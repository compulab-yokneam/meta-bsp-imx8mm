From 6dd11102e42373f7b0e64fcee674ae77e65cd093 Mon Sep 17 00:00:00 2001
From: Uri Mashiach <uri.mashiach@compulab.co.il>
Date: Wed, 25 Mar 2020 19:41:29 +0200
Subject: [PATCH 24/70] can: mcp25xxfd: Microchip MCP25xxFD Family CAN
 controller driver

The driver was taken from the linux-can-next project.
Adjusted to kernel 4.14.98.

Signed-off-by: Uri Mashiach <uri.mashiach@compulab.co.il>
Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 arch/arm64/configs/mcm-imx8m-mini_defconfig      |    1 +
 drivers/net/can/rx-offload.c                     |   11 +
 drivers/net/can/spi/Kconfig                      |    2 +
 drivers/net/can/spi/Makefile                     |    2 +
 drivers/net/can/spi/mcp25xxfd/Kconfig            |   25 +
 drivers/net/can/spi/mcp25xxfd/Makefile           |   11 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c   | 2302 ++++++++++++++++++++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c  |   82 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c   |  685 +++++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c    |  105 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h    |  164 ++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c |  268 +++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h        |  757 +++++++
 include/linux/can/rx-offload.h                   |    3 +
 14 files changed, 4418 insertions(+)
 create mode 100644 drivers/net/can/spi/mcp25xxfd/Kconfig
 create mode 100644 drivers/net/can/spi/mcp25xxfd/Makefile
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h

diff --git a/arch/arm64/configs/mcm-imx8m-mini_defconfig b/arch/arm64/configs/mcm-imx8m-mini_defconfig
index 7d20477c69e6..d409796b0f08 100644
--- a/arch/arm64/configs/mcm-imx8m-mini_defconfig
+++ b/arch/arm64/configs/mcm-imx8m-mini_defconfig
@@ -128,6 +128,7 @@ CONFIG_NET_SWITCHDEV=y
 CONFIG_BPF_JIT=y
 CONFIG_CAN=m
 CONFIG_CAN_FLEXCAN=m
+CONFIG_CAN_MCP25XXFD=m
 CONFIG_BT=y
 CONFIG_BT_RFCOMM=y
 CONFIG_BT_RFCOMM_TTY=y
diff --git a/drivers/net/can/rx-offload.c b/drivers/net/can/rx-offload.c
index e3b9d44609fe..e674756f2421 100644
--- a/drivers/net/can/rx-offload.c
+++ b/drivers/net/can/rx-offload.c
@@ -363,3 +363,14 @@ void can_rx_offload_del(struct can_rx_offload *offload)
 	skb_queue_purge(&offload->skb_queue);
 }
 EXPORT_SYMBOL_GPL(can_rx_offload_del);
+
+int can_rx_offload_add_manual(struct net_device *dev,
+			      struct can_rx_offload *offload,
+			      unsigned int weight)
+{
+	if (offload->mailbox_read)
+		return -EINVAL;
+
+	return can_rx_offload_init_queue(dev, offload, weight);
+}
+EXPORT_SYMBOL_GPL(can_rx_offload_add_manual);
diff --git a/drivers/net/can/spi/Kconfig b/drivers/net/can/spi/Kconfig
index 1c50788055cb..d4b68eb5d386 100644
--- a/drivers/net/can/spi/Kconfig
+++ b/drivers/net/can/spi/Kconfig
@@ -15,4 +15,6 @@ config CAN_MCP251X
 	  Driver for the Microchip MCP251x and MCP25625 SPI CAN
 	  controllers.
 
+source "drivers/net/can/spi/mcp25xxfd/Kconfig"
+
 endmenu
diff --git a/drivers/net/can/spi/Makefile b/drivers/net/can/spi/Makefile
index f115b2c46623..769197785331 100644
--- a/drivers/net/can/spi/Makefile
+++ b/drivers/net/can/spi/Makefile
@@ -6,3 +6,5 @@
 
 obj-$(CONFIG_CAN_HI311X)	+= hi311x.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
+
+obj-y				+= mcp25xxfd/
diff --git a/drivers/net/can/spi/mcp25xxfd/Kconfig b/drivers/net/can/spi/mcp25xxfd/Kconfig
new file mode 100644
index 000000000000..e5fbaf8e46e1
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/Kconfig
@@ -0,0 +1,25 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config CAN_MCP25XXFD
+	tristate "Microchip MCP25xxFD SPI CAN controllers"
+	help
+	  Driver for the Microchip MCP25XXFD SPI FD-CAN controller
+	  family.
+
+config CAN_MCP25XXFD_SANITY
+	depends on CAN_MCP25XXFD
+	bool "Additional Sanity Checks"
+	help
+	  This option enables additional sanity checks in the driver,
+	  that compares various internal counters with the in chip
+	  variants. This comes with a runtime overhead.
+	  Disable if unsure.
+
+config CAN_MCP25XXFD_LOG
+	depends on CAN_MCP25XXFD
+	bool "Logging"
+	help
+	  This option enables logging of events in the driver, that
+	  help debugging. This comes with a very small runtime
+	  overhead.
+	  Disable if unsure.
diff --git a/drivers/net/can/spi/mcp25xxfd/Makefile b/drivers/net/can/spi/mcp25xxfd/Makefile
new file mode 100644
index 000000000000..9a22a1a73954
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-$(CONFIG_CAN_MCP25XXFD) += mcp25xxfd.o
+
+mcp25xxfd-objs :=
+mcp25xxfd-objs += mcp25xxfd-core.o
+mcp25xxfd-objs += mcp25xxfd-crc16.o
+mcp25xxfd-objs += mcp25xxfd-dump.o
+mcp25xxfd-objs += mcp25xxfd-regmap.o
+
+mcp25xxfd-$(CONFIG_CAN_MCP25XXFD_LOG) += mcp25xxfd-log.o
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
new file mode 100644
index 000000000000..a74cac6a7cbf
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
@@ -0,0 +1,2302 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+// Based on:
+//
+// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+//
+// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+//
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/ipu.h>
+
+#include <asm/unaligned.h>
+
+#include "mcp25xxfd.h"
+
+#define DEVICE_NAME "mcp25xxfd"
+
+#define MCP25XXFD_SYSCLOCK_HZ_MAX 40000000
+#define MCP25XXFD_SYSCLOCK_HZ_MIN 1000000
+#define MCP25XXFD_SPICLOCK_HZ_MAX 20000000
+#define MCP25XXFD_OSC_PLL_MULTIPLIER 10
+#define MCP25XXFD_OSC_DELAY_MS 3
+
+/* DS80000792B - MCP2517FD Errata
+ *
+ * Incorrect CRC for certain READ_CRC commands
+ *
+ * It is possible that there is a mismatch between the transmitted CRC
+ * and the actual CRC for the transmitted data when data is updated at
+ * a specific time during the SPI READ_CRC command. In these cases the
+ * transmitted CRC is wrong. The data transmitted is correct.
+ *
+ * Fix/Work Around:
+ *
+ * If a CRC mismatch occurs, reissue the READ_CRC command. Only bits
+ * 7/15/23/31 of the following registers can be affected:
+ *
+ * - CiTXIF		(*)
+ * - CiRXIF		(*)
+ * - CiCON
+ * - CiTBC
+ * - CiINT
+ * - CiRXOVIF		(*)
+ * - CiTXATIF		(*)
+ * - CiTXREQ		(*)
+ * - CiTREC
+ * - CiBDIAG0
+ * - CiBDIAG1
+ * - CiTXQSTA
+ * - CiFIFOSTAm
+ *
+ * The occurrence can be minimized by not using FIFOs 7/15/23/31. In
+ * these cases, the registers CiTXIF, CiRXIF, CiRXOVIF, CiTXATIF and
+ * CiTXREQ are not affected.
+ *
+ * Bit 31 of RAM reads with CRC could also be affected. This can be
+ * avoided by reading from a received FIFO only after the message has
+ * been loaded into the FIFO, indicated by the receive flags. This is
+ * the recommended procedure independent of the issue described here.
+ */
+
+static const struct can_bittiming_const mcp25xxfd_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 2,
+	.tseg1_max = 256,
+	.tseg2_min = 1,
+	.tseg2_max = 128,
+	.sjw_max = 128,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+static const struct can_bittiming_const mcp25xxfd_data_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 32,
+	.tseg2_min = 1,
+	.tseg2_max = 16,
+	.sjw_max = 16,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+static const char *mcp25xxfd_get_mode_str(const u8 mode)
+{
+	switch (mode) {
+	case MCP25XXFD_CAN_CON_MODE_MIXED:
+		return "Mixed (CAN FD/CAN 2.0)"; break;
+	case MCP25XXFD_CAN_CON_MODE_SLEEP:
+		return "Sleep"; break;
+	case MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK:
+		return "Internal Loopback"; break;
+	case MCP25XXFD_CAN_CON_MODE_LISTENONLY:
+		return "Listen Only"; break;
+	case MCP25XXFD_CAN_CON_MODE_CONFIG:
+		return "Configuration"; break;
+	case MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK:
+		return "External Loopback"; break;
+	case MCP25XXFD_CAN_CON_MODE_CAN2_0:
+		return "CAN 2.0"; break;
+	case MCP25XXFD_CAN_CON_MODE_RESTRICTED:
+		return "Restricted Operation"; break;
+	}
+
+	return "<unknown>";
+}
+
+static inline int mcp25xxfd_vdd_enable(const struct mcp25xxfd_priv *priv)
+{
+	if (!priv->reg_vdd)
+		return 0;
+
+	return regulator_enable(priv->reg_vdd);
+}
+
+static inline int mcp25xxfd_vdd_disable(const struct mcp25xxfd_priv *priv)
+{
+	if (!priv->reg_vdd)
+		return 0;
+
+	return regulator_disable(priv->reg_vdd);
+}
+
+static inline int
+mcp25xxfd_transceiver_enable(const struct mcp25xxfd_priv *priv)
+{
+	if (!priv->reg_xceiver)
+		return 0;
+
+	return regulator_enable(priv->reg_xceiver);
+}
+
+static inline int
+mcp25xxfd_transceiver_disable(const struct mcp25xxfd_priv *priv)
+{
+	if (!priv->reg_xceiver)
+		return 0;
+
+	return regulator_disable(priv->reg_xceiver);
+}
+
+static int mcp25xxfd_clks_and_vdd_enable(const struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	err = mcp25xxfd_vdd_enable(priv);
+	if (err)
+		clk_disable_unprepare(priv->clk);
+
+	return err;
+}
+
+static int mcp25xxfd_clks_and_vdd_disable(const struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = mcp25xxfd_vdd_disable(priv);
+	if (err)
+		return err;
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_cmd_prepare_write(struct mcp25xxfd_reg_write_buf *write_reg_buf,
+			    const u16 reg, const u32 mask, const u32 val)
+{
+	u8 first_byte, last_byte, len;
+	__le32 val_le32;
+
+	first_byte = mcp25xxfd_first_byte_set(mask);
+	last_byte = mcp25xxfd_last_byte_set(mask);
+	len = last_byte - first_byte + 1;
+
+	write_reg_buf->cmd = mcp25xxfd_cmd_write(reg + first_byte);
+	val_le32 = cpu_to_le32(val >> 8 * first_byte);
+	memcpy(write_reg_buf->data, &val_le32, len);
+
+	return sizeof(write_reg_buf->cmd) + len;
+}
+
+static inline int
+mcp25xxfd_tef_obj_tail_get_rel_addr_from_chip(const struct mcp25xxfd_priv *priv,
+					      u16 *tef_obj_tail_rel_addr)
+{
+	int err;
+	u32 tef_ua;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TEFUA, &tef_ua);
+	if (err)
+		return err;
+
+	*tef_obj_tail_rel_addr = tef_ua;
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_tef_tail_get_from_chip(const struct mcp25xxfd_priv *priv,
+				 u8 *tef_tail)
+{
+	int err;
+	u16 tef_obj_tail_rel_addr;
+
+	err = mcp25xxfd_tef_obj_tail_get_rel_addr_from_chip(priv,
+							    &tef_obj_tail_rel_addr);
+	if (err)
+		return err;
+
+	*tef_tail = tef_obj_tail_rel_addr / sizeof(struct mcp25xxfd_hw_tef_obj);
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_rx_obj_tail_get_rel_addr_from_chip(const struct mcp25xxfd_priv *priv,
+					     u16 *rx_obj_tail_rel_addr)
+{
+	int err;
+	u32 fifo_ua;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_FIFOUA(MCP25XXFD_RX_FIFO(0)),
+			  &fifo_ua);
+	if (err)
+		return err;
+
+	*rx_obj_tail_rel_addr = fifo_ua;
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_rx_tail_get_from_chip(const struct mcp25xxfd_priv *priv, u8 *rx_tail)
+{
+	int err;
+	u16 rx_obj_tail_rel_addr;
+
+	err = mcp25xxfd_rx_obj_tail_get_rel_addr_from_chip(priv,
+							   &rx_obj_tail_rel_addr);
+	if (err)
+		return err;
+
+	rx_obj_tail_rel_addr -= (sizeof(struct mcp25xxfd_hw_tef_obj) +
+				 priv->tx.obj_size) * priv->tx.obj_num;
+	*rx_tail = rx_obj_tail_rel_addr / priv->rx.obj_size;
+
+	return 0;
+}
+
+static void
+mcp25xxfd_tx_ring_init_one(const struct mcp25xxfd_priv *priv,
+			   struct mcp25xxfd_tx_obj *tx_obj, const u8 n)
+{
+	u32 val;
+	u16 addr;
+	u8 len;
+
+	/* FIFO load */
+	addr = mcp25xxfd_get_tx_obj_addr(priv, n);
+	tx_obj->load.buf.cmd = mcp25xxfd_cmd_write(addr);
+	/* len is calculated on the fly */
+
+	spi_message_init_with_transfers(&tx_obj->load.msg,
+					&tx_obj->load.xfer, 1);
+	tx_obj->load.xfer.tx_buf = &tx_obj->load.buf;
+	/* len is assigned on the fly */
+
+	/* FIFO trigger */
+	addr = MCP25XXFD_CAN_FIFOCON(MCP25XXFD_TX_FIFO);
+	val = MCP25XXFD_CAN_FIFOCON_TXREQ | MCP25XXFD_CAN_FIFOCON_UINC;
+	len = mcp25xxfd_cmd_prepare_write(&tx_obj->trigger.buf, addr, val, val);
+
+	spi_message_init_with_transfers(&tx_obj->trigger.msg,
+					&tx_obj->trigger.xfer, 1);
+	tx_obj->trigger.xfer.tx_buf = &tx_obj->trigger.buf;
+	tx_obj->trigger.xfer.len = len;
+}
+
+static void mcp25xxfd_ring_init(struct mcp25xxfd_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(priv->tx.obj); i++) {
+		struct mcp25xxfd_tx_obj *tx_obj = &priv->tx.obj[i];
+
+		mcp25xxfd_tx_ring_init_one(priv, tx_obj, i);
+	}
+
+	priv->tef.head = 0;
+	priv->tef.tail = 0;
+	priv->tx.head = 0;
+	priv->tx.tail = 0;
+	priv->rx.head = 0;
+	priv->rx.tail = 0;
+}
+
+static inline int
+mcp25xxfd_chip_get_mode(const struct mcp25xxfd_priv *priv, u8 *mode)
+{
+	u32 val;
+	int err;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_CON, &val);
+	if (err)
+		return err;
+
+	*mode = FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK, val);
+
+	return 0;
+}
+
+static int
+__mcp25xxfd_chip_set_mode(const struct mcp25xxfd_priv *priv,
+			  const u8 mode_req, bool nowait)
+{
+	u32 con, con_reqop;
+	int err;
+
+	con_reqop = FIELD_PREP(MCP25XXFD_CAN_CON_REQOP_MASK, mode_req);
+	err = regmap_update_bits(priv->map, MCP25XXFD_CAN_CON,
+				 MCP25XXFD_CAN_CON_REQOP_MASK, con_reqop);
+	if (err)
+		return err;
+
+	if (mode_req == MCP25XXFD_CAN_CON_MODE_SLEEP || nowait)
+		return 0;
+
+	err = regmap_read_poll_timeout(priv->map, MCP25XXFD_CAN_CON, con,
+				       FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK,
+						 con) == mode_req,
+				       10000, 1000000);
+	if (err) {
+		u8 mode = FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK, con);
+
+		netdev_err(priv->ndev,
+			   "Controller failed to enter mode %s Mode (%u) and stays in %s Mode (%u).\n",
+			   mcp25xxfd_get_mode_str(mode_req), mode_req,
+			   mcp25xxfd_get_mode_str(mode), mode);
+		return err;
+	}
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_chip_set_mode(const struct mcp25xxfd_priv *priv,
+			const u8 mode_req)
+{
+	return __mcp25xxfd_chip_set_mode(priv, mode_req, false);
+}
+
+static inline int
+mcp25xxfd_chip_set_mode_nowait(const struct mcp25xxfd_priv *priv,
+			       const u8 mode_req)
+{
+	return __mcp25xxfd_chip_set_mode(priv, mode_req, true);
+}
+
+static int mcp25xxfd_chip_clock_enable(const struct mcp25xxfd_priv *priv)
+{
+	u32 osc, osc_reference, osc_mask;
+	int err;
+
+	/* Set Power On Defaults for "Clock Output Divisor" and remove
+	 * "Oscillator Disable" bit.
+	 */
+	osc = FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK, MCP25XXFD_OSC_CLKODIV_10);
+	osc_reference = MCP25XXFD_OSC_OSCRDY;
+	osc_mask = MCP25XXFD_OSC_OSCRDY | MCP25XXFD_OSC_PLLRDY;
+
+	/* Note:
+	 *
+	 * If the controller is in Sleep Mode the following write only
+	 * removes the "Oscillator Disable" bit and powers it up. All
+	 * other bits are unaffected.
+	 */
+	err = regmap_write(priv->map, MCP25XXFD_OSC, osc);
+	if (err)
+		return err;
+
+	/* Wait for "Oscillator Ready" bit */
+	return regmap_read_poll_timeout(priv->map, MCP25XXFD_OSC, osc,
+					(osc & osc_mask) == osc_reference,
+					10000, 1000000);
+}
+
+static int mcp25xxfd_chip_clock_init(const struct mcp25xxfd_priv *priv)
+{
+	u32 osc;
+	int err;
+
+	/* Activate Low Power Mode on Oscillator Disable. This only
+	 * works on the MCP2518FD. The MCP2517FD will go into normal
+	 * Sleep Mode instead.
+	 */
+	osc = MCP25XXFD_OSC_LPMEN |
+		FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK,
+			   MCP25XXFD_OSC_CLKODIV_10);
+	err = regmap_write(priv->map, MCP25XXFD_OSC, osc);
+	if (err)
+		return err;
+
+	/* Set Time Base Counter Prescaler to 1.
+	 *
+	 * This means an overflow of the 32 bit Time Base Counter
+	 * register at 40 MHz every 107 seconds.
+	 */
+	return regmap_write(priv->map, MCP25XXFD_CAN_TSCON,
+			    MCP25XXFD_CAN_TSCON_TBCEN);
+}
+
+static int mcp25xxfd_chip_softreset(const struct mcp25xxfd_priv *priv)
+{
+	const __be16 cmd = mcp25xxfd_cmd_reset();
+	u8 mode;
+	int err;
+
+	/* The Set Mode and SPI Reset command only seems to works if
+	 * the controller is not in Sleep Mode.
+	 */
+	err = mcp25xxfd_chip_clock_enable(priv);
+	if (err)
+		return err;
+
+	err = mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_CONFIG);
+	if (err)
+		return err;
+
+	/* spi_write_then_read() works with non DMA-safe buffers */
+	err = spi_write_then_read(priv->spi, &cmd, sizeof(cmd), NULL, 0);
+	if (err)
+		return err;
+
+	err = mcp25xxfd_chip_get_mode(priv, &mode);
+	if (err)
+		return err;
+
+	if (mode != MCP25XXFD_CAN_CON_MODE_CONFIG) {
+		netdev_err(priv->ndev,
+			   "Controller not in Config Mode after reset, but in %s Mode (%u).\n",
+			   mcp25xxfd_get_mode_str(mode), mode);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_set_bittiming(const struct mcp25xxfd_priv *priv)
+{
+	const struct can_bittiming *bt = &priv->can.bittiming;
+	const struct can_bittiming *dbt = &priv->can.data_bittiming;
+	u32 val = 0;
+	s8 tdco;
+	int err;
+
+	/* CAN Control Register
+	 *
+	 * - no transmit bandwidth sharing
+	 * - config mode
+	 * - disable transmit queue
+	 * - store in transmit FIFO event
+	 * - transition to restricted operation mode on system error
+	 * - ESI is transmitted recessive when ESI of message is high or
+	 *   CAN controller error passive
+	 * - restricted retransmission attempts,
+	 *   use TQXCON_TXAT and FIFOCON_TXAT
+	 * - wake-up filter bits T11FILTER
+	 * - use CAN bus line filter for wakeup
+	 * - protocol exception is treated as a form error
+	 * - Do not compare data bytes
+	 */
+	val = FIELD_PREP(MCP25XXFD_CAN_CON_REQOP_MASK,
+			 MCP25XXFD_CAN_CON_MODE_CONFIG) |
+		MCP25XXFD_CAN_CON_STEF |
+		MCP25XXFD_CAN_CON_ESIGM |
+		MCP25XXFD_CAN_CON_RTXAT |
+		FIELD_PREP(MCP25XXFD_CAN_CON_WFT_MASK,
+			   MCP25XXFD_CAN_CON_WFT_T11FILTER) |
+		MCP25XXFD_CAN_CON_WAKFIL |
+		MCP25XXFD_CAN_CON_PXEDIS;
+
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
+		val |= MCP25XXFD_CAN_CON_ISOCRCEN;
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_CON, val);
+	if (err)
+		return err;
+
+	/* Nominal Bit Time */
+	val = FIELD_PREP(MCP25XXFD_CAN_NBTCFG_BRP_MASK, bt->brp - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_TSEG1_MASK,
+			   bt->prop_seg + bt->phase_seg1 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_TSEG2_MASK,
+			   bt->phase_seg2 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_SJW_MASK, bt->sjw - 1);
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_NBTCFG, val);
+	if (err)
+		return err;
+
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))
+		return 0;
+
+	/* Data Bit Time */
+	val = FIELD_PREP(MCP25XXFD_CAN_DBTCFG_BRP_MASK, dbt->brp - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_TSEG1_MASK,
+			   dbt->prop_seg + dbt->phase_seg1 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_TSEG2_MASK,
+			   dbt->phase_seg2 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_SJW_MASK, dbt->sjw - 1);
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_DBTCFG, val);
+	if (err)
+		return err;
+
+	/* Transmitter Delay Compensation */
+	tdco = clamp_t(int, dbt->brp * (dbt->prop_seg + dbt->phase_seg1),
+		       -64, 63);
+	val = FIELD_PREP(MCP25XXFD_CAN_TDC_TDCMOD_MASK,
+			 MCP25XXFD_CAN_TDC_TDCMOD_AUTO) |
+		FIELD_PREP(MCP25XXFD_CAN_TDC_TDCO_MASK, tdco);
+
+	return regmap_write(priv->map, MCP25XXFD_CAN_TDC, val);
+}
+
+static int mcp25xxfd_chip_pinctrl_init(const struct mcp25xxfd_priv *priv)
+{
+	u32 val;
+
+	if (!priv->rx_int)
+		return 0;
+
+	/* Configure GPIOs:
+	 * - PIN0: GPIO Input
+	 * - PIN1: RX Interrupt
+	 */
+	val = MCP25XXFD_IOCON_PM0 | MCP25XXFD_IOCON_TRIS0;
+	return regmap_write(priv->map, MCP25XXFD_IOCON, val);
+}
+
+static int mcp25xxfd_chip_fifo_compute(struct mcp25xxfd_priv *priv)
+{
+	int tef_obj_size, tx_obj_size, rx_obj_size;
+	int tx_obj_num, rx_obj_num;
+	int ram_free;
+
+	tef_obj_size = sizeof(struct mcp25xxfd_hw_tef_obj);
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD) {
+		tx_obj_num = MCP25XXFD_TX_OBJ_NUM_CANFD;
+		tx_obj_size = sizeof(struct mcp25xxfd_hw_tx_obj_canfd);
+		rx_obj_size = sizeof(struct mcp25xxfd_hw_rx_obj_canfd);
+	} else {
+		tx_obj_num = MCP25XXFD_TX_OBJ_NUM_CAN;
+		tx_obj_size = sizeof(struct mcp25xxfd_hw_tx_obj_can);
+		rx_obj_size = sizeof(struct mcp25xxfd_hw_rx_obj_can);
+	}
+
+	ram_free = MCP25XXFD_RAM_SIZE - tx_obj_num *
+		(tef_obj_size + tx_obj_size);
+	rx_obj_num = min(ram_free / rx_obj_size, 32);
+	ram_free -= rx_obj_num * rx_obj_size;
+
+	if ((priv->can.ctrlmode & CAN_CTRLMODE_FD &&
+	     rx_obj_num > MCP25XXFD_RX_OBJ_NUM_CANFD) ||
+	    (!(priv->can.ctrlmode & CAN_CTRLMODE_FD) &&
+	     rx_obj_num > MCP25XXFD_RX_OBJ_NUM_CAN)) {
+		netdev_err(priv->ndev,
+			   "Too many rx-objects (calculated=%d, max=%d).\n",
+			   rx_obj_num, priv->can.ctrlmode & CAN_CTRLMODE_FD ?
+			   MCP25XXFD_RX_OBJ_NUM_CANFD :
+			   MCP25XXFD_RX_OBJ_NUM_CAN);
+		return -ENOMEM;
+	}
+
+	priv->tx.obj_num = tx_obj_num;
+	priv->tx.obj_size = tx_obj_size;
+	priv->rx.obj_num = rx_obj_num;
+	priv->rx.obj_size = rx_obj_size;
+
+	netdev_dbg(priv->ndev,
+		   "FIFO setup: tef: %d*%d bytes = %d bytes, tx: %d*%d bytes = %d, rx: %d*%d bytes = %d bytes, free: %d bytes.\n",
+		   tx_obj_num, tef_obj_size, tef_obj_size * tx_obj_num,
+		   tx_obj_num, tx_obj_size, tx_obj_size * tx_obj_num,
+		   rx_obj_num, rx_obj_size, rx_obj_size * rx_obj_num,
+		   ram_free);
+
+	return 0;
+}
+
+static int mcp25xxfd_chip_fifo_init(struct mcp25xxfd_priv *priv)
+{
+	u32 val;
+	int err;
+
+	err = mcp25xxfd_chip_fifo_compute(priv);
+	if (err)
+		return err;
+
+	mcp25xxfd_ring_init(priv);
+
+	/* TEF */
+	val = FIELD_PREP(MCP25XXFD_CAN_TEFCON_FSIZE_MASK,
+			 priv->tx.obj_num - 1) |
+		MCP25XXFD_CAN_TEFCON_TEFTSEN |
+		MCP25XXFD_CAN_TEFCON_TEFOVIE |
+		MCP25XXFD_CAN_TEFCON_TEFNEIE;
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_TEFCON, val);
+	if (err)
+		return err;
+
+	/* FIFO 1 - TX */
+	val = FIELD_PREP(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK,
+			 priv->tx.obj_num - 1) |
+		MCP25XXFD_CAN_FIFOCON_TXEN |
+		MCP25XXFD_CAN_FIFOCON_TXATIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_64);
+	else
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_8);
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_TXAT_MASK,
+				  MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT);
+	else
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_TXAT_MASK,
+				  MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED);
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_FIFOCON(MCP25XXFD_TX_FIFO),
+			   val);
+	if (err)
+		return err;
+
+	/* FIFO 2 - RX */
+	val = FIELD_PREP(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK,
+			 priv->rx.obj_num - 1) |
+		MCP25XXFD_CAN_FIFOCON_RXTSEN |
+		MCP25XXFD_CAN_FIFOCON_RXOVIE |
+		MCP25XXFD_CAN_FIFOCON_TFNRFNIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_64);
+	else
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_8);
+
+	err = regmap_write(priv->map,
+			   MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)), val);
+	if (err)
+		return err;
+
+	/* RX Filter */
+	val = MCP25XXFD_CAN_FLTCON_FLTEN0 |
+		FIELD_PREP(MCP25XXFD_CAN_FLTCON_F0BP_MASK,
+			   MCP25XXFD_RX_FIFO(0));
+	return regmap_write(priv->map, MCP25XXFD_CAN_FLTCON(0), val);
+}
+
+static int mcp25xxfd_chip_ecc_init(const struct mcp25xxfd_priv *priv)
+{
+	void *ram;
+	int err;
+
+	ram = kzalloc(MCP25XXFD_RAM_SIZE, GFP_KERNEL);
+	if (!ram)
+		return -ENOMEM;
+
+	err = regmap_raw_write(priv->map, MCP25XXFD_RAM_START, ram,
+			       MCP25XXFD_RAM_SIZE);
+	kfree(ram);
+
+	return err;
+}
+
+static u8 mcp25xxfd_get_normal_mode(const struct mcp25xxfd_priv *priv)
+{
+	u8 mode;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		mode = MCP25XXFD_CAN_CON_MODE_MIXED;
+	else
+		mode = MCP25XXFD_CAN_CON_MODE_CAN2_0;
+
+	return mode;
+}
+
+static int
+__mcp25xxfd_chip_set_normal_mode(const struct mcp25xxfd_priv *priv,
+				 bool nowait)
+{
+	u8 mode;
+
+	mode = mcp25xxfd_get_normal_mode(priv);
+
+	return __mcp25xxfd_chip_set_mode(priv, mode, nowait);
+}
+
+static inline int
+mcp25xxfd_chip_set_normal_mode(const struct mcp25xxfd_priv *priv)
+{
+	return __mcp25xxfd_chip_set_normal_mode(priv, false);
+}
+
+static inline int
+mcp25xxfd_chip_set_normal_mode_nowait(const struct mcp25xxfd_priv *priv)
+{
+	return __mcp25xxfd_chip_set_normal_mode(priv, true);
+}
+
+static int mcp25xxfd_chip_interrupts_enable(const struct mcp25xxfd_priv *priv)
+{
+	u32 val;
+	int err;
+
+	val = MCP25XXFD_CAN_INT_CERRIE |
+		MCP25XXFD_CAN_INT_SERRIE |
+		MCP25XXFD_CAN_INT_RXOVIE |
+		MCP25XXFD_CAN_INT_TXATIE |
+		MCP25XXFD_CAN_INT_SPICRCIE |
+		MCP25XXFD_CAN_INT_ECCIE |
+		MCP25XXFD_CAN_INT_TEFIE |
+		MCP25XXFD_CAN_INT_MODIE |
+		MCP25XXFD_CAN_INT_RXIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
+		val |= MCP25XXFD_CAN_INT_IVMIE;
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_INT, val);
+	if (err)
+		return err;
+
+	val = MCP25XXFD_CRC_FERRIE |
+		MCP25XXFD_CRC_CRCERRIE;
+	err = regmap_write(priv->map, MCP25XXFD_CRC, val);
+	if (err)
+		return err;
+
+	val = MCP25XXFD_ECCCON_DEDIE |
+		MCP25XXFD_ECCCON_SECIE |
+		MCP25XXFD_ECCCON_ECCEN;
+	return regmap_write(priv->map, MCP25XXFD_ECCCON, val);
+}
+
+static int mcp25xxfd_chip_interrupts_disable(const struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = regmap_write(priv->map, MCP25XXFD_ECCCON, 0);
+	if (err)
+		return err;
+
+	err = regmap_write(priv->map, MCP25XXFD_CRC, 0);
+	if (err)
+		return err;
+
+	return regmap_write(priv->map, MCP25XXFD_CAN_INT, 0);
+}
+
+static int mcp25xxfd_chip_start(struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = mcp25xxfd_chip_softreset(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_clock_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_set_bittiming(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_pinctrl_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_fifo_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_ecc_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	/* Note:
+	 *
+	 * First enable the interrupts, then bring the chip into
+	 * Normal Mode. Otherwise on a MCP2517FD a burst of CAN
+	 * messages on the bus may result in overwritten RX FIFO
+	 * contents and ECC errors.
+	 *
+	 * The current theory is that the SPI read access disturbes
+	 * the RX process in the chip.
+	 */
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	err = mcp25xxfd_chip_interrupts_enable(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_set_normal_mode(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	return 0;
+
+ out_chip_set_mode_sleep:
+	mcp25xxfd_chip_interrupts_disable(priv);
+	mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+	priv->can.state = CAN_STATE_STOPPED;
+
+	return err;
+}
+
+static int mcp25xxfd_chip_stop(struct mcp25xxfd_priv *priv,
+			       const enum can_state state)
+{
+	priv->can.state = state;
+
+	mcp25xxfd_chip_interrupts_disable(priv);
+	return mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+}
+
+static int mcp25xxfd_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	int err;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		err = mcp25xxfd_chip_start(priv);
+		if (err)
+			return err;
+
+		netif_wake_queue(ndev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_get_berr_counter(const struct net_device *ndev,
+				      struct can_berr_counter *bec)
+{
+	const struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	u32 trec;
+	int err;
+
+	/* Avoid waking up the controller when the interface is down. */
+	if (!(ndev->flags & IFF_UP))
+		return 0;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TREC, &trec);
+	if (err)
+		return err;
+
+	bec->txerr = FIELD_GET(MCP25XXFD_CAN_TREC_TEC_MASK, trec);
+	bec->rxerr = FIELD_GET(MCP25XXFD_CAN_TREC_REC_MASK, trec);
+
+	return 0;
+}
+
+static int mcp25xxfd_check_tef_tail(struct mcp25xxfd_priv *priv)
+{
+	u8 tef_tail_chip, tef_tail;
+	int err;
+
+	if (!IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY))
+		return 0;
+
+	err = mcp25xxfd_tef_tail_get_from_chip(priv, &tef_tail_chip);
+	if (err)
+		return err;
+
+	mcp25xxfd_log_hw_tef_tail(priv, tef_tail_chip);
+
+	tef_tail = mcp25xxfd_get_tef_tail(priv);
+	if (tef_tail_chip != tef_tail) {
+		netdev_err(priv->ndev,
+			   "TEF tail of chip (0x%02x) and ours (0x%08x) inconsistent.\n",
+			   tef_tail_chip, tef_tail);
+		return -EILSEQ;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_check_rx_tail(const struct mcp25xxfd_priv *priv)
+{
+	u8 rx_tail_chip, rx_tail;
+	int err;
+
+	if (!IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY))
+		return 0;
+
+	err = mcp25xxfd_rx_tail_get_from_chip(priv, &rx_tail_chip);
+	if (err)
+		return err;
+
+	rx_tail = mcp25xxfd_get_rx_tail(priv);
+	if (rx_tail_chip != rx_tail) {
+		netdev_err(priv->ndev,
+			   "RX tail of chip (%d) and ours (%d) inconsistent.\n",
+			   rx_tail_chip, rx_tail);
+		return -EILSEQ;
+	}
+
+	return 0;
+}
+
+static int
+mcp25xxfd_handle_tefif_recover(const struct mcp25xxfd_priv *priv, const u32 seq)
+{
+	u32 tef_sta;
+	int err;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TEFSTA, &tef_sta);
+	if (err)
+		return err;
+
+	if (tef_sta & MCP25XXFD_CAN_TEFSTA_TEFOVIF) {
+		netdev_err(priv->ndev,
+			   "Transmit Event FIFO buffer overflow.\n");
+		return -ENOBUFS;
+	}
+
+	netdev_info(priv->ndev,
+		   "Transmit Event FIFO buffer %s (seq=0x%08x, tef_tail=0x%08x, tef_head=0x%08x, tx_head=0x%08x)\n",
+		   tef_sta & MCP25XXFD_CAN_TEFSTA_TEFNEIF ?
+		   "empty." : "not empty anymore?",
+		   seq, priv->tef.tail, priv->tef.head, priv->tx.head);
+
+	return -EAGAIN;
+}
+
+static int
+mcp25xxfd_handle_tefif_one(struct mcp25xxfd_priv *priv,
+			   const struct mcp25xxfd_hw_tef_obj *hw_tef_obj)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	u32 seq, seq_masked, tef_tail_masked;
+	int err;
+
+	seq = FIELD_GET(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
+			hw_tef_obj->flags);
+
+	/* Use the MCP2517FD mask on the MCP2518FD, too. We only
+	 * compare 7 bits, this should be enough to detect
+	 * net-yet-completed, i.e. old TEF objects.
+	 */
+	seq_masked = seq &
+		field_mask(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
+	tef_tail_masked = priv->tef.tail &
+		field_mask(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
+	if (seq_masked != tef_tail_masked)
+		return mcp25xxfd_handle_tefif_recover(priv, seq);
+
+	mcp25xxfd_log(priv, hw_tef_obj->id);
+
+	stats->tx_bytes +=
+		can_rx_offload_get_echo_skb(&priv->offload,
+					    mcp25xxfd_get_tef_tail(priv),
+					    hw_tef_obj->ts);
+	stats->tx_packets++;
+
+	/* finally increment the TEF pointer */
+	err = regmap_update_bits(priv->map, MCP25XXFD_CAN_TEFCON,
+				 GENMASK(15, 8),
+				 MCP25XXFD_CAN_TEFCON_UINC);
+	if (err)
+		return err;
+
+	priv->tx.tail++;
+	priv->tef.tail++;
+
+	return mcp25xxfd_check_tef_tail(priv);
+}
+
+static int mcp25xxfd_tef_ring_update(struct mcp25xxfd_priv *priv)
+{
+	u32 fifo_sta, new_head;
+	u8 tx_ci;
+	int err;
+
+	/* guess head */
+	err = regmap_read(priv->map, MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_TX_FIFO),
+			  &fifo_sta);
+	if (err)
+		return err;
+
+	tx_ci = FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, fifo_sta);
+	new_head = round_down(priv->tef.head, priv->tx.obj_num) + tx_ci;
+
+	if (new_head <= priv->tef.head)
+		new_head += priv->tx.obj_num;
+
+	priv->tef.head = min(new_head, priv->tx.head);
+
+	mcp25xxfd_log_hw_tx_ci(priv, tx_ci);
+
+	return mcp25xxfd_check_tef_tail(priv);
+}
+
+static inline int
+mcp25xxfd_tef_obj_read(const struct mcp25xxfd_priv *priv,
+		       struct mcp25xxfd_hw_tef_obj *hw_tef_obj,
+		       const u8 offset, const u8 len)
+{
+	if (IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY) &&
+	    (offset > priv->tx.obj_num ||
+	     len > priv->tx.obj_num ||
+	     offset + len > priv->tx.obj_num)) {
+		netdev_err(priv->ndev,
+			   "Trying to read to many TEF objects (max=%d, offset=%d, len=%d).\n",
+			   priv->tx.obj_num, offset, len);
+		return -ERANGE;
+	}
+
+	return regmap_bulk_read(priv->map,
+				mcp25xxfd_get_tef_obj_addr(priv, offset),
+				hw_tef_obj,
+				sizeof(*hw_tef_obj) / sizeof(u32) * len);
+}
+
+static int mcp25xxfd_handle_tefif(struct mcp25xxfd_priv *priv)
+{
+	struct mcp25xxfd_hw_tef_obj hw_tef_obj[MCP25XXFD_TX_OBJ_NUM_MAX];
+	u8 tef_tail, len, l;
+	int err, i;
+
+	err = mcp25xxfd_tef_ring_update(priv);
+	if (err)
+		return err;
+
+	tef_tail = mcp25xxfd_get_tef_tail(priv);
+	len = mcp25xxfd_get_tef_len(priv);
+	l = mcp25xxfd_get_tef_linear_len(priv);
+	err = mcp25xxfd_tef_obj_read(priv, hw_tef_obj, tef_tail, l);
+	if (err)
+		return err;
+
+	if (l < len) {
+		err = mcp25xxfd_tef_obj_read(priv, &hw_tef_obj[l], 0, len - l);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < len; i++) {
+		err = mcp25xxfd_handle_tefif_one(priv, &hw_tef_obj[i]);
+		/* -EAGAIN means the Sequence Number in the TEF
+		 * doesn't match our tef_tail. This can happen if we
+		 * read the TEF objects too early. Leave loop let the
+		 * interrupt handler call us again.
+		 */
+		if (err == -EAGAIN)
+			goto out_netif_wake_queue;
+		if (err)
+			return err;
+	}
+
+ out_netif_wake_queue:
+	mcp25xxfd_log_wake(priv, hw_tef_obj->id);
+	netif_wake_queue(priv->ndev);
+
+	return 0;
+}
+
+static int mcp25xxfd_rx_ring_update(struct mcp25xxfd_priv *priv)
+{
+	u32 fifo_sta, new_head;
+	u8 rx_ci;
+	int err;
+
+	err = regmap_read(priv->map,
+			  MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_RX_FIFO(0)),
+			  &fifo_sta);
+	if (err)
+		return err;
+
+	rx_ci = FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, fifo_sta);
+	new_head = round_down(priv->rx.head, priv->rx.obj_num) + rx_ci;
+
+	if (new_head <= priv->rx.head)
+		new_head += priv->rx.obj_num;
+
+	priv->rx.head = new_head;
+
+	return mcp25xxfd_check_rx_tail(priv);
+}
+
+static void
+mcp25xxfd_hw_rx_obj_to_skb(const struct mcp25xxfd_priv *priv,
+			   const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj,
+			   struct sk_buff *skb)
+{
+	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+
+	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_IDE) {
+		u32 sid, eid;
+
+		eid = FIELD_GET(MCP25XXFD_OBJ_ID_EID_MASK, hw_rx_obj->id);
+		sid = FIELD_GET(MCP25XXFD_OBJ_ID_SID_MASK, hw_rx_obj->id);
+
+		cfd->can_id = CAN_EFF_FLAG |
+			FIELD_PREP(MCP25XXFD_CAN_FRAME_EFF_EID_MASK, eid) |
+			FIELD_PREP(MCP25XXFD_CAN_FRAME_EFF_SID_MASK, sid);
+	} else {
+		cfd->can_id = FIELD_GET(MCP25XXFD_OBJ_ID_SID_MASK,
+					hw_rx_obj->id);
+	}
+
+	/* CANFD */
+	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_FDF) {
+		u8 dlc;
+
+		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_ESI)
+			cfd->flags |= CANFD_ESI;
+
+		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_BRS)
+			cfd->flags |= CANFD_BRS;
+
+		dlc = FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_rx_obj->flags);
+		cfd->len = can_dlc2len(get_canfd_dlc(dlc));
+	} else {
+		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_RTR)
+			cfd->can_id |= CAN_RTR_FLAG;
+
+		cfd->len = get_can_dlc(FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC,
+						 hw_rx_obj->flags));
+	}
+
+	memcpy(cfd->data, hw_rx_obj->data, cfd->len);
+}
+
+static int
+mcp25xxfd_handle_rxif_one(struct mcp25xxfd_priv *priv,
+			  const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct canfd_frame *cfd;
+	int err;
+
+	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_FDF)
+		skb = alloc_canfd_skb(priv->ndev, &cfd);
+	else
+		skb = alloc_can_skb(priv->ndev, (struct can_frame **)&cfd);
+
+	if (!cfd) {
+		stats->rx_dropped++;
+		return 0;
+	}
+
+	mcp25xxfd_hw_rx_obj_to_skb(priv, hw_rx_obj, skb);
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, hw_rx_obj->ts);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	priv->rx.tail++;
+
+	/* finally increment the RX pointer */
+	return regmap_update_bits(priv->map,
+				  MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)),
+				  GENMASK(15, 8),
+				  MCP25XXFD_CAN_FIFOCON_UINC);
+}
+
+static inline int
+mcp25xxfd_rx_obj_read(const struct mcp25xxfd_priv *priv,
+		      struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj,
+		      const u8 offset, const u8 len)
+{
+	return regmap_bulk_read(priv->map,
+				mcp25xxfd_get_rx_obj_addr(priv, offset),
+				hw_rx_obj,
+				len * priv->rx.obj_size / sizeof(u32));
+}
+
+static int mcp25xxfd_handle_rxif(struct mcp25xxfd_priv *priv)
+{
+	struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj = priv->rx.obj;
+	u8 rx_tail, len, l;
+	int err, i;
+
+	err = mcp25xxfd_rx_ring_update(priv);
+	if (err)
+		return err;
+
+	rx_tail = mcp25xxfd_get_rx_tail(priv);
+	len = mcp25xxfd_get_rx_len(priv);
+	l = mcp25xxfd_get_rx_linear_len(priv);
+	err = mcp25xxfd_rx_obj_read(priv, hw_rx_obj, rx_tail, l);
+	if (err)
+		return err;
+
+	if (l < len) {
+		err = mcp25xxfd_rx_obj_read(priv, (void *)hw_rx_obj +
+					    l * priv->rx.obj_size, 0, len - l);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < len; i++) {
+		err = mcp25xxfd_handle_rxif_one(priv, (void *)hw_rx_obj +
+						i * priv->rx.obj_size);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static inline int mcp25xxfd_get_timestamp(const struct mcp25xxfd_priv *priv,
+					  u32 *timestamp)
+{
+	return regmap_read(priv->map, MCP25XXFD_CAN_TBC, timestamp);
+}
+
+static struct sk_buff *
+mcp25xxfd_alloc_can_err_skb(const struct mcp25xxfd_priv *priv,
+			    struct can_frame **cf, u32 *timestamp)
+{
+	int err;
+
+	err = mcp25xxfd_get_timestamp(priv, timestamp);
+	if (err)
+		return NULL;
+
+	return alloc_can_err_skb(priv->ndev, cf);
+}
+
+static int mcp25xxfd_handle_rxovif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	u32 timestamp, rxovif;
+	int err, i;
+
+	stats->rx_over_errors++;
+	stats->rx_errors++;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_RXOVIF, &rxovif);
+	if (err)
+		return err;
+
+	for (i = 0; i < MCP25XXFD_RX_FIFO_NUM; i++) {
+		const u8 rx_fifo = MCP25XXFD_RX_FIFO(i);
+
+		if (rxovif & BIT(rx_fifo)) {
+			netdev_warn(priv->ndev,
+				   "RX-FIFO overflow in FIFO %d.\n", rx_fifo);
+
+			err = regmap_update_bits(priv->map,
+						 MCP25XXFD_CAN_FIFOSTA(rx_fifo),
+						 MCP25XXFD_CAN_FIFOSTA_RXOVIF,
+						 0x0);
+			if (err)
+				return err;
+		}
+	}
+
+	skb = mcp25xxfd_alloc_can_err_skb(priv, &cf, &timestamp);
+	if (!skb)
+		return 0;
+
+	cf->can_id |= CAN_ERR_CRTL;
+	cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_txatif(struct mcp25xxfd_priv *priv)
+{
+	netdev_info(priv->ndev, "%s\n", __func__);
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_ivmif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	u32 bdiag1, timestamp;
+	struct sk_buff *skb;
+	struct can_frame *cf = NULL;
+	int err;
+
+	err = mcp25xxfd_get_timestamp(priv, &timestamp);
+	if (err)
+		return err;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_BDIAG1, &bdiag1);
+	if (err)
+		return err;
+
+	/* Write 0s to clear error bits, don't write 1s to non active
+	 * bits, as they will be set.
+	 */
+	err = regmap_write(priv->map, MCP25XXFD_CAN_BDIAG1, 0x0);
+	if (err)
+		return err;
+
+	priv->can.can_stats.bus_error++;
+
+	skb = alloc_can_err_skb(priv->ndev, &cf);
+	if (cf)
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+
+	/* Controller misconfiguration */
+	if (WARN_ON(bdiag1 & MCP25XXFD_CAN_BDIAG1_DLCMM))
+		netdev_err(priv->ndev,
+			   "recv'd DLC is larger than PLSIZE of FIFO element.");
+
+	/* RX errors */
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DCRCERR |
+		      MCP25XXFD_CAN_BDIAG1_NCRCERR)) {
+		stats->rx_errors++;
+		if (cf)
+			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DSTUFERR |
+		      MCP25XXFD_CAN_BDIAG1_NSTUFERR)) {
+		stats->rx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DFORMERR |
+		      MCP25XXFD_CAN_BDIAG1_NFORMERR)) {
+		stats->rx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+	}
+
+	/* TX errors */
+	if (bdiag1 & MCP25XXFD_CAN_BDIAG1_NACKERR) {
+		stats->tx_errors++;
+		if (cf) {
+			cf->can_id |= CAN_ERR_ACK;
+			cf->data[2] |= CAN_ERR_PROT_TX;
+		}
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DBIT1ERR |
+		      MCP25XXFD_CAN_BDIAG1_NBIT1ERR)) {
+		stats->tx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT1;
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DBIT0ERR |
+		      MCP25XXFD_CAN_BDIAG1_NBIT0ERR)) {
+		stats->tx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT0;
+	}
+
+	if (!cf)
+		return 0;
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_cerrif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf = NULL;
+	enum can_state new_state, rx_state, tx_state;
+	u32 trec, timestamp;
+	int err;
+
+	/* The skb allocation might fail, but can_change_state()
+	 * handles cf == NULL.
+	 */
+	skb = mcp25xxfd_alloc_can_err_skb(priv, &cf, &timestamp);
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TREC, &trec);
+	if (err)
+		return err;
+
+	if (trec & MCP25XXFD_CAN_TREC_TXBO)
+		tx_state = CAN_STATE_BUS_OFF;
+	else if (trec & MCP25XXFD_CAN_TREC_TXBP)
+		tx_state = CAN_STATE_ERROR_PASSIVE;
+	else if (trec & MCP25XXFD_CAN_TREC_TXWARN)
+		tx_state = CAN_STATE_ERROR_WARNING;
+	else
+		tx_state = CAN_STATE_ERROR_ACTIVE;
+
+	if (trec & MCP25XXFD_CAN_TREC_RXBP)
+		rx_state = CAN_STATE_ERROR_PASSIVE;
+	else if (trec & MCP25XXFD_CAN_TREC_RXWARN)
+		rx_state = CAN_STATE_ERROR_WARNING;
+	else
+		rx_state = CAN_STATE_ERROR_ACTIVE;
+
+	new_state = max(tx_state, rx_state);
+	if (new_state == priv->can.state)
+		return 0;
+
+	can_change_state(priv->ndev, cf, tx_state, rx_state);
+
+	if (new_state == CAN_STATE_BUS_OFF) {
+		mcp25xxfd_chip_stop(priv, CAN_STATE_BUS_OFF);
+		can_bus_off(priv->ndev);
+	}
+
+	if (!skb)
+		return 0;
+
+	if (new_state != CAN_STATE_BUS_OFF) {
+		struct can_berr_counter bec;
+
+		err = mcp25xxfd_get_berr_counter(priv->ndev, &bec);
+		cf->data[6] = bec.txerr;
+		cf->data[7] = bec.rxerr;
+	}
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_modif(const struct mcp25xxfd_priv *priv)
+{
+	const u8 mode_reference = mcp25xxfd_get_normal_mode(priv);
+	u8 mode;
+	int err;
+
+	err = mcp25xxfd_chip_get_mode(priv, &mode);
+	if (err)
+		return err;
+
+	if (mode == mode_reference)
+		return 0;
+
+	/* According to MCP2517FD errata DS80000792B, during a TX MAB
+	 * underflow, the controller will transition to Restricted
+	 * Operation Mode or Listen Only Mode (depending on SERR2LOM).
+	 *
+	 * However this is not always the case. When SERR2LOM is
+	 * configured for Restricted Operation Mode (SERR2LOM not set)
+	 * the MCP2517FD will sometimes transition to Listen Only Mode
+	 * first. When polling this bit we see that it will transition
+	 * to Restricted Operation Mode shortly after.
+	 */
+	if (mode == MCP25XXFD_CAN_CON_MODE_RESTRICTED ||
+	    mode == MCP25XXFD_CAN_CON_MODE_LISTENONLY)
+		netdev_dbg(priv->ndev,
+			    "Controller changed into %s Mode (%u).\n",
+			    mcp25xxfd_get_mode_str(mode), mode);
+	else
+		netdev_err(priv->ndev,
+			   "Controller changed into %s Mode (%u).\n",
+			   mcp25xxfd_get_mode_str(mode), mode);
+
+	/* After the application requests Normal mode, the CAN FD
+	 * Controller will automatically attempt to retransmit the
+	 * message that caused the TX MAB underflow.
+	 */
+	return mcp25xxfd_chip_set_normal_mode_nowait(priv);
+}
+
+static int mcp25xxfd_handle_serrif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+
+	/* TX MAB underflow
+	 *
+	 * According to the MCP2517FD Errata DS80000792B a TX MAB
+	 * underflow is indicated by SERRIF and MODIF.
+	 *
+	 * Due to the corresponding Bus Errors, a IVMIF can be seen as
+	 * well.
+	 */
+	if ((priv->intf & MCP25XXFD_CAN_INT_MODIF) &&
+	    (priv->intf & MCP25XXFD_CAN_INT_IVMIF)) {
+		stats->tx_aborted_errors++;
+		stats->tx_errors++;
+
+		return 0;
+	}
+
+	/* RX MAB overflow
+	 *
+	 * According to the MCP2517FD Errata DS80000792B a RX MAB
+	 * overflow is indicated by SERRIF.
+	 */
+	if (priv->intf & MCP25XXFD_CAN_INT_RXIF) {
+		stats->rx_dropped++;
+		stats->rx_errors++;
+
+		return 0;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_eccif(struct mcp25xxfd_priv *priv)
+{
+	int err;
+	u32 ecc_stat;
+
+	err = regmap_read(priv->map, MCP25XXFD_ECCSTAT, &ecc_stat);
+	if (err)
+		return err;
+
+	err = regmap_update_bits(priv->map, MCP25XXFD_ECCSTAT,
+				 MCP25XXFD_ECCSTAT_IF_MASK,
+				 ~ecc_stat);
+	if (err)
+		return err;
+
+	if (ecc_stat & MCP25XXFD_ECCSTAT_SECIF)
+		netdev_info(priv->ndev,
+			    "Single ECC Error corrected at address 0x%04lx.\n",
+			    FIELD_GET(MCP25XXFD_ECCSTAT_ERRADDR_MASK,
+				      ecc_stat));
+	else if (ecc_stat & MCP25XXFD_ECCSTAT_DEDIF)
+		netdev_notice(priv->ndev,
+			      "Double ECC Error detected at address 0x%04lx.\n",
+			      FIELD_GET(MCP25XXFD_ECCSTAT_ERRADDR_MASK,
+					ecc_stat));
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_spicrcif(struct mcp25xxfd_priv *priv)
+{
+	int err;
+	u32 crc;
+
+	err = regmap_read(priv->map, MCP25XXFD_CRC, &crc);
+	if (err)
+		return err;
+
+	err = regmap_update_bits(priv->map, MCP25XXFD_CRC,
+				 MCP25XXFD_CRC_IF_MASK,
+				 ~crc);
+	if (err)
+		return err;
+
+	if (crc & MCP25XXFD_CRC_FERRIF)
+		netdev_info(priv->ndev, "CRC Command Format Error.\n");
+	else if (crc & MCP25XXFD_CRC_CRCERRIF)
+		netdev_notice(priv->ndev, "CRC Error detected. CRC=0x%04lx.\n",
+			      FIELD_GET(MCP25XXFD_CRC_MASK, crc));
+
+	return 0;
+}
+
+#define mcp25xxfd_handle(priv, irq, ...) \
+({ \
+	int err; \
+\
+	err = mcp25xxfd_handle_##irq(priv, ## __VA_ARGS__); \
+	if (err) \
+		netdev_err(priv->ndev, \
+			"IRQ handler mcp25xxfd_handle_%s() returned %d.\n", \
+			__stringify(irq), err); \
+	err; \
+})
+
+static irqreturn_t mcp25xxfd_irq(int irq, void *dev_id)
+{
+	struct mcp25xxfd_priv *priv = dev_id;
+	irqreturn_t handled = IRQ_NONE;
+	int err;
+
+	if (priv->rx_int)
+		do {
+			int rx_pending;
+
+			rx_pending = gpiod_get_value_cansleep(priv->rx_int);
+			if (!rx_pending)
+				break;
+
+			err = mcp25xxfd_handle(priv, rxif);
+			if (err)
+				goto out_fail;
+
+			handled = IRQ_HANDLED;
+		} while (1);
+
+	do {
+		u32 intf_pending, intf_pending_clearable;
+
+		err = regmap_read(priv->map, MCP25XXFD_CAN_INT, &priv->intf);
+		if (err)
+			goto out_fail;
+
+		intf_pending = FIELD_GET(MCP25XXFD_CAN_INT_IF_MASK, priv->intf) &
+			FIELD_GET(MCP25XXFD_CAN_INT_IE_MASK, priv->intf);
+
+		if (!(intf_pending))
+			return handled;
+
+		/* Some interrupts must be ACKed in the
+		 * MCP25XXFD_CAN_INT register.
+		 * - First ACK then handle, to avoid lost-IRQ race
+		 *   condition on fast re-occuring interrupts.
+		 * - Write "0" to clear active IRQs, "1" to all other,
+		 *   to avoid r/m/w race condition on the
+		 *   MCP25XXFD_CAN_INT register.
+		 */
+		intf_pending_clearable = intf_pending &
+			MCP25XXFD_CAN_INT_IF_CLEARABLE_MASK;
+		if (intf_pending_clearable) {
+			err = regmap_update_bits(priv->map, MCP25XXFD_CAN_INT,
+						 MCP25XXFD_CAN_INT_IF_MASK,
+						 ~intf_pending_clearable);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_MODIF) {
+			err = mcp25xxfd_handle(priv, modif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_RXIF) {
+			err = mcp25xxfd_handle(priv, rxif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_TEFIF) {
+			err = mcp25xxfd_handle(priv, tefif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_RXOVIF) {
+			err = mcp25xxfd_handle(priv, rxovif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_TXATIF) {
+			err = mcp25xxfd_handle(priv, txatif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_IVMIF) {
+			err = mcp25xxfd_handle(priv, ivmif);
+			if (err)
+				goto out_fail;
+		}
+
+		/* On the MCP2527FD and MCP2518FD, we don't get a
+		 * CERRIF IRQ on the transition TX ERROR_WARNING -> TX
+		 * ERROR_ACTIVE.
+		 */
+		if (intf_pending & MCP25XXFD_CAN_INT_CERRIF ||
+		    priv->can.state > CAN_STATE_ERROR_ACTIVE) {
+			err = mcp25xxfd_handle(priv, cerrif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_SERRIF) {
+			err = mcp25xxfd_handle(priv, serrif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_ECCIF) {
+			err = mcp25xxfd_handle(priv, eccif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_SPICRCIE) {
+			err = mcp25xxfd_handle(priv, spicrcif);
+			if (err)
+				goto out_fail;
+		}
+
+		handled = IRQ_HANDLED;
+	} while (1);
+
+ out_fail:
+	netdev_err(priv->ndev, "IRQ handler returned %d.\n", err);
+	mcp25xxfd_dump(priv);
+	mcp25xxfd_log_dump(priv);
+	mcp25xxfd_chip_interrupts_disable(priv);
+
+	return handled;
+}
+
+static inline struct
+mcp25xxfd_tx_obj *mcp25xxfd_get_tx_obj_next(struct mcp25xxfd_priv *priv)
+{
+	u8 tx_head;
+
+	tx_head = mcp25xxfd_get_tx_head(priv);
+
+	return &priv->tx.obj[tx_head];
+}
+
+static void
+mcp25xxfd_tx_obj_from_skb(const struct mcp25xxfd_priv *priv,
+			  struct mcp25xxfd_tx_obj *tx_obj,
+			  const struct sk_buff *skb)
+{
+	const struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+	struct mcp25xxfd_hw_tx_obj_raw *hw_tx_obj = &tx_obj->load.buf.hw_tx_obj;
+	u32 id, flags, len;
+
+	if (cfd->can_id & CAN_EFF_FLAG) {
+		u32 sid, eid;
+
+		sid = FIELD_GET(MCP25XXFD_CAN_FRAME_EFF_SID_MASK, cfd->can_id);
+		eid = FIELD_GET(MCP25XXFD_CAN_FRAME_EFF_EID_MASK, cfd->can_id);
+
+		id = FIELD_PREP(MCP25XXFD_OBJ_ID_EID_MASK, eid) |
+			FIELD_PREP(MCP25XXFD_OBJ_ID_SID_MASK, sid);
+
+		flags = MCP25XXFD_OBJ_FLAGS_IDE;
+	} else {
+		id = FIELD_PREP(MCP25XXFD_OBJ_ID_SID_MASK, cfd->can_id);
+		flags = 0;
+	}
+
+	/* Use the MCP2518FD mask even on the MCP2517FD. It doesn't
+	 * harm, only the lower 7 bits will be transferred into the
+	 * TEF object.
+	 */
+	flags |= FIELD_PREP(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
+			    priv->tx.head) |
+		FIELD_PREP(MCP25XXFD_OBJ_FLAGS_DLC, can_len2dlc(cfd->len));
+
+	if (cfd->can_id & CAN_RTR_FLAG)
+		flags |= MCP25XXFD_OBJ_FLAGS_RTR;
+
+	/* CANFD */
+	if (can_is_canfd_skb(skb)) {
+		if (cfd->flags & CANFD_ESI)
+			flags |= MCP25XXFD_OBJ_FLAGS_ESI;
+
+		flags |= MCP25XXFD_OBJ_FLAGS_FDF;
+
+		if (cfd->flags & CANFD_BRS)
+			flags |= MCP25XXFD_OBJ_FLAGS_BRS;
+	}
+
+	put_unaligned_le32(id, &hw_tx_obj->id);
+	put_unaligned_le32(flags, &hw_tx_obj->flags);
+
+	// FIXME: what does the controller send in CANFD if can_dlc2len(can_len2dlc(cfd->len)) > cfd->len?
+	memset(hw_tx_obj->data + round_down(cfd->len, sizeof(u32)),
+	       0x0, sizeof(u32));
+	memcpy(hw_tx_obj->data, cfd->data, cfd->len);
+
+	len = sizeof(tx_obj->load.buf.cmd);
+	len += sizeof(hw_tx_obj->id) + sizeof(hw_tx_obj->flags);
+	len += round_up(cfd->len, sizeof(u32));
+
+	tx_obj->load.xfer.len = len;
+}
+
+static int mcp25xxfd_tx_obj_write(const struct mcp25xxfd_priv *priv,
+				  struct mcp25xxfd_tx_obj *tx_obj)
+{
+	int err;
+
+	err = spi_async(priv->spi, &tx_obj->load.msg);
+	if (err)
+		return err;
+
+	return spi_async(priv->spi, &tx_obj->trigger.msg);
+}
+
+static netdev_tx_t mcp25xxfd_start_xmit(struct sk_buff *skb,
+					struct net_device *ndev)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	struct mcp25xxfd_tx_obj *tx_obj;
+	const canid_t can_id = ((struct canfd_frame *)skb->data)->can_id;
+	u8 tx_head;
+	int err;
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+	mcp25xxfd_log(priv, can_id);
+
+	if (priv->tx.head - priv->tx.tail >= priv->tx.obj_num) {
+		netdev_info(priv->ndev,
+			   "Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\n",
+			   priv->tx.head, priv->tx.tail,
+			   priv->tx.head - priv->tx.tail);
+
+		mcp25xxfd_log_busy(priv, can_id);
+		netif_stop_queue(ndev);
+
+		return NETDEV_TX_BUSY;
+	}
+
+	tx_obj = mcp25xxfd_get_tx_obj_next(priv);
+	mcp25xxfd_tx_obj_from_skb(priv, tx_obj, skb);
+
+	// FIXME:
+	// if (!netdev_xmit_more() ||
+	//	netif_xmit_stopped(netdev_get_tx_queue(netdev, 0)))
+
+	/* Stop queue if we occupy the complete TX FIFO */
+	tx_head = mcp25xxfd_get_tx_head(priv);
+	priv->tx.head++;
+	if (priv->tx.head - priv->tx.tail >= priv->tx.obj_num) {
+		mcp25xxfd_log_stop(priv, can_id);
+		netif_stop_queue(ndev);
+	}
+
+	can_put_echo_skb(skb, ndev, tx_head);
+
+	err = mcp25xxfd_tx_obj_write(priv, tx_obj);
+	if (err)
+		goto out_err;
+
+	return NETDEV_TX_OK;
+
+ out_err:
+	netdev_err(priv->ndev, "ERROR in %s: %d\n", __func__, err);
+	mcp25xxfd_dump(priv);
+	mcp25xxfd_log_dump(priv);
+
+	return NETDEV_TX_OK;
+}
+
+static int mcp25xxfd_open(struct net_device *ndev)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	const struct spi_device *spi = priv->spi;
+	int err;
+
+	err = pm_runtime_get_sync(ndev->dev.parent);
+	if (err < 0)
+		return err;
+
+	err = open_candev(ndev);
+	if (err)
+		goto out_pm_runtime_put;
+
+	err = request_threaded_irq(spi->irq, NULL, mcp25xxfd_irq,
+				   IRQF_ONESHOT, dev_name(&spi->dev),
+				   priv);
+	if (err)
+		goto out_close;
+
+	err = mcp25xxfd_transceiver_enable(priv);
+	if (err)
+		goto out_free_irq;
+
+	can_rx_offload_enable(&priv->offload);
+
+	err = mcp25xxfd_chip_start(priv);
+	if (err)
+		goto out_can_rx_offload_disable;
+
+	netif_start_queue(ndev);
+
+	return 0;
+
+ out_can_rx_offload_disable:
+	can_rx_offload_disable(&priv->offload);
+	mcp25xxfd_transceiver_disable(priv);
+ out_free_irq:
+	free_irq(spi->irq, priv);
+ out_close:
+	close_candev(ndev);
+ out_pm_runtime_put:
+	mcp25xxfd_chip_stop(priv, CAN_STATE_STOPPED);
+	pm_runtime_put(ndev->dev.parent);
+
+	return err;
+}
+
+static int mcp25xxfd_stop(struct net_device *ndev)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	mcp25xxfd_chip_stop(priv, CAN_STATE_STOPPED);
+	can_rx_offload_disable(&priv->offload);
+	mcp25xxfd_transceiver_disable(priv);
+	free_irq(ndev->irq, priv);
+	close_candev(ndev);
+
+	pm_runtime_put(ndev->dev.parent);
+
+	return 0;
+}
+
+static const struct net_device_ops mcp25xxfd_netdev_ops = {
+	.ndo_open = mcp25xxfd_open,
+	.ndo_stop = mcp25xxfd_stop,
+	.ndo_start_xmit	= mcp25xxfd_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+static int mcp25xxfd_register_chip_detect(struct mcp25xxfd_priv *priv)
+{
+	const struct net_device *ndev = priv->ndev;
+	u32 osc, osc_reference;
+	enum mcp25xxfd_model model;
+	int err;
+
+	osc_reference = MCP25XXFD_OSC_OSCRDY |
+		FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK,
+			   MCP25XXFD_OSC_CLKODIV_10);
+
+	/* check reset defaults of OSC reg */
+	err = regmap_read(priv->map, MCP25XXFD_OSC, &osc);
+	if (err)
+		return err;
+
+	if (osc != osc_reference) {
+		netdev_err(ndev,
+			   "Chip failed to soft reset. osc=0x%08x, reference value=0x%08x\n",
+			   osc, osc_reference);
+		return -ENODEV;
+	}
+
+	/* The OSC_LPMEN is only supported on MCP2518FD, so use it to
+	 * autodetect the model.
+	 */
+	err = regmap_update_bits(priv->map, MCP25XXFD_OSC,
+				 MCP25XXFD_OSC_LPMEN, MCP25XXFD_OSC_LPMEN);
+	if (err)
+		return err;
+
+	err = regmap_read(priv->map, MCP25XXFD_OSC, &osc);
+	if (err)
+		return err;
+
+	if (osc & MCP25XXFD_OSC_LPMEN)
+		model = CAN_MCP2518FD;
+	else
+		model = CAN_MCP2517FD;
+
+	if (priv->model != CAN_MCP25XXFD &&
+	    priv->model != model) {
+		netdev_info(ndev,
+			    "Detected MCP%xFD, but firmware specifies a MCP%xFD. Fixing up.",
+			    model, priv->model);
+	}
+	priv->model = model;
+
+	return 0;
+}
+
+static int mcp25xxfd_register_check_rx_int(struct mcp25xxfd_priv *priv)
+{
+	int err, rx_pending;
+
+	if (!priv->rx_int)
+		return 0;
+
+	err = mcp25xxfd_chip_pinctrl_init(priv);
+	if (err)
+		return err;
+
+	/* Check if RX_INT is properly working. The RX-INT should not
+	 * be active after a softreset.
+	 */
+	rx_pending = gpiod_get_value_cansleep(priv->rx_int);
+	if (!rx_pending)
+		return 0;
+
+	netdev_info(priv->ndev,
+		   "RX-INT active after softreset, disabling RX-INT support.");
+	devm_gpiod_put(&priv->spi->dev, priv->rx_int);
+	priv->rx_int = NULL;
+
+	return 0;
+}
+
+static int mcp25xxfd_register(struct mcp25xxfd_priv *priv)
+{
+	struct net_device *ndev = priv->ndev;
+	int err;
+
+	err = mcp25xxfd_clks_and_vdd_enable(priv);
+	if (err)
+		return err;
+
+	pm_runtime_get_noresume(ndev->dev.parent);
+	err = pm_runtime_set_active(ndev->dev.parent);
+	if (err)
+		goto out_runtime_put_noidle;
+	pm_runtime_enable(ndev->dev.parent);
+
+	/* Wait for oscillator startup timer after power up */
+	mdelay(MCP25XXFD_OSC_DELAY_MS);
+
+	err = mcp25xxfd_chip_softreset(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_register_chip_detect(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_register_check_rx_int(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = register_candev(ndev);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	if (priv->model == CAN_MCP2517FD) {
+		netdev_info(ndev, "MCP%xFD %ssuccessfully initialized.\n",
+			    priv->model, priv->rx_int ? "(+RX-INT) " : "");
+	} else {
+		u32 devid;
+
+		err = regmap_read(priv->map, MCP25XXFD_DEVID, &devid);
+		if (err)
+			goto out_unregister_candev;
+
+		netdev_info(ndev, "MCP%xFD rev%lu.%lu %ssuccessfully initialized.\n",
+			    priv->model,
+			    FIELD_GET(MCP25XXFD_DEVID_ID_MASK, devid),
+			    FIELD_GET(MCP25XXFD_DEVID_REV_MASK, devid),
+			    priv->rx_int ? "(+RX-INT) " : "");
+	}
+
+	/* Put core into sleep mode and let pm_runtime_put() disable
+	 * the clocks and vdd. If CONFIG_PM is not enabled, the clocks
+	 * and vdd will stay powered.
+	 */
+	err = mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+	if (err)
+		goto out_unregister_candev;
+
+	pm_runtime_put(ndev->dev.parent);
+
+	return 0;
+
+ out_unregister_candev:
+	unregister_candev(ndev);
+ out_chip_set_mode_sleep:
+	mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+	pm_runtime_disable(ndev->dev.parent);
+ out_runtime_put_noidle:
+	pm_runtime_put_noidle(ndev->dev.parent);
+	mcp25xxfd_clks_and_vdd_disable(priv);
+
+	return err;
+}
+
+static inline void mcp25xxfd_unregister(struct mcp25xxfd_priv *priv)
+{
+	struct net_device *ndev	= priv->ndev;
+
+	unregister_candev(ndev);
+
+	pm_runtime_get_sync(ndev->dev.parent);
+	pm_runtime_put_noidle(ndev->dev.parent);
+	mcp25xxfd_clks_and_vdd_disable(priv);
+	pm_runtime_disable(ndev->dev.parent);
+}
+
+static const struct of_device_id mcp25xxfd_of_match[] = {
+	{
+		.compatible = "microchip,mcp2517fd",
+		.data = (void *)CAN_MCP2517FD,
+	}, {
+		.compatible = "microchip,mcp2518fd",
+		.data = (void *)CAN_MCP2518FD,
+	}, {
+		.compatible = "microchip,mcp25xxfd",
+		.data = (void *)CAN_MCP25XXFD,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, mcp25xxfd_of_match);
+
+static const struct spi_device_id mcp25xxfd_id_table[] = {
+	{
+		.name = "mcp2517fd",
+		.driver_data = (kernel_ulong_t)CAN_MCP2517FD,
+	}, {
+		.name = "mcp2518fd",
+		.driver_data = (kernel_ulong_t)CAN_MCP2518FD,
+	}, {
+		.name = "mcp25xxfd",
+		.driver_data = (kernel_ulong_t)CAN_MCP25XXFD,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(spi, mcp25xxfd_id_table);
+
+static int mcp25xxfd_probe(struct spi_device *spi)
+{
+#if 0
+	const void *match;
+#endif/*0*/
+	struct net_device *ndev;
+	struct mcp25xxfd_priv *priv;
+	struct gpio_desc *rx_int;
+	struct regulator *reg_vdd, *reg_xceiver;
+	struct clk *clk;
+	u32 freq;
+	int err;
+
+	rx_int = devm_gpiod_get_optional(&spi->dev, "rx-int", GPIOD_IN);
+	if (PTR_ERR(rx_int) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (IS_ERR(rx_int))
+		return PTR_ERR(rx_int);
+
+	reg_vdd = devm_regulator_get_optional(&spi->dev, "vdd");
+	if (PTR_ERR(reg_vdd) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (PTR_ERR(reg_vdd) == -ENODEV)
+		reg_vdd = NULL;
+	else if (IS_ERR(reg_vdd))
+		return PTR_ERR(reg_vdd);
+
+	reg_xceiver = devm_regulator_get_optional(&spi->dev, "xceiver");
+	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (PTR_ERR(reg_xceiver) == -ENODEV)
+		reg_xceiver = NULL;
+	else if (IS_ERR(reg_xceiver))
+		return PTR_ERR(reg_xceiver);
+
+	clk = devm_clk_get(&spi->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&spi->dev, "No Oscillator (clock) defined.\n");
+		return PTR_ERR(clk);
+	}
+	freq = clk_get_rate(clk);
+
+	/* Sanity check */
+	if (freq < MCP25XXFD_SYSCLOCK_HZ_MIN ||
+	    freq > MCP25XXFD_SYSCLOCK_HZ_MAX) {
+		dev_err(&spi->dev, "Oscillator frequency is too low.\n");
+		return -ERANGE;
+	}
+
+	if (freq < MCP25XXFD_SYSCLOCK_HZ_MAX /
+	    MCP25XXFD_OSC_PLL_MULTIPLIER) {
+		dev_err(&spi->dev,
+			"Oscillator frequency is too low and PLL in not supported.\n");
+		return -ERANGE;
+	}
+
+	ndev = alloc_candev(sizeof(struct mcp25xxfd_priv),
+			    MCP25XXFD_TX_OBJ_NUM_MAX);
+	if (!ndev)
+		return -ENOMEM;
+
+	SET_NETDEV_DEV(ndev, &spi->dev);
+
+	ndev->netdev_ops = &mcp25xxfd_netdev_ops;
+	ndev->irq = spi->irq;
+	ndev->flags |= IFF_ECHO;
+
+	priv = netdev_priv(ndev);
+	spi_set_drvdata(spi, priv);
+	priv->can.clock.freq = freq;
+	priv->can.do_set_mode = mcp25xxfd_set_mode;
+	priv->can.do_get_berr_counter = mcp25xxfd_get_berr_counter;
+	priv->can.bittiming_const = &mcp25xxfd_bittiming_const;
+	priv->can.data_bittiming_const = &mcp25xxfd_data_bittiming_const;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_FD |
+		CAN_CTRLMODE_BERR_REPORTING;
+	priv->ndev = ndev;
+	priv->spi = spi;
+	priv->rx_int = rx_int;
+	priv->clk = clk;
+	priv->reg_vdd = reg_vdd;
+	priv->reg_xceiver = reg_xceiver;
+	atomic_set(&priv->cnt, 0);
+#if 0
+	match = device_get_match_data(&spi->dev);
+	if (match)
+		priv->model = (enum mcp25xxfd_model)match;
+	else
+#endif/*0*/
+		priv->model = spi_get_device_id(spi)->driver_data;
+
+	spi->bits_per_word = 8;
+	/* SPI clock must be less or equal SYSCLOCK / 2 */
+	spi->max_speed_hz = min(spi->max_speed_hz, freq / 2);
+	err = spi_setup(spi);
+	if (err)
+		goto out_free_candev;
+
+	err = mcp25xxfd_regmap_init(priv);
+	if (err)
+		goto out_free_candev;
+
+	err = can_rx_offload_add_manual(ndev, &priv->offload,
+					MCP25XXFD_NAPI_WEIGHT);
+	if (err)
+		goto out_free_candev;
+
+	err = mcp25xxfd_register(priv);
+	if (err)
+		goto out_free_candev;
+
+	return 0;
+
+ out_free_candev:
+	free_candev(ndev);
+
+	return err;
+}
+
+static int mcp25xxfd_remove(struct spi_device *spi)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct net_device *ndev = priv->ndev;
+
+	can_rx_offload_del(&priv->offload);
+	mcp25xxfd_unregister(priv);
+	free_candev(ndev);
+
+	return 0;
+}
+
+static int __maybe_unused mcp25xxfd_runtime_suspend(struct device *device)
+{
+	const struct mcp25xxfd_priv *priv = dev_get_drvdata(device);
+
+	return mcp25xxfd_clks_and_vdd_disable(priv);
+}
+
+static int __maybe_unused mcp25xxfd_runtime_resume(struct device *device)
+{
+	const struct mcp25xxfd_priv *priv = dev_get_drvdata(device);
+
+	return mcp25xxfd_clks_and_vdd_enable(priv);
+}
+
+static const struct dev_pm_ops mcp25xxfd_pm_ops = {
+	SET_RUNTIME_PM_OPS(mcp25xxfd_runtime_suspend,
+			   mcp25xxfd_runtime_resume, NULL)
+};
+
+static struct spi_driver mcp25xxfd_driver = {
+	.driver = {
+		.name = DEVICE_NAME,
+		.pm = &mcp25xxfd_pm_ops,
+		.of_match_table = mcp25xxfd_of_match,
+	},
+	.probe = mcp25xxfd_probe,
+	.remove = mcp25xxfd_remove,
+	.id_table = mcp25xxfd_id_table,
+};
+module_spi_driver(mcp25xxfd_driver);
+
+MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutornix.de>");
+MODULE_DESCRIPTION("Microchip MCP25xxFD Family CAN controller driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
new file mode 100644
index 000000000000..bd591bfb4ccc
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2020 Pengutronix,
+//                    Marc Kleine-Budde <kernel@pengutronix.de>
+//
+// Based on:
+//
+// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+//
+// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+//
+
+#include "mcp25xxfd.h"
+
+/* The standard crc16 in linux/crc16.h is unfortunately not computing
+ * the correct results (left shift vs. right shift). So here an
+ * implementation with a table generated with the help of:
+ *
+ * http://lkml.iu.edu/hypermail/linux/kernel/0508.1/1085.html
+ */
+static const u16 mcp25xxfd_crc16_table[] = {
+	0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011,
+	0x8033, 0x0036, 0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022,
+	0x8063, 0x0066, 0x006c, 0x8069, 0x0078, 0x807d, 0x8077, 0x0072,
+	0x0050, 0x8055, 0x805f, 0x005a, 0x804b, 0x004e, 0x0044, 0x8041,
+	0x80c3, 0x00c6, 0x00cc, 0x80c9, 0x00d8, 0x80dd, 0x80d7, 0x00d2,
+	0x00f0, 0x80f5, 0x80ff, 0x00fa, 0x80eb, 0x00ee, 0x00e4, 0x80e1,
+	0x00a0, 0x80a5, 0x80af, 0x00aa, 0x80bb, 0x00be, 0x00b4, 0x80b1,
+	0x8093, 0x0096, 0x009c, 0x8099, 0x0088, 0x808d, 0x8087, 0x0082,
+	0x8183, 0x0186, 0x018c, 0x8189, 0x0198, 0x819d, 0x8197, 0x0192,
+	0x01b0, 0x81b5, 0x81bf, 0x01ba, 0x81ab, 0x01ae, 0x01a4, 0x81a1,
+	0x01e0, 0x81e5, 0x81ef, 0x01ea, 0x81fb, 0x01fe, 0x01f4, 0x81f1,
+	0x81d3, 0x01d6, 0x01dc, 0x81d9, 0x01c8, 0x81cd, 0x81c7, 0x01c2,
+	0x0140, 0x8145, 0x814f, 0x014a, 0x815b, 0x015e, 0x0154, 0x8151,
+	0x8173, 0x0176, 0x017c, 0x8179, 0x0168, 0x816d, 0x8167, 0x0162,
+	0x8123, 0x0126, 0x012c, 0x8129, 0x0138, 0x813d, 0x8137, 0x0132,
+	0x0110, 0x8115, 0x811f, 0x011a, 0x810b, 0x010e, 0x0104, 0x8101,
+	0x8303, 0x0306, 0x030c, 0x8309, 0x0318, 0x831d, 0x8317, 0x0312,
+	0x0330, 0x8335, 0x833f, 0x033a, 0x832b, 0x032e, 0x0324, 0x8321,
+	0x0360, 0x8365, 0x836f, 0x036a, 0x837b, 0x037e, 0x0374, 0x8371,
+	0x8353, 0x0356, 0x035c, 0x8359, 0x0348, 0x834d, 0x8347, 0x0342,
+	0x03c0, 0x83c5, 0x83cf, 0x03ca, 0x83db, 0x03de, 0x03d4, 0x83d1,
+	0x83f3, 0x03f6, 0x03fc, 0x83f9, 0x03e8, 0x83ed, 0x83e7, 0x03e2,
+	0x83a3, 0x03a6, 0x03ac, 0x83a9, 0x03b8, 0x83bd, 0x83b7, 0x03b2,
+	0x0390, 0x8395, 0x839f, 0x039a, 0x838b, 0x038e, 0x0384, 0x8381,
+	0x0280, 0x8285, 0x828f, 0x028a, 0x829b, 0x029e, 0x0294, 0x8291,
+	0x82b3, 0x02b6, 0x02bc, 0x82b9, 0x02a8, 0x82ad, 0x82a7, 0x02a2,
+	0x82e3, 0x02e6, 0x02ec, 0x82e9, 0x02f8, 0x82fd, 0x82f7, 0x02f2,
+	0x02d0, 0x82d5, 0x82df, 0x02da, 0x82cb, 0x02ce, 0x02c4, 0x82c1,
+	0x8243, 0x0246, 0x024c, 0x8249, 0x0258, 0x825d, 0x8257, 0x0252,
+	0x0270, 0x8275, 0x827f, 0x027a, 0x826b, 0x026e, 0x0264, 0x8261,
+	0x0220, 0x8225, 0x822f, 0x022a, 0x823b, 0x023e, 0x0234, 0x8231,
+	0x8213, 0x0216, 0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202
+};
+
+static inline u16 mcp25xxfd_crc16_byte(u16 crc, const u8 data)
+{
+	u8 index = (crc >> 8) ^ data;
+
+	return (crc << 8) ^ mcp25xxfd_crc16_table[index];
+}
+
+static u16 mcp25xxfd_crc16(u16 crc, u8 const *buffer, size_t len)
+{
+	while (len--)
+		crc = mcp25xxfd_crc16_byte(crc, *buffer++);
+
+	return crc;
+}
+
+u16 mcp25xxfd_crc16_compute(const void *cmd, size_t cmd_size,
+			    const void *data, size_t data_size)
+{
+	u16 crc = 0xffff;
+
+	crc = mcp25xxfd_crc16(crc, cmd, cmd_size);
+	crc = mcp25xxfd_crc16(crc, data, data_size);
+
+	return crc;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
new file mode 100644
index 000000000000..b04ec5000968
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
@@ -0,0 +1,685 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include <linux/bitfield.h>
+#include <linux/kernel.h>
+
+#include "mcp25xxfd.h"
+
+#define __dump_bit(val, prefix, bit, desc) \
+	pr_info("%16s   %s\t\t%s\n", __stringify(bit), \
+		(val) & prefix##_##bit ? "x" : " ", desc)
+
+#define __dump_mask(val, prefix, mask, fmt, desc) \
+	pr_info("%16s = " fmt "\t\t%s\n", \
+		__stringify(mask), \
+		FIELD_GET(prefix##_##mask##_MASK, (val)), \
+		desc)
+
+static void mcp25xxfd_dump_reg_con(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("CON: con(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_CON, TXBWS, "0x%02lx", "Transmit Bandwidth Sharing");
+	__dump_bit(val, MCP25XXFD_CAN_CON, ABAT, "Abort All Pending Transmissions");
+	__dump_mask(val, MCP25XXFD_CAN_CON, REQOP, "0x%02lx", "Request Operation Mode");
+	__dump_mask(val, MCP25XXFD_CAN_CON, OPMOD, "0x%02lx", "Operation Mode Status");
+	__dump_bit(val, MCP25XXFD_CAN_CON, TXQEN, "Enable Transmit Queue");
+	__dump_bit(val, MCP25XXFD_CAN_CON, STEF, "Store in Transmit Event FIFO");
+	__dump_bit(val, MCP25XXFD_CAN_CON, SERR2LOM, "Transition to Listen Only Mode on System Error");
+	__dump_bit(val, MCP25XXFD_CAN_CON, ESIGM, "Transmit ESI in Gateway Mode");
+	__dump_bit(val, MCP25XXFD_CAN_CON, RTXAT, "Restrict Retransmission Attempts");
+	__dump_bit(val, MCP25XXFD_CAN_CON, BRSDIS, "Bit Rate Switching Disable");
+	__dump_bit(val, MCP25XXFD_CAN_CON, BUSY, "CAN Module is Busy");
+	__dump_mask(val, MCP25XXFD_CAN_CON, WFT, "0x%02lx", "Selectable Wake-up Filter Time");
+	__dump_bit(val, MCP25XXFD_CAN_CON, WAKFIL, "Enable CAN Bus Line Wake-up Filter");
+	__dump_bit(val, MCP25XXFD_CAN_CON, PXEDIS, "Protocol Exception Event Detection Disabled");
+	__dump_bit(val, MCP25XXFD_CAN_CON, ISOCRCEN, "Enable ISO CRC in CAN FD Frames");
+	__dump_mask(val, MCP25XXFD_CAN_CON, DNCNT, "0x%02lx", "Device Net Filter Bit Number");
+}
+
+static void mcp25xxfd_dump_reg_tbc(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TBC: tbc(0x%03x)=0x%08x\n", addr, val);
+}
+
+static void mcp25xxfd_dump_reg_vec(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	u8 rx_code, tx_code, i_code;
+
+	pr_info("VEC: vec(0x%03x)=0x%08x\n", addr, val);
+
+	rx_code = FIELD_GET(MCP25XXFD_CAN_VEC_RXCODE_MASK, val);
+	tx_code = FIELD_GET(MCP25XXFD_CAN_VEC_TXCODE_MASK, val);
+	i_code = FIELD_GET(MCP25XXFD_CAN_VEC_ICODE_MASK, val);
+
+	pr_info("\trxcode: ");
+	if (rx_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (rx_code < 0x20)
+		pr_cont("FIFO %u", rx_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", rx_code);
+
+	pr_info("\ttxcode: ");
+	if (tx_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (tx_code < 0x20)
+		pr_cont("FIFO %u", tx_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", tx_code);
+
+	pr_info("\ticode: ");
+	if (i_code == 0x4a)
+		pr_cont("Transmit Attempt Interrupt");
+	else if (i_code == 0x49)
+		pr_cont("Transmit Event FIFO Interrupt");
+	else if (i_code == 0x48)
+		pr_cont("Invalid Message Occurred");
+	else if (i_code == 0x47)
+		pr_cont("Operation Mode Changed");
+	else if (i_code == 0x46)
+		pr_cont("TBC Overflow");
+	else if (i_code == 0x45)
+		pr_cont("RX/TX MAB Overflow/Underflow");
+	else if (i_code == 0x44)
+		pr_cont("Address Error Interrupt");
+	else if (i_code == 0x43)
+		pr_cont("Receive FIFO Overflow Interrupt");
+	else if (i_code == 0x42)
+		pr_cont("Wake-up Interrupt");
+	else if (i_code == 0x41)
+		pr_cont("Error Interrupt");
+	else if (i_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (i_code < 0x20)
+		pr_cont("FIFO %u", i_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", i_code);
+}
+
+#define __dump_int(val, bit, desc) \
+	pr_info("\t" __stringify(bit) "\t%s\t%s\t%s\t%s\n", \
+		 (val) & MCP25XXFD_CAN_INT_##bit##E ? "x" : "", \
+		 (val) & MCP25XXFD_CAN_INT_##bit##F ? "x" : "", \
+		 FIELD_GET(MCP25XXFD_CAN_INT_IF_MASK, val) & \
+		 FIELD_GET(MCP25XXFD_CAN_INT_IE_MASK, val) & \
+		 MCP25XXFD_CAN_INT_##bit##F ? "x" : "", \
+		 desc)
+
+static void mcp25xxfd_dump_reg_intf(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("INT: intf(0x%03x)=0x%08x\n", addr, val);
+
+	pr_info("\t\tIE\tIF\tIE & IF\n");
+	__dump_int(val, IVMI, "Invalid Message Interrupt");
+	__dump_int(val, WAKI, "Bus Wake Up Interrupt");
+	__dump_int(val, CERRI, "CAN Bus Error Interrupt");
+	__dump_int(val, SERRI, "System Error Interrupt");
+	__dump_int(val, RXOVI, "Receive FIFO Overflow Interrupt");
+	__dump_int(val, TXATI, "Transmit Attempt Interrupt");
+	__dump_int(val, SPICRCI, "SPI CRC Error Interrupt");
+	__dump_int(val, ECCI, "ECC Error Interrupt");
+	__dump_int(val, TEFI, "Transmit Event FIFO Interrupt");
+	__dump_int(val, MODI, "Mode Change Interrupt");
+	__dump_int(val, TBCI, "Time Base Counter Interrupt");
+	__dump_int(val, RXI, "Receive FIFO Interrupt");
+	__dump_int(val, TXI, "Transmit FIFO Interrupt");
+}
+
+#undef __dump_int
+
+#define __create_dump_fifo_bitmask(fifo, name, description) \
+static void mcp25xxfd_dump_reg_##fifo(const struct mcp25xxfd_priv *priv, u32 val, u16 addr) \
+{ \
+	int i; \
+\
+	pr_info(__stringify(name) ": " __stringify(fifo) "(0x%03x)=0x%08x\n", addr, val); \
+	pr_info(description ":\n"); \
+	if (!val) { \
+		pr_info("\t\t-none-\n"); \
+		return; \
+	} \
+\
+	pr_info("\t\t"); \
+	for (i = 0; i < sizeof(val); i++) { \
+		if (val & BIT(i)) \
+			pr_cont("%d ", i); \
+	} \
+\
+	pr_cont("\n"); \
+}
+
+__create_dump_fifo_bitmask(rxif, RXIF, "Receive FIFO Interrupt Pending bits");
+__create_dump_fifo_bitmask(rxovif, RXOVIF, "Receive FIFO Overflow Interrupt Pending bits");
+__create_dump_fifo_bitmask(txif, TXIF, "Transmit FIFO Interrupt Pending bits");
+__create_dump_fifo_bitmask(txatif, TXATIF, "Transmit FIFO Attempt Interrupt Pending bits");
+__create_dump_fifo_bitmask(txreq, TXREQ, "Message Send Request bits");
+
+#undef __create_dump_fifo_bitmask
+
+static void mcp25xxfd_dump_reg_trec(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TREC: trec(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_CAN_TREC, TXBO, "Transmitter in Bus Off State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, TXBP, "Transmitter in Error Passive State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, RXBP, "Receiver in Error Passive State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, TXWARN, "Transmitter in Error Warning State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, RXWARN, "Receiver in Error Warning State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, EWARN, "Transmitter or Receiver is in Error Warning State");
+
+	__dump_mask(val, MCP25XXFD_CAN_TREC, TEC, "%3lu", "Transmit Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_TREC, REC, "%3lu", "Receive Error Counter");
+}
+
+static void mcp25xxfd_dump_reg_bdiag0(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("BDIAG0: bdiag0(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, DTERRCNT, "%3lu", "Data Bit Rate Transmit Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, DRERRCNT, "%3lu", "Data Bit Rate Receive Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, NTERRCNT, "%3lu", "Nominal Bit Rate Transmit Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, NRERRCNT, "%3lu", "Nominal Bit Rate Receive Error Counter");
+}
+
+static void mcp25xxfd_dump_reg_bdiag1(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("BDIAG1: bdiag1(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DLCMM, "DLC Mismatch");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, ESI, "ESI flag of a received CAN FD message was set");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DCRCERR, "Data CRC Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DSTUFERR, "Data Bit Stuffing Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DFORMERR, "Data Format Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DBIT1ERR, "Data BIT1 Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DBIT0ERR, "Data BIT0 Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, TXBOERR, "Device went to bus-off (and auto-recovered)");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NCRCERR, "CRC Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NSTUFERR, "Bit Stuffing Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NFORMERR, "Format Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NACKERR, "Transmitted message was not acknowledged");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NBIT1ERR, "Bit1 Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NBIT0ERR, "Bit0 Error");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG1, EFMSGCNT, "%3lu", "Error Free Message Counter bits");
+}
+
+static void mcp25xxfd_dump_reg_osc(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("OSC: osc(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_OSC, SCLKRDY, "Synchronized SCLKDIV");
+	__dump_bit(val, MCP25XXFD_OSC, OSCRDY, "Clock Ready");
+	__dump_bit(val, MCP25XXFD_OSC, PLLRDY, "PLL Ready");
+	__dump_mask(val, MCP25XXFD_OSC, CLKODIV, "%2lu", "Clock Output Divisor");
+	__dump_bit(val, MCP25XXFD_OSC, SCLKDIV, "System Clock Divisor");
+	__dump_bit(val, MCP25XXFD_OSC, LPMEN, "Low Power Mode (LPM) Enable (MCP2518FD only)");
+	__dump_bit(val, MCP25XXFD_OSC, OSCDIS, "Clock (Oscillator) Disable");
+	__dump_bit(val, MCP25XXFD_OSC, PLLEN, "PLL Enable");
+}
+
+static void mcp25xxfd_dump_reg_tefcon(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFCON: tefcon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_TEFCON, FSIZE, "%3lu", "FIFO Size");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, FRESET, "FIFO Reset");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, UINC, "Increment Tail");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFTSEN, "Transmit Event FIFO Time Stamp Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFOVIE, "Transmit Event FIFO Overflow Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFFIE, "Transmit Event FIFO Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFHIE, "Transmit Event FIFO Half Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFNEIE, "Transmit Event FIFO Not Empty Interrupt Enable");
+}
+
+static void mcp25xxfd_dump_reg_tefsta(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFSTA: tefsta(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFOVIF, "Transmit Event FIFO Overflow Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFFIF, "Transmit Event FIFO Full Interrupt Flag (0 = not full)");
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFHIF, "Transmit Event FIFO Half Full Interrupt Flag (0= < half full)");
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFNEIF, "Transmit Event FIFO Not Empty Interrupt Flag (0=empty)");
+}
+
+static void mcp25xxfd_dump_reg_tefua(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFUA: tefua(0x%03x)=0x%08x\n", addr, val);
+}
+
+static void mcp25xxfd_dump_reg_fifocon(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOCON: fifocon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, PLSIZE, "%3lu", "Payload Size");
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, FSIZE, "%3lu", "FIFO Size");
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, TXAT, "%3lu", "Retransmission Attempts");
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, TXPRI, "%3lu", "Message Transmit Priority");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, FRESET, "FIFO Reset");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXREQ, "Message Send Request");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, UINC, "Increment Head/Tail");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXEN, "TX/RX FIFO Selection (0=RX, 1=TX)");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RTREN, "Auto RTR Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RXTSEN, "Received Message Time Stamp Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXATIE, "Transmit Attempts Exhausted Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RXOVIE, "Overflow Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFERFFIE, "Transmit/Receive FIFO Empty/Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFHRFHIE, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFNRFNIE, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Enable");
+}
+
+static void mcp25xxfd_dump_reg_fifosta(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOSTA: fifosta(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_FIFOSTA, FIFOCI, "%3lu", "FIFO Message Index");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXABT, "Message Aborted Status (1=aborted, 0=completed successfully)");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXLARB, "Message Lost Arbitration Status");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXERR, "Error Detected During Transmission");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXATIF, "Transmit Attempts Exhausted Interrupt Pending");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, RXOVIF, "Receive FIFO Overflow Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFERFFIF, "Transmit/Receive FIFO Empty/Full Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFHRFHIF, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFNRFNIF, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Flag");
+}
+
+static void mcp25xxfd_dump_reg_fifoua(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOUA: fifoua(0x%03x)=0x%08x\n", addr, val);
+}
+
+#define __dump_call(regs, val) \
+do { \
+	mcp25xxfd_dump_reg_##val(priv, (regs)->val, (u16)offsetof(typeof(*(regs)), val)); \
+	pr_info("\n"); \
+} while (0)
+
+#define __dump_call_fifo(reg, val) \
+do { \
+	mcp25xxfd_dump_reg_##reg(priv, regs->val, (u16)offsetof(typeof(*regs), val)); \
+	pr_info("\n"); \
+} while (0)
+
+static void
+mcp25xxfd_dump_regs(const struct mcp25xxfd_priv *priv,
+		    const struct mcp25xxfd_dump_regs *regs,
+		    const struct mcp25xxfd_dump_regs_mcp25xxfd *regs_mcp25xxfd)
+{
+	netdev_info(priv->ndev, "-------------------- register dump --------------------\n");
+	__dump_call(regs_mcp25xxfd, osc);
+	__dump_call(regs, con);
+	__dump_call(regs, tbc);
+	__dump_call(regs, vec);
+	__dump_call(regs, intf);
+	__dump_call(regs, rxif);
+	__dump_call(regs, rxovif);
+	__dump_call(regs, txif);
+	__dump_call(regs, txatif);
+	__dump_call(regs, txreq);
+	__dump_call(regs, trec);
+	__dump_call(regs, bdiag0);
+	__dump_call(regs, bdiag1);
+	pr_info("-------------------- TEF --------------------\n");
+	__dump_call(regs, tefcon);
+	__dump_call(regs, tefsta);
+	__dump_call(regs, tefua);
+	pr_info("-------------------- TX_FIFO --------------------\n");
+	__dump_call_fifo(fifocon, fifo[MCP25XXFD_TX_FIFO].con);
+	__dump_call_fifo(fifosta, fifo[MCP25XXFD_TX_FIFO].sta);
+	__dump_call_fifo(fifoua, fifo[MCP25XXFD_TX_FIFO].ua);
+	pr_info(" -------------------- RX_FIFO --------------------\n");
+	__dump_call_fifo(fifocon, fifo[MCP25XXFD_RX_FIFO(0)].con);
+	__dump_call_fifo(fifosta, fifo[MCP25XXFD_RX_FIFO(0)].sta);
+	__dump_call_fifo(fifoua, fifo[MCP25XXFD_RX_FIFO(0)].ua);
+	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
+}
+
+#undef __dump_call
+#undef __dump_call_fifo
+
+static u8 mcp25xxfd_dump_get_fifo_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u32 fifo_con)
+{
+	u8 obj_size;
+
+	obj_size = FIELD_GET(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK, fifo_con);
+	switch (obj_size) {
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_8:
+		return 8;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_12:
+		return 12;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_16:
+		return 16;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_20:
+		return 20;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_24:
+		return 24;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_32:
+		return 32;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_48:
+		return 48;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_64:
+		return 64;
+	}
+
+	return 0;
+}
+
+static u8 mcp25xxfd_dump_get_fifo_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u32 fifo_con)
+{
+	u8 obj_num;
+
+	obj_num = FIELD_GET(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK, fifo_con);
+
+	return obj_num + 1;
+}
+
+static void mcp25xxfd_dump_ram_fifo_obj_data(const struct mcp25xxfd_priv *priv, const u8 *data, u8 dlc)
+{
+	int i;
+	u8 len;
+
+	len = can_dlc2len(get_canfd_dlc(dlc));
+
+	if (!len) {
+		pr_info("%16s = -none-\n", "data");
+		return;
+	}
+
+	for (i = 0; i < len; i++) {
+		if ((i % 8) == 0) {
+			if (i == 0)
+				pr_info("%16s = %02x", "data", data[i]);
+			else
+				pr_info("                   %02x", data[i]);
+		} else if ((i % 4) == 0) {
+			pr_cont("  %02x", data[i]);
+		} else if ((i % 8) == 7) {
+			pr_cont(" %02x\n", data[i]);
+		} else {
+			pr_cont(" %02x", data[i]);
+		}
+	}
+
+	if (i % 8)
+		pr_cont("\n");
+}
+
+/* TEF */
+
+static u8 mcp25xxfd_dump_get_tef_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->tef.con);
+}
+
+static u8 mcp25xxfd_dump_get_tef_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return regs->tefua / sizeof(struct mcp25xxfd_hw_tef_obj);
+}
+
+static u16 mcp25xxfd_dump_get_tef_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return sizeof(struct mcp25xxfd_hw_tef_obj) * n;
+}
+
+static u16 mcp25xxfd_dump_get_tef_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_dump_get_tef_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+/* TX */
+
+static u8 mcp25xxfd_dump_get_tx_obj_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return sizeof(struct mcp25xxfd_hw_tx_obj_can) -
+		FIELD_SIZEOF(struct mcp25xxfd_hw_tx_obj_can, data) +
+		mcp25xxfd_dump_get_fifo_size(priv, regs, regs->tx_fifo.con);
+}
+
+static u8 mcp25xxfd_dump_get_tx_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->tx_fifo.con);
+}
+
+static u16 mcp25xxfd_dump_get_tx_obj_rel_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_tef_obj_rel_addr(priv, mcp25xxfd_dump_get_tef_obj_num(priv, regs)) +
+		mcp25xxfd_dump_get_tx_obj_size(priv, regs) * n;
+}
+
+static u16 mcp25xxfd_dump_get_tx_obj_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, n) + MCP25XXFD_RAM_START;
+}
+
+static u8 mcp25xxfd_dump_get_tx_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return (regs->fifo[MCP25XXFD_TX_FIFO].ua -
+		mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, 0)) /
+		mcp25xxfd_dump_get_tx_obj_size(priv, regs);
+}
+
+static u8 mcp25xxfd_dump_get_tx_head(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP25XXFD_TX_FIFO].sta);
+}
+
+/* RX */
+
+static u8 mcp25xxfd_dump_get_rx_obj_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return sizeof(struct mcp25xxfd_hw_rx_obj_can) -
+		FIELD_SIZEOF(struct mcp25xxfd_hw_rx_obj_can, data) +
+		mcp25xxfd_dump_get_fifo_size(priv, regs, regs->rx_fifo.con);
+}
+
+static u8 mcp25xxfd_dump_get_rx_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->rx_fifo.con);
+}
+
+static u16 mcp25xxfd_dump_get_rx_obj_rel_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, mcp25xxfd_dump_get_tx_obj_num(priv, regs)) +
+		mcp25xxfd_dump_get_rx_obj_size(priv, regs) * n;
+}
+
+static u16 mcp25xxfd_dump_get_rx_obj_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, n) + MCP25XXFD_RAM_START;
+}
+
+static u8 mcp25xxfd_dump_get_rx_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return (regs->fifo[MCP25XXFD_RX_FIFO(0)].ua -
+		mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, 0)) /
+		mcp25xxfd_dump_get_rx_obj_size(priv, regs);
+}
+
+static u8 mcp25xxfd_dump_get_rx_head(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP25XXFD_RX_FIFO(0)].sta);
+}
+
+/* dump TEF */
+
+static void mcp25xxfd_dump_ram_tef_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_tef_obj *hw_tef_obj, u8 n)
+{
+	pr_info("TEF Object: 0x%02x (0x%03x)%s%s%s%s%s\n",
+		n, mcp25xxfd_dump_get_tef_obj_addr(priv, n),
+		mcp25xxfd_get_tef_head(priv) == n ? "  priv-HEAD" : "",
+		mcp25xxfd_dump_get_tef_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp25xxfd_get_tef_tail(priv) == n ? "  priv-TAIL" : "",
+		(mcp25xxfd_dump_get_tef_tail(priv, regs) == n ?
+		 ((regs->tef.sta & MCP25XXFD_CAN_TEFSTA_TEFFIF) ? "  chip-FIFO-full" :
+		  !(regs->tef.sta & MCP25XXFD_CAN_TEFSTA_TEFNEIF) ? "  chip-FIFO-empty" : "") :
+		 ("")),
+		(mcp25xxfd_get_tef_head(priv) == mcp25xxfd_get_tef_tail(priv) &&
+		 mcp25xxfd_get_tef_tail(priv) == n ?
+		 (priv->tef.head == priv->tef.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_tef_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_tef_obj->flags);
+	pr_info("%16s = 0x%08x\n", "ts", hw_tef_obj->ts);
+	__dump_mask(hw_tef_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ, "0x%06lx", "Sequence");
+	pr_info("\n");
+}
+
+static void mcp25xxfd_dump_ram_tef_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	int i;
+
+	pr_info("\nTEF Overview:\n");
+	pr_info("%16s =        0x%02x    0x%08x\n", "head (p)", mcp25xxfd_get_tef_head(priv), priv->tef.head);
+	pr_info("%16s = 0x%02x   0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_tef_tail(priv, regs), mcp25xxfd_get_tef_tail(priv), priv->tef.tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp25xxfd_dump_get_tef_obj_num(priv, regs); i++) {
+		const struct mcp25xxfd_hw_tef_obj *hw_tef_obj;
+		u16 hw_tef_obj_rel_addr;
+
+		hw_tef_obj_rel_addr = mcp25xxfd_dump_get_tef_obj_rel_addr(priv, i);
+
+		hw_tef_obj = (const struct mcp25xxfd_hw_tef_obj *)&ram->ram[hw_tef_obj_rel_addr];
+		mcp25xxfd_dump_ram_tef_obj_one(priv, regs, hw_tef_obj, i);
+	}
+}
+
+/* dump TX */
+
+static void mcp25xxfd_dump_ram_tx_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_tx_obj_canfd *hw_tx_obj, u8 n)
+{
+	pr_info("TX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
+		n, mcp25xxfd_dump_get_tx_obj_addr(priv, regs, n),
+		mcp25xxfd_dump_get_tx_head(priv, regs) == n ? "  chip-HEAD" : "",
+		mcp25xxfd_get_tx_head(priv) == n ? "  priv-HEAD" : "",
+		mcp25xxfd_dump_get_tx_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp25xxfd_get_tx_tail(priv) == n ? "  priv-TAIL" : "",
+		mcp25xxfd_dump_get_tx_tail(priv, regs) == n ?
+		(!(regs->tx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-full" :
+		 (regs->tx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFERFFIF) ? "  chip-FIFO-empty" : "") :
+		(""),
+		(mcp25xxfd_get_tx_head(priv) == mcp25xxfd_get_tx_tail(priv) &&
+		 mcp25xxfd_get_tx_tail(priv) == n ?
+		 (priv->tx.head == priv->tx.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_tx_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_tx_obj->flags);
+	__dump_mask(hw_tx_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ_MCP2517FD, "0x%06lx", "Sequence (MCP2517)");
+	__dump_mask(hw_tx_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ_MCP2518FD, "0x%06lx", "Sequence (MCP2518)");
+	mcp25xxfd_dump_ram_fifo_obj_data(priv, hw_tx_obj->data, FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_tx_obj->flags));
+	pr_info("\n");
+}
+
+static void mcp25xxfd_dump_ram_tx_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	int i;
+
+	pr_info("\nTX Overview:\n");
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)", mcp25xxfd_dump_get_tx_head(priv, regs), mcp25xxfd_get_tx_head(priv), priv->tx.head);
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_tx_tail(priv, regs), mcp25xxfd_get_tx_tail(priv), priv->tx.tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp25xxfd_dump_get_tx_obj_num(priv, regs); i++) {
+		const struct mcp25xxfd_hw_tx_obj_canfd *hw_tx_obj;
+		u16 hw_tx_obj_rel_addr;
+
+		hw_tx_obj_rel_addr = mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, i);
+		hw_tx_obj = (const struct mcp25xxfd_hw_tx_obj_canfd *)&ram->ram[hw_tx_obj_rel_addr];
+
+		mcp25xxfd_dump_ram_tx_obj_one(priv, regs, hw_tx_obj, i);
+	}
+}
+
+/* dump RX */
+
+static void mcp25xxfd_dump_ram_rx_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj, u8 n)
+{
+	pr_info("RX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
+		n, mcp25xxfd_dump_get_rx_obj_addr(priv, regs, n),
+		mcp25xxfd_dump_get_rx_head(priv, regs) == n ? "  chip-HEAD" : "",
+		mcp25xxfd_get_rx_head(priv) == n ? "  priv-HEAD" : "",
+		mcp25xxfd_dump_get_rx_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp25xxfd_get_rx_tail(priv) == n ? "  priv-TAIL" : "",
+		mcp25xxfd_dump_get_rx_tail(priv, regs) == n ?
+		((regs->rx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFERFFIF) ? "  chip-FIFO-full" :
+		 !(regs->rx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-empty" : "") :
+		(""),
+		(mcp25xxfd_get_rx_head(priv) == mcp25xxfd_get_rx_tail(priv) &&
+		 mcp25xxfd_get_rx_tail(priv) == n ?
+		 (priv->rx.head == priv->rx.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_rx_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_rx_obj->flags);
+	pr_info("%16s = 0x%08x\n", "ts", hw_rx_obj->ts);
+	mcp25xxfd_dump_ram_fifo_obj_data(priv, hw_rx_obj->data, FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_rx_obj->flags));
+	pr_info("\n");
+}
+
+static void mcp25xxfd_dump_ram_rx_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	int i;
+
+	pr_info("\nRX Overview:\n");
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)", mcp25xxfd_dump_get_rx_head(priv, regs), mcp25xxfd_get_rx_head(priv), priv->rx.head);
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_rx_tail(priv, regs), mcp25xxfd_get_rx_tail(priv), priv->rx.tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp25xxfd_dump_get_rx_obj_num(priv, regs); i++) {
+		const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj;
+		u16 hw_rx_obj_rel_addr;
+
+		hw_rx_obj_rel_addr = mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, i);
+		hw_rx_obj = (const struct mcp25xxfd_hw_rx_obj_canfd *)&ram->ram[hw_rx_obj_rel_addr];
+
+		mcp25xxfd_dump_ram_rx_obj_one(priv, regs, hw_rx_obj, i);
+	}
+}
+
+#undef __dump_mask
+#undef __dump_bit
+
+static void mcp25xxfd_dump_ram(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	netdev_info(priv->ndev, "----------------------- RAM dump ----------------------\n");
+	mcp25xxfd_dump_ram_tef_obj(priv, regs, ram);
+	mcp25xxfd_dump_ram_tx_obj(priv, regs, ram);
+	mcp25xxfd_dump_ram_rx_obj(priv, regs, ram);
+	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
+}
+
+void mcp25xxfd_dump(struct mcp25xxfd_priv *priv)
+{
+	struct mcp25xxfd_dump_regs *regs = &priv->dump.regs;
+	struct mcp25xxfd_dump_ram *ram = &priv->dump.ram;
+	struct mcp25xxfd_dump_regs_mcp25xxfd *regs_mcp25xxfd = &priv->dump.regs_mcp25xxfd;
+	int err;
+
+	BUILD_BUG_ON(sizeof(struct mcp25xxfd_dump_regs) !=
+		     MCP25XXFD_CAN_FIFOUA(31) - MCP25XXFD_CAN_CON + 4);
+
+	err = regmap_bulk_read(priv->map, MCP25XXFD_CAN_CON,
+			       regs, sizeof(*regs) / sizeof(u32));
+	if (err)
+		return;
+
+	err = regmap_bulk_read(priv->map, MCP25XXFD_RAM_START,
+			       ram, sizeof(*ram) / sizeof(u32));
+	if (err)
+		return;
+
+	err = regmap_bulk_read(priv->map, MCP25XXFD_OSC,
+			       regs_mcp25xxfd, sizeof(*regs_mcp25xxfd) / sizeof(u32));
+	if (err)
+		return;
+
+	mcp25xxfd_dump_regs(priv, regs, regs_mcp25xxfd);
+	mcp25xxfd_dump_ram(priv, regs, ram);
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
new file mode 100644
index 000000000000..d1a70513d5e4
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019 Pengutronix,
+//                    Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include "mcp25xxfd.h"
+#include "mcp25xxfd-log.h"
+
+struct mcp25xxfd_log *___mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+	int cnt;
+
+	cnt = atomic_add_return(1, &priv->cnt);
+	cnt &= ARRAY_SIZE(priv->log) - 1;
+
+	log = &priv->log[cnt];
+	log->func = func;
+	log->can_id = can_id;
+	log->tef_head = priv->tef.head;
+	log->tef_tail = priv->tef.tail;
+	log->tx_head = priv->tx.head;
+	log->tx_tail = priv->tx.tail;
+	log->flags = 0;
+
+	return log;
+}
+
+static void mcp25xxfd_log_dump_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_log *last_log, const struct mcp25xxfd_log *log, int n)
+{
+	pr_info("%04d: %30s: ",
+		n, log->func);
+
+	if (log->can_id != -1 &&
+	    last_log->can_id != log->can_id)
+		pr_cont("id=%03x ", log->can_id);
+	else
+		pr_cont(" ---   ");
+
+	if (last_log->tef_head != log->tef_head)
+		pr_cont("tef_h=%08x/%02x ", log->tef_head, log->tef_head & (priv->tx.obj_num - 1));
+	else
+		pr_cont("    ---           ");
+
+	if (log->hw_tx_ci != -1 &&
+	    last_log->hw_tx_ci != log->hw_tx_ci)
+		pr_cont("hw_tx_ci=%02x ", log->hw_tx_ci);
+	else
+		pr_cont("       ---  ");
+
+	if (last_log->tef_tail != log->tef_tail)
+		pr_cont("tef_t=%08x/%02x ", log->tef_tail, log->tef_tail & (priv->tx.obj_num - 1));
+	else
+		pr_cont("    ---           ");
+
+	if (log->hw_tef_tail != -1 &&
+	    last_log->hw_tef_tail != log->hw_tef_tail)
+		pr_cont("hw_tef_t=%02x ", log->hw_tef_tail);
+	else
+		pr_cont("       ---  ");
+
+	if (last_log->tx_head != log->tx_head)
+		pr_cont("tx_h=%08x/%02x ", log->tx_head, log->tx_head & (priv->tx.obj_num - 1));
+	else
+		pr_cont("   ---           ");
+
+	if (last_log->tx_tail != log->tx_tail)
+		pr_cont("tx_t=%08x/%02x ", log->tx_tail, log->tx_tail & (priv->tx.obj_num - 1));
+	else
+		pr_cont("   ---           ");
+
+	pr_cont("%s%s%s\n",
+		log->flags & MCP25XXFD_LOG_STOP ? "s" : " ",
+		log->flags & MCP25XXFD_LOG_WAKE ? "w" : " ",
+		log->flags & MCP25XXFD_LOG_BUSY ? "b" : " ");
+}
+
+void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv)
+{
+	int cnt;
+	int i, n = 0;
+
+	cnt = atomic_read(&priv->cnt);
+	cnt &= ARRAY_SIZE(priv->log) - 1;
+
+	i = cnt;
+
+	if (cnt == 0) {
+		mcp25xxfd_log_dump_one(priv, &priv->log[ARRAY_SIZE(priv->log) - 2], &priv->log[0], n++);
+		i++;
+	}
+
+	for (/* nix */; i < ARRAY_SIZE(priv->log); i++)
+		mcp25xxfd_log_dump_one(priv, &priv->log[i - 1], &priv->log[i], n++);
+
+	if (cnt) {
+		mcp25xxfd_log_dump_one(priv, &priv->log[ARRAY_SIZE(priv->log) - 2], &priv->log[0], n++);
+		if (cnt > 1)
+			for (i = 1; i < cnt; i++)
+				mcp25xxfd_log_dump_one(priv, &priv->log[i - 1], &priv->log[i], n++);
+	}
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
new file mode 100644
index 000000000000..cadb07780ee1
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
@@ -0,0 +1,164 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+ *
+ * Copyright (c) 2019 Pengutronix,
+ *                    Marc Kleine-Budde <kernel@pengutronix.de>
+ */
+
+#ifndef _MCP25XXFD_LOG_H
+#define _MCP25XXFD_LOG_H
+
+struct mcp25xxfd_priv;
+
+#ifdef CONFIG_CAN_MCP25XXFD_LOG
+
+struct mcp25xxfd_log {
+	const char *func;
+	canid_t can_id;
+	u32 tef_head;
+	u32 tef_tail;
+	u32 tx_head;
+	u32 tx_tail;
+
+#define MCP25XXFD_LOG_STOP BIT(0)
+#define MCP25XXFD_LOG_WAKE BIT(1)
+#define MCP25XXFD_LOG_BUSY BIT(2)
+	u32 flags;
+
+	u32 hw_tx_ci;
+	u32 hw_tef_tail;
+};
+
+struct mcp25xxfd_log *___mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id);
+void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv);
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = ___mcp25xxfd_log(priv, func, can_id);
+	log->hw_tx_ci = -1;
+	log->hw_tef_tail = -1;
+
+	return log;
+}
+
+#define mcp25xxfd_log(priv, ...) __mcp25xxfd_log(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_no_canid(struct mcp25xxfd_priv *priv, const char *func)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, -1);
+	log->can_id = -1;
+
+	return log;
+}
+
+#define mcp25xxfd_log_no_canid(priv, ...) __mcp25xxfd_log_no_canid(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_stop(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, can_id);
+	log->flags |= MCP25XXFD_LOG_STOP;
+
+	return log;
+}
+
+#define mcp25xxfd_log_stop(priv, ...) __mcp25xxfd_log_stop(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_wake(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, can_id);
+	log->flags |= MCP25XXFD_LOG_WAKE;
+
+	return log;
+}
+
+#define mcp25xxfd_log_wake(priv, ...) __mcp25xxfd_log_wake(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_busy(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, can_id);
+	log->flags |= MCP25XXFD_LOG_BUSY;
+
+	return log;
+}
+
+#define mcp25xxfd_log_busy(priv, ...) __mcp25xxfd_log_busy(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_hw_tx_ci(struct mcp25xxfd_priv *priv, const char *func, u32 tx_ci)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log_no_canid(priv, func);
+	log->hw_tx_ci = tx_ci;
+
+	return log;
+}
+
+#define mcp25xxfd_log_hw_tx_ci(priv, ...) __mcp25xxfd_log_hw_tx_ci(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_hw_tef_tail(struct mcp25xxfd_priv *priv, const char *func, u32 tef_tail)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log_no_canid(priv, func);
+	log->hw_tef_tail = tef_tail;
+
+	return log;
+}
+
+#define mcp25xxfd_log_hw_tef_tail(priv, ...) __mcp25xxfd_log_hw_tef_tail(priv, __func__, ## __VA_ARGS__)
+
+#else
+
+static inline void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv)
+{
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_no_canid(struct mcp25xxfd_priv *priv)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_stop(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_wake(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_busy(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_hw_tx_ci(struct mcp25xxfd_priv *priv, u32 tx_ci)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_hw_tef_tail(struct mcp25xxfd_priv *priv, u32 tef_tail)
+{
+	return NULL;
+}
+
+#endif
+
+#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
new file mode 100644
index 000000000000..c2628653d48c
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
@@ -0,0 +1,268 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include "mcp25xxfd.h"
+
+static int mcp25xxfd_regmap_write(void *context, const void *data, size_t count)
+{
+	struct spi_device *spi = context;
+
+	return spi_write(spi, data, count);
+}
+
+static int mcp25xxfd_regmap_gather_write(void *context,
+					 const void *reg, size_t reg_len,
+					 const void *val, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = reg,
+			.len = reg_len,
+		}, {
+			.tx_buf = val,
+			.len = val_len,
+		},
+	};
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static inline bool mcp25xxfd_update_bits_read_reg(unsigned int reg)
+{
+	switch (reg) {
+	case MCP25XXFD_CAN_INT:
+	case MCP25XXFD_CAN_TEFCON:
+	case MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)):
+	case MCP25XXFD_ECCSTAT:
+	case MCP25XXFD_CRC:
+		return false;
+	case MCP25XXFD_CAN_BDIAG1:
+	case MCP25XXFD_CAN_CON:
+	case MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_RX_FIFO(0)):
+	case MCP25XXFD_OSC:
+		return true;
+	default:
+		WARN(1, "Status of reg=%03x unknown.\n", reg);
+	}
+
+	return true;
+}
+
+static int mcp25xxfd_regmap_update_bits(void *context, unsigned int reg,
+					unsigned int mask, unsigned int val)
+
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp25xxfd_reg_write_buf *buf = &priv->update_bits_buf;
+	__be16 cmd;
+	__le32 orig_le32 = 0, mask_le32, val_le32, tmp_le32;
+	u8 first_byte, last_byte, len;
+	int err;
+
+	first_byte = mcp25xxfd_first_byte_set(mask);
+	last_byte = mcp25xxfd_last_byte_set(mask);
+	len = last_byte - first_byte + 1;
+
+	if (mcp25xxfd_update_bits_read_reg(reg)) {
+		cmd = mcp25xxfd_cmd_read(reg + first_byte);
+		/* spi_write_then_read() works with non DMA-safe buffers */
+		err = spi_write_then_read(priv->spi,
+					  &cmd, sizeof(cmd), &orig_le32, len);
+
+		if (err)
+			return err;
+	}
+
+	mask_le32 = cpu_to_le32(mask >> 8 * first_byte);
+	val_le32 = cpu_to_le32(val >> 8 * first_byte);
+
+	tmp_le32 = orig_le32 & ~mask_le32;
+	tmp_le32 |= val_le32 & mask_le32;
+
+	buf->cmd = mcp25xxfd_cmd_write(reg + first_byte);
+	memcpy(buf->data, &tmp_le32, len);
+
+	return spi_write(spi, buf, sizeof(buf->cmd) + len);
+}
+
+static int mcp25xxfd_regmap_read(void *context,
+				 const void *reg, size_t reg_len,
+				 void *val_buf, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = reg,
+			.len = reg_len,
+		}, {
+			.rx_buf = val_buf,
+			.len = val_len,
+		},
+	};
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static int mcp25xxfd_regmap_crc_gather_write(void *context,
+					     const void *reg, size_t reg_len,
+					     const void *val, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = &priv->crc_buf.addr,
+			.len = sizeof(priv->crc_buf.addr),
+		}, {
+			.tx_buf = val,
+			.len = val_len,
+		}, {
+			.rx_buf = &priv->crc_buf.crc,
+			.len = sizeof(priv->crc_buf.crc),
+		},
+	};
+	u16 crc;
+
+	priv->crc_buf.addr.cmd = *(__be16 *)reg;
+	priv->crc_buf.addr.len = val_len;
+
+	crc = mcp25xxfd_crc16_compute(xfer[0].tx_buf, xfer[0].len,
+				      xfer[1].rx_buf, xfer[1].len);
+	priv->crc_buf.crc = cpu_to_be16(crc);
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static int mcp25xxfd_regmap_crc_write(void *context,
+				      const void *data, size_t count)
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+
+	return mcp25xxfd_regmap_crc_gather_write(context, data,
+						 sizeof(priv->crc_buf.addr),
+						 data + 4, count - 4);
+}
+
+static int mcp25xxfd_regmap_crc_read(void *context,
+				     const void *reg, size_t reg_len,
+				     void *val_buf, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = &priv->crc_buf.addr,
+			.len = sizeof(priv->crc_buf.addr),
+		}, {
+			.rx_buf = val_buf,
+			.len = val_len,
+		}, {
+			.rx_buf = &priv->crc_buf.crc,
+			.len = sizeof(priv->crc_buf.crc),
+		},
+	};
+	u16 crc_received, crc_calculated;
+	int err;
+
+	priv->crc_buf.addr.cmd = *(__be16 *)reg;
+	priv->crc_buf.addr.len = val_len;
+
+	err = spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+	if (err)
+		return err;
+
+	crc_received = be16_to_cpu(priv->crc_buf.crc);
+	crc_calculated = mcp25xxfd_crc16_compute(xfer[0].tx_buf, xfer[0].len,
+						 xfer[1].rx_buf, xfer[1].len);
+	if (crc_received != crc_calculated) {
+		__dump(xfer[0].tx_buf, xfer[0].len);
+		__dump(xfer[1].rx_buf, xfer[1].len);
+		__dump(&crc_received, sizeof(crc_received));
+		__dump(&crc_calculated, sizeof(crc_calculated));
+		return -EBADMSG;
+	}
+
+	return 0;
+}
+
+static const struct regmap_range mcp25xxfd_reg_table_yes_range[] = {
+	regmap_reg_range(0x000, 0x2ec),	/* CAN FD Controller Module SFR */
+	regmap_reg_range(0x400, 0xbfc),	/* RAM */
+	regmap_reg_range(0xe00, 0xe14),	/* MCP2517/18FD SFR */
+};
+
+static const struct regmap_access_table mcp25xxfd_reg_table = {
+	.yes_ranges = mcp25xxfd_reg_table_yes_range,
+	.n_yes_ranges = ARRAY_SIZE(mcp25xxfd_reg_table_yes_range),
+};
+
+static const struct regmap_config mcp25xxfd_regmap = {
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.pad_bits = 0,
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.wr_table = &mcp25xxfd_reg_table,
+	.rd_table = &mcp25xxfd_reg_table,
+	.cache_type = REGCACHE_NONE,
+	.read_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_READ),
+	.write_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE),
+};
+
+static const struct regmap_bus mcp25xxfd_bus = {
+	.write = mcp25xxfd_regmap_write,
+	.gather_write = mcp25xxfd_regmap_gather_write,
+	.reg_update_bits = mcp25xxfd_regmap_update_bits,
+	.read = mcp25xxfd_regmap_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+};
+
+static const struct regmap_config mcp25xxfd_regmap_crc = {
+	.name = "crc",
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.pad_bits = 16,		/* keep data bits aligned */
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.wr_table = &mcp25xxfd_reg_table,
+	.rd_table = &mcp25xxfd_reg_table,
+	.cache_type = REGCACHE_NONE,
+	.read_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_READ_CRC),
+	.write_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE_CRC),
+};
+
+static const struct regmap_bus mcp25xxfd_bus_crc = {
+	.write = mcp25xxfd_regmap_crc_write,
+	.gather_write = mcp25xxfd_regmap_crc_gather_write,
+	.read = mcp25xxfd_regmap_crc_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+	.max_raw_read = 256 - 4,
+	.max_raw_write = 256 - 4,
+};
+
+int mcp25xxfd_regmap_init(struct mcp25xxfd_priv *priv)
+{
+	priv->map = devm_regmap_init(&priv->spi->dev, &mcp25xxfd_bus,
+				     priv->spi, &mcp25xxfd_regmap);
+	if (IS_ERR(priv->map))
+		return PTR_ERR(priv->map);
+
+	priv->map_crc = devm_regmap_init(&priv->spi->dev, &mcp25xxfd_bus_crc,
+					 priv->spi, &mcp25xxfd_regmap_crc);
+	return PTR_ERR_OR_ZERO(priv->map_crc);
+
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
new file mode 100644
index 000000000000..119cdbdbe9d2
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
@@ -0,0 +1,757 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+ *
+ * Copyright (c) 2019 Pengutronix,
+ *                    Marc Kleine-Budde <kernel@pengutronix.de>
+ * Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef _MCP25XXFD_H
+#define _MCP25XXFD_H
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/can/rx-offload.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd-log.h"
+
+static inline void __dump(const void *d, unsigned int len)
+{
+	const u8 *data = d;
+	unsigned int i;
+
+	for (i = 0; i < len; i++) {
+		if ((i % 8) == 0) {
+			if (i == 0)
+				pr_info("%16s = %02x", "data", data[i]);
+			else
+				pr_info("                   %02x", data[i]);
+		} else if ((i % 4) == 0) {
+			pr_cont("  %02x", data[i]);
+		} else if ((i % 8) == 7) {
+			pr_cont(" %02x\n", data[i]);
+		} else {
+			pr_cont(" %02x", data[i]);
+		}
+	}
+
+	if (i % 8)
+		pr_cont("\n");
+}
+
+/* MPC25xx registers */
+
+/* CAN FD Controller Module SFR */
+#define MCP25XXFD_CAN_CON 0x00
+#define MCP25XXFD_CAN_CON_TXBWS_MASK GENMASK(31, 28)
+#define MCP25XXFD_CAN_CON_ABAT BIT(27)
+#define MCP25XXFD_CAN_CON_REQOP_MASK GENMASK(26, 24)
+#define MCP25XXFD_CAN_CON_MODE_MIXED 0
+#define MCP25XXFD_CAN_CON_MODE_SLEEP 1
+#define MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK 2
+#define MCP25XXFD_CAN_CON_MODE_LISTENONLY 3
+#define MCP25XXFD_CAN_CON_MODE_CONFIG 4
+#define MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK 5
+#define MCP25XXFD_CAN_CON_MODE_CAN2_0 6
+#define MCP25XXFD_CAN_CON_MODE_RESTRICTED 7
+#define MCP25XXFD_CAN_CON_OPMOD_MASK GENMASK(23, 21)
+#define MCP25XXFD_CAN_CON_TXQEN BIT(20)
+#define MCP25XXFD_CAN_CON_STEF BIT(19)
+#define MCP25XXFD_CAN_CON_SERR2LOM BIT(18)
+#define MCP25XXFD_CAN_CON_ESIGM BIT(17)
+#define MCP25XXFD_CAN_CON_RTXAT BIT(16)
+#define MCP25XXFD_CAN_CON_BRSDIS BIT(12)
+#define MCP25XXFD_CAN_CON_BUSY BIT(11)
+#define MCP25XXFD_CAN_CON_WFT_MASK GENMASK(10, 9)
+#define MCP25XXFD_CAN_CON_WFT_T00FILTER 0x0
+#define MCP25XXFD_CAN_CON_WFT_T01FILTER 0x1
+#define MCP25XXFD_CAN_CON_WFT_T10FILTER 0x2
+#define MCP25XXFD_CAN_CON_WFT_T11FILTER 0x3
+#define MCP25XXFD_CAN_CON_WAKFIL BIT(8)
+#define MCP25XXFD_CAN_CON_PXEDIS BIT(6)
+#define MCP25XXFD_CAN_CON_ISOCRCEN BIT(5)
+#define MCP25XXFD_CAN_CON_DNCNT_MASK GENMASK(4, 0)
+
+#define MCP25XXFD_CAN_NBTCFG 0x04
+#define MCP25XXFD_CAN_NBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP25XXFD_CAN_NBTCFG_TSEG1_MASK GENMASK(23, 16)
+#define MCP25XXFD_CAN_NBTCFG_TSEG2_MASK GENMASK(14, 8)
+#define MCP25XXFD_CAN_NBTCFG_SJW_MASK GENMASK(6, 0)
+
+#define MCP25XXFD_CAN_DBTCFG 0x08
+#define MCP25XXFD_CAN_DBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP25XXFD_CAN_DBTCFG_TSEG1_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_DBTCFG_TSEG2_MASK GENMASK(11, 8)
+#define MCP25XXFD_CAN_DBTCFG_SJW_MASK GENMASK(3, 0)
+
+#define MCP25XXFD_CAN_TDC 0x0c
+#define MCP25XXFD_CAN_TDC_EDGFLTEN BIT(25)
+#define MCP25XXFD_CAN_TDC_SID11EN BIT(24)
+#define MCP25XXFD_CAN_TDC_TDCMOD_MASK GENMASK(17, 16)
+#define MCP25XXFD_CAN_TDC_TDCMOD_AUTO 2
+#define MCP25XXFD_CAN_TDC_TDCMOD_MANUAL 1
+#define MCP25XXFD_CAN_TDC_TDCMOD_DISABLED 0
+#define MCP25XXFD_CAN_TDC_TDCO_MASK GENMASK(14, 8)
+#define MCP25XXFD_CAN_TDC_TDCV_MASK GENMASK(5, 0)
+
+#define MCP25XXFD_CAN_TBC 0x10
+
+#define MCP25XXFD_CAN_TSCON 0x14
+#define MCP25XXFD_CAN_TSCON_TSRES BIT(18)
+#define MCP25XXFD_CAN_TSCON_TSEOF BIT(17)
+#define MCP25XXFD_CAN_TSCON_TBCEN BIT(16)
+#define MCP25XXFD_CAN_TSCON_TBCPRE_MASK GENMASK(9, 0)
+
+#define MCP25XXFD_CAN_VEC 0x18
+#define MCP25XXFD_CAN_VEC_RXCODE_MASK GENMASK(30, 24)
+#define MCP25XXFD_CAN_VEC_TXCODE_MASK GENMASK(22, 16)
+#define MCP25XXFD_CAN_VEC_FILHIT_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_VEC_ICODE_MASK GENMASK(6, 0)
+
+#define MCP25XXFD_CAN_INT 0x1c
+#define MCP25XXFD_CAN_INT_IF_MASK GENMASK(15, 0)
+#define MCP25XXFD_CAN_INT_IE_MASK GENMASK(31, 16)
+#define MCP25XXFD_CAN_INT_IVMIE BIT(31)
+#define MCP25XXFD_CAN_INT_WAKIE BIT(30)
+#define MCP25XXFD_CAN_INT_CERRIE BIT(29)
+#define MCP25XXFD_CAN_INT_SERRIE BIT(28)
+#define MCP25XXFD_CAN_INT_RXOVIE BIT(27)
+#define MCP25XXFD_CAN_INT_TXATIE BIT(26)
+#define MCP25XXFD_CAN_INT_SPICRCIE BIT(25)
+#define MCP25XXFD_CAN_INT_ECCIE BIT(24)
+#define MCP25XXFD_CAN_INT_TEFIE BIT(20)
+#define MCP25XXFD_CAN_INT_MODIE BIT(19)
+#define MCP25XXFD_CAN_INT_TBCIE BIT(18)
+#define MCP25XXFD_CAN_INT_RXIE BIT(17)
+#define MCP25XXFD_CAN_INT_TXIE BIT(16)
+#define MCP25XXFD_CAN_INT_IVMIF BIT(15)
+#define MCP25XXFD_CAN_INT_WAKIF BIT(14)
+#define MCP25XXFD_CAN_INT_CERRIF BIT(13)
+#define MCP25XXFD_CAN_INT_SERRIF BIT(12)
+#define MCP25XXFD_CAN_INT_RXOVIF BIT(11)
+#define MCP25XXFD_CAN_INT_TXATIF BIT(10)
+#define MCP25XXFD_CAN_INT_SPICRCIF BIT(9)
+#define MCP25XXFD_CAN_INT_ECCIF BIT(8)
+#define MCP25XXFD_CAN_INT_TEFIF BIT(4)
+#define MCP25XXFD_CAN_INT_MODIF BIT(3)
+#define MCP25XXFD_CAN_INT_TBCIF BIT(2)
+#define MCP25XXFD_CAN_INT_RXIF BIT(1)
+#define MCP25XXFD_CAN_INT_TXIF BIT(0)
+/* These IRQ flags must be cleared by SW in the CAN_INT register */
+#define MCP25XXFD_CAN_INT_IF_CLEARABLE_MASK \
+	(MCP25XXFD_CAN_INT_IVMIF | MCP25XXFD_CAN_INT_WAKIF | \
+	 MCP25XXFD_CAN_INT_CERRIF |  MCP25XXFD_CAN_INT_SERRIF | \
+	 MCP25XXFD_CAN_INT_MODIF)
+
+#define MCP25XXFD_CAN_RXIF 0x20
+#define MCP25XXFD_CAN_TXIF 0x24
+#define MCP25XXFD_CAN_RXOVIF 0x28
+#define MCP25XXFD_CAN_TXATIF 0x2c
+#define MCP25XXFD_CAN_TXREQ 0x30
+
+#define MCP25XXFD_CAN_TREC 0x34
+#define MCP25XXFD_CAN_TREC_TXBO BIT(21)
+#define MCP25XXFD_CAN_TREC_TXBP BIT(20)
+#define MCP25XXFD_CAN_TREC_RXBP BIT(19)
+#define MCP25XXFD_CAN_TREC_TXWARN BIT(18)
+#define MCP25XXFD_CAN_TREC_RXWARN BIT(17)
+#define MCP25XXFD_CAN_TREC_EWARN BIT(16)
+#define MCP25XXFD_CAN_TREC_TEC_MASK GENMASK(15, 8)
+#define MCP25XXFD_CAN_TREC_REC_MASK GENMASK(7, 0)
+
+#define MCP25XXFD_CAN_BDIAG0 0x38
+#define MCP25XXFD_CAN_BDIAG0_DTERRCNT_MASK GENMASK(31, 24)
+#define MCP25XXFD_CAN_BDIAG0_DRERRCNT_MASK GENMASK(23, 16)
+#define MCP25XXFD_CAN_BDIAG0_NTERRCNT_MASK GENMASK(15, 8)
+#define MCP25XXFD_CAN_BDIAG0_NRERRCNT_MASK GENMASK(7, 0)
+
+#define MCP25XXFD_CAN_BDIAG1 0x3c
+#define MCP25XXFD_CAN_BDIAG1_DLCMM BIT(31)
+#define MCP25XXFD_CAN_BDIAG1_ESI BIT(30)
+#define MCP25XXFD_CAN_BDIAG1_DCRCERR BIT(29)
+#define MCP25XXFD_CAN_BDIAG1_DSTUFERR BIT(28)
+#define MCP25XXFD_CAN_BDIAG1_DFORMERR BIT(27)
+#define MCP25XXFD_CAN_BDIAG1_DBIT1ERR BIT(25)
+#define MCP25XXFD_CAN_BDIAG1_DBIT0ERR BIT(24)
+#define MCP25XXFD_CAN_BDIAG1_TXBOERR BIT(23)
+#define MCP25XXFD_CAN_BDIAG1_NCRCERR BIT(21)
+#define MCP25XXFD_CAN_BDIAG1_NSTUFERR BIT(20)
+#define MCP25XXFD_CAN_BDIAG1_NFORMERR BIT(19)
+#define MCP25XXFD_CAN_BDIAG1_NACKERR BIT(18)
+#define MCP25XXFD_CAN_BDIAG1_NBIT1ERR BIT(17)
+#define MCP25XXFD_CAN_BDIAG1_NBIT0ERR BIT(16)
+#define MCP25XXFD_CAN_BDIAG1_BERR_MASK \
+	(MCP25XXFD_CAN_BDIAG1_DLCMM | MCP25XXFD_CAN_BDIAG1_ESI | \
+	 MCP25XXFD_CAN_BDIAG1_DCRCERR | MCP25XXFD_CAN_BDIAG1_DSTUFERR | \
+	 MCP25XXFD_CAN_BDIAG1_DFORMERR | MCP25XXFD_CAN_BDIAG1_DBIT1ERR | \
+	 MCP25XXFD_CAN_BDIAG1_DBIT0ERR | MCP25XXFD_CAN_BDIAG1_TXBOERR | \
+	 MCP25XXFD_CAN_BDIAG1_NCRCERR | MCP25XXFD_CAN_BDIAG1_NSTUFERR | \
+	 MCP25XXFD_CAN_BDIAG1_NFORMERR | MCP25XXFD_CAN_BDIAG1_NACKERR | \
+	 MCP25XXFD_CAN_BDIAG1_NBIT1ERR | MCP25XXFD_CAN_BDIAG1_NBIT0ERR)
+#define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_MASK GENMASK(15, 0)
+
+#define MCP25XXFD_CAN_TEFCON 0x40
+#define MCP25XXFD_CAN_TEFCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_TEFCON_FRESET BIT(10)
+#define MCP25XXFD_CAN_TEFCON_UINC BIT(8)
+#define MCP25XXFD_CAN_TEFCON_TEFTSEN BIT(5)
+#define MCP25XXFD_CAN_TEFCON_TEFOVIE BIT(3)
+#define MCP25XXFD_CAN_TEFCON_TEFFIE BIT(2)
+#define MCP25XXFD_CAN_TEFCON_TEFHIE BIT(1)
+#define MCP25XXFD_CAN_TEFCON_TEFNEIE BIT(0)
+
+#define MCP25XXFD_CAN_TEFSTA 0x44
+#define MCP25XXFD_CAN_TEFSTA_TEFOVIF BIT(3)
+#define MCP25XXFD_CAN_TEFSTA_TEFFIF BIT(2)
+#define MCP25XXFD_CAN_TEFSTA_TEFHIF BIT(1)
+#define MCP25XXFD_CAN_TEFSTA_TEFNEIF BIT(0)
+
+#define MCP25XXFD_CAN_TEFUA 0x48
+
+#define MCP25XXFD_CAN_TXQCON 0x50
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_8 0
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_12 1
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_16 2
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_20 3
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_24 4
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_32 5
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_48 6
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_64 7
+#define MCP25XXFD_CAN_TXQCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_TXQCON_TXAT_UNLIMITED 3
+#define MCP25XXFD_CAN_TXQCON_TXAT_THREE_SHOT 1
+#define MCP25XXFD_CAN_TXQCON_TXAT_ONE_SHOT 0
+#define MCP25XXFD_CAN_TXQCON_TXAT_MASK GENMASK(22, 21)
+#define MCP25XXFD_CAN_TXQCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_TXQCON_FRESET BIT(10)
+#define MCP25XXFD_CAN_TXQCON_TXREQ BIT(9)
+#define MCP25XXFD_CAN_TXQCON_UINC BIT(8)
+#define MCP25XXFD_CAN_TXQCON_TXEN BIT(7)
+#define MCP25XXFD_CAN_TXQCON_TXATIE BIT(4)
+#define MCP25XXFD_CAN_TXQCON_TXQEIE BIT(2)
+#define MCP25XXFD_CAN_TXQCON_TXQNIE BIT(0)
+
+#define MCP25XXFD_CAN_TXQSTA 0x54
+#define MCP25XXFD_CAN_TXQSTA_TXQCI_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_TXQSTA_TXABT BIT(7)
+#define MCP25XXFD_CAN_TXQSTA_TXLARB BIT(6)
+#define MCP25XXFD_CAN_TXQSTA_TXERR BIT(5)
+#define MCP25XXFD_CAN_TXQSTA_TXATIF BIT(4)
+#define MCP25XXFD_CAN_TXQSTA_TXQEIF BIT(2)
+#define MCP25XXFD_CAN_TXQSTA_TXQNIF BIT(0)
+
+#define MCP25XXFD_CAN_TXQUA 0x58
+
+#define MCP25XXFD_CAN_FIFOCON(x) (0x50 + 0xc * (x))
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_8 0
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_12 1
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_16 2
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_20 3
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_24 4
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_32 5
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_48 6
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_64 7
+#define MCP25XXFD_CAN_FIFOCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_FIFOCON_TXAT_MASK GENMASK(22, 21)
+#define MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT 0
+#define MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT 1
+#define MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED 3
+#define MCP25XXFD_CAN_FIFOCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_FIFOCON_FRESET BIT(10)
+#define MCP25XXFD_CAN_FIFOCON_TXREQ BIT(9)
+#define MCP25XXFD_CAN_FIFOCON_UINC BIT(8)
+#define MCP25XXFD_CAN_FIFOCON_TXEN BIT(7)
+#define MCP25XXFD_CAN_FIFOCON_RTREN BIT(6)
+#define MCP25XXFD_CAN_FIFOCON_RXTSEN BIT(5)
+#define MCP25XXFD_CAN_FIFOCON_TXATIE BIT(4)
+#define MCP25XXFD_CAN_FIFOCON_RXOVIE BIT(3)
+#define MCP25XXFD_CAN_FIFOCON_TFERFFIE BIT(2)
+#define MCP25XXFD_CAN_FIFOCON_TFHRFHIE BIT(1)
+#define MCP25XXFD_CAN_FIFOCON_TFNRFNIE BIT(0)
+
+#define MCP25XXFD_CAN_FIFOSTA(x) (0x54 + 0xc * (x))
+#define MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_FIFOSTA_TXABT BIT(7)
+#define MCP25XXFD_CAN_FIFOSTA_TXLARB BIT(6)
+#define MCP25XXFD_CAN_FIFOSTA_TXERR BIT(5)
+#define MCP25XXFD_CAN_FIFOSTA_TXATIF BIT(4)
+#define MCP25XXFD_CAN_FIFOSTA_RXOVIF BIT(3)
+#define MCP25XXFD_CAN_FIFOSTA_TFERFFIF BIT(2)
+#define MCP25XXFD_CAN_FIFOSTA_TFHRFHIF BIT(1)
+#define MCP25XXFD_CAN_FIFOSTA_TFNRFNIF BIT(0)
+
+#define MCP25XXFD_CAN_FIFOUA(x) (0x58 + 0xc * (x))
+
+#define MCP25XXFD_CAN_FLTCON(x) (0x1d0 + (x))
+#define MCP25XXFD_CAN_FLTCON_FLTEN3 BIT(31)
+#define MCP25XXFD_CAN_FLTCON_F3BP_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_FLTCON_FLTEN2 BIT(23)
+#define MCP25XXFD_CAN_FLTCON_F2BP_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_FLTCON_FLTEN1 BIT(15)
+#define MCP25XXFD_CAN_FLTCON_F1BP_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_FLTCON_FLTEN0 BIT(7)
+#define MCP25XXFD_CAN_FLTCON_F0BP_MASK GENMASK(4, 0)
+
+#define MCP25XXFD_CAN_FLTOBJ(x) (0x1f0 + 8 * (x))
+#define MCP25XXFD_CAN_FLTOBJ_EXIDE BIT(30)
+#define MCP25XXFD_CAN_FLTOBJ_SID11 BIT(29)
+#define MCP25XXFD_CAN_FLTOBJ_EID_MASK GENMASK(28, 11)
+#define MCP25XXFD_CAN_FLTOBJ_SID_MASK GENMASK(10, 0)
+
+#define MCP25XXFD_CAN_FLTMASK(x) (0x1f4 + 8 * (x))
+#define MCP25XXFD_CAN_MASK_MIDE BIT(30)
+#define MCP25XXFD_CAN_MASK_MSID11 BIT(29)
+#define MCP25XXFD_CAN_MASK_MEID_MASK GENMASK(28, 11)
+#define MCP25XXFD_CAN_MASK_MSID_MASK GENMASK(10, 0)
+
+/* RAM */
+#define MCP25XXFD_RAM_SIZE 2048
+#define MCP25XXFD_RAM_START 0x400
+
+/* Message Object */
+#define MCP25XXFD_OBJ_ID_SID11 BIT(29)
+#define MCP25XXFD_OBJ_ID_EID_MASK GENMASK(28, 11)
+#define MCP25XXFD_OBJ_ID_SID_MASK GENMASK(10, 0)
+#define MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK GENMASK(31, 9)
+#define MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK GENMASK(15, 9)
+#define MCP25XXFD_OBJ_FLAGS_SEQ_MASK MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK
+#define MCP25XXFD_OBJ_FLAGS_ESI BIT(8)
+#define MCP25XXFD_OBJ_FLAGS_FDF BIT(7)
+#define MCP25XXFD_OBJ_FLAGS_BRS BIT(6)
+#define MCP25XXFD_OBJ_FLAGS_RTR BIT(5)
+#define MCP25XXFD_OBJ_FLAGS_IDE BIT(4)
+#define MCP25XXFD_OBJ_FLAGS_DLC GENMASK(3, 0)
+
+#define MCP25XXFD_CAN_FRAME_EFF_SID_MASK GENMASK(28, 18)
+#define MCP25XXFD_CAN_FRAME_EFF_EID_MASK GENMASK(17, 0)
+
+/* MCP2517/18FD SFR */
+#define MCP25XXFD_OSC 0xe00
+#define MCP25XXFD_OSC_SCLKRDY BIT(12)
+#define MCP25XXFD_OSC_OSCRDY BIT(10)
+#define MCP25XXFD_OSC_PLLRDY BIT(8)
+#define MCP25XXFD_OSC_CLKODIV_10 3
+#define MCP25XXFD_OSC_CLKODIV_4 2
+#define MCP25XXFD_OSC_CLKODIV_2 1
+#define MCP25XXFD_OSC_CLKODIV_1 0
+#define MCP25XXFD_OSC_CLKODIV_MASK GENMASK(6, 5)
+#define MCP25XXFD_OSC_SCLKDIV BIT(4)
+#define MCP25XXFD_OSC_LPMEN BIT(3)	/* MCP2518FD only */
+#define MCP25XXFD_OSC_OSCDIS BIT(2)
+#define MCP25XXFD_OSC_PLLEN BIT(0)
+
+#define MCP25XXFD_IOCON 0xe04
+#define MCP25XXFD_IOCON_INTOD BIT(30)
+#define MCP25XXFD_IOCON_SOF BIT(29)
+#define MCP25XXFD_IOCON_TXCANOD BIT(28)
+#define MCP25XXFD_IOCON_PM1 BIT(25)
+#define MCP25XXFD_IOCON_PM0 BIT(24)
+#define MCP25XXFD_IOCON_GPIO1 BIT(17)
+#define MCP25XXFD_IOCON_GPIO0 BIT(16)
+#define MCP25XXFD_IOCON_LAT1 BIT(9)
+#define MCP25XXFD_IOCON_LAT0 BIT(8)
+#define MCP25XXFD_IOCON_XSTBYEN BIT(6)
+#define MCP25XXFD_IOCON_TRIS1 BIT(1)
+#define MCP25XXFD_IOCON_TRIS0 BIT(0)
+
+#define MCP25XXFD_CRC 0xe08
+#define MCP25XXFD_CRC_FERRIE BIT(25)
+#define MCP25XXFD_CRC_CRCERRIE BIT(24)
+#define MCP25XXFD_CRC_FERRIF BIT(17)
+#define MCP25XXFD_CRC_CRCERRIF BIT(16)
+#define MCP25XXFD_CRC_IF_MASK GENMASK(17, 16)
+#define MCP25XXFD_CRC_MASK GENMASK(15, 0)
+
+#define MCP25XXFD_ECCCON 0xe0c
+#define MCP25XXFD_ECCCON_PARITY_MASK GENMASK(14, 8)
+#define MCP25XXFD_ECCCON_DEDIE BIT(2)
+#define MCP25XXFD_ECCCON_SECIE BIT(1)
+#define MCP25XXFD_ECCCON_ECCEN BIT(0)
+
+#define MCP25XXFD_ECCSTAT 0xe10
+#define MCP25XXFD_ECCSTAT_ERRADDR_MASK GENMASK(27, 16)
+#define MCP25XXFD_ECCSTAT_IF_MASK GENMASK(2, 1)
+#define MCP25XXFD_ECCSTAT_DEDIF BIT(2)
+#define MCP25XXFD_ECCSTAT_SECIF BIT(1)
+
+#define MCP25XXFD_DEVID 0xe14	/* MCP2518FD only */
+#define MCP25XXFD_DEVID_ID_MASK GENMASK(7, 4)
+#define MCP25XXFD_DEVID_REV_MASK GENMASK(3, 0)
+
+/* number of TX FIFO objects, depending on CAN mode
+ *
+ * FIFO setup: tef: 8*12 bytes = 96 bytes, tx: 8*16 bytes = 128, rx: 32*20 bytes =  640 bytes, free: 1184 bytes.
+ * FIFO setup: tef: 4*12 bytes = 48 bytes, tx: 4*72 bytes = 288, rx: 22*76 bytes = 1672 bytes, free:   40 bytes.
+ */
+#define MCP25XXFD_TX_OBJ_NUM_CAN 8
+#define MCP25XXFD_TX_OBJ_NUM_CANFD 4
+
+#if MCP25XXFD_TX_OBJ_NUM_CAN > MCP25XXFD_TX_OBJ_NUM_CANFD
+#define MCP25XXFD_TX_OBJ_NUM_MAX MCP25XXFD_TX_OBJ_NUM_CAN
+#else
+#define MCP25XXFD_TX_OBJ_NUM_MAX MCP25XXFD_TX_OBJ_NUM_CANFD
+#endif
+
+/* The actual number of RX objects is calculated in
+ * mcp25xxfd_chip_fifo_compute(), but we allocate memory
+ * beforehand.
+ */
+#define MCP25XXFD_RX_OBJ_NUM_CAN 32
+#define MCP25XXFD_RX_OBJ_NUM_CANFD 22
+
+#define MCP25XXFD_NAPI_WEIGHT 32
+#define MCP25XXFD_TX_FIFO 1
+#define MCP25XXFD_RX_FIFO(x) (MCP25XXFD_TX_FIFO + 1 + (x))
+#define MCP25XXFD_RX_FIFO_NUM (1)
+
+/* SPI commands */
+#define MCP25XXFD_INSTRUCTION_RESET 0x0000
+#define MCP25XXFD_INSTRUCTION_WRITE 0x2000
+#define MCP25XXFD_INSTRUCTION_READ 0x3000
+#define MCP25XXFD_INSTRUCTION_WRITE_CRC 0xa000
+#define MCP25XXFD_INSTRUCTION_READ_CRC 0xb000
+#define MCP25XXFD_INSTRUCTION_WRITE_SAVE 0xc000
+
+struct mcp25xxfd_dump_regs_fifo {
+	u32 con;
+	u32 sta;
+	u32 ua;
+};
+
+struct mcp25xxfd_dump_regs {
+	u32 con;
+	u32 nbtcfg;
+	u32 dbtcfg;
+	u32 tdc;
+	u32 tbc;
+	u32 tscon;
+	u32 vec;
+	u32 intf;
+	u32 rxif;
+	u32 txif;
+	u32 rxovif;
+	u32 txatif;
+	u32 txreq;
+	u32 trec;
+	u32 bdiag0;
+	u32 bdiag1;
+	union {
+		struct {
+			u32 tefcon;
+			u32 tefsta;
+			u32 tefua;
+		};
+		struct mcp25xxfd_dump_regs_fifo tef;
+	};
+	u32 reserved0;
+	union {
+		struct {
+			struct mcp25xxfd_dump_regs_fifo txq;
+			struct mcp25xxfd_dump_regs_fifo tx_fifo;
+			struct mcp25xxfd_dump_regs_fifo rx_fifo;
+		};
+		struct mcp25xxfd_dump_regs_fifo fifo[32];
+	};
+};
+
+struct mcp25xxfd_dump_ram {
+	u8 ram[MCP25XXFD_RAM_SIZE];
+};
+
+struct mcp25xxfd_dump_regs_mcp25xxfd {
+	u32 osc;
+	u32 iocon;
+	u32 crc;
+	u32 ecccon;
+	u32 eccstat;
+	u32 devid;		/* MCP2518FD only */
+};
+
+struct mcp25xxfd_dump {
+	struct mcp25xxfd_dump_regs regs;
+	struct mcp25xxfd_dump_ram ram;
+	struct mcp25xxfd_dump_regs_mcp25xxfd regs_mcp25xxfd;
+};
+
+struct mcp25xxfd_hw_tef_obj {
+	u32 id;
+	u32 flags;
+	u32 ts;
+};
+
+/* The tx_obj_raw version is used in spi async, i.e. without
+ * regmap. We have to take care of endianness ourselves.
+ */
+struct mcp25xxfd_hw_tx_obj_raw {
+	__le32 id;
+	__le32 flags;
+	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
+};
+
+struct mcp25xxfd_hw_tx_obj_can {
+	u32 id;
+	u32 flags;
+	u8 data[FIELD_SIZEOF(struct can_frame, data)];
+};
+
+struct mcp25xxfd_hw_tx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
+};
+
+struct mcp25xxfd_hw_rx_obj_can {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[FIELD_SIZEOF(struct can_frame, data)];
+};
+
+struct mcp25xxfd_hw_rx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
+};
+
+struct __packed mcp25xxfd_tx_obj_load_buf {
+	__be16 cmd;
+	struct mcp25xxfd_hw_tx_obj_raw hw_tx_obj;
+} ____cacheline_aligned;
+
+struct __packed mcp25xxfd_reg_write_buf {
+	__be16 cmd;
+	u8 data[4];
+} ____cacheline_aligned;
+
+struct mcp25xxfd_crc_buf {
+	struct __packed {
+		__be16 cmd;
+		u8 len;
+	} addr;
+	__be16 crc;
+} ____cacheline_aligned;
+
+struct mcp25xxfd_tef_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	/* u8 obj_num equals tx_ring->obj_num */
+	/* u8 obj_size equals sizeof(struct mcp25xxfd_hw_tef_obj) */
+};
+
+struct mcp25xxfd_tx_obj {
+	struct {
+		struct spi_message msg;
+		struct spi_transfer xfer;
+		struct mcp25xxfd_tx_obj_load_buf buf;
+	} load;
+
+	struct {
+		struct spi_message msg;
+		struct spi_transfer xfer;
+		struct mcp25xxfd_reg_write_buf buf;
+	} trigger;
+};
+
+struct mcp25xxfd_tx_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u8 obj_num;
+	u8 obj_size;
+
+	struct mcp25xxfd_tx_obj obj[MCP25XXFD_TX_OBJ_NUM_MAX];
+};
+
+struct mcp25xxfd_rx_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u8 obj_num;
+	u8 obj_size;
+
+	struct mcp25xxfd_hw_rx_obj_canfd obj[MCP25XXFD_RX_OBJ_NUM_CANFD];
+};
+
+struct mcp25xxfd_regs_status {
+	u32 intf;
+};
+
+enum mcp25xxfd_model {
+	CAN_MCP2517FD = 0x2517,
+	CAN_MCP2518FD = 0x2518,
+	CAN_MCP25XXFD = 0xffff,		/* autodetect model */
+};
+
+struct mcp25xxfd_priv {
+	struct can_priv can;
+	struct can_rx_offload offload;
+	struct net_device *ndev;
+
+	struct regmap *map;
+	struct regmap *map_crc;
+	struct spi_device *spi;
+
+	struct mcp25xxfd_tef_ring tef;
+	struct mcp25xxfd_tx_ring tx;
+	struct mcp25xxfd_rx_ring rx;
+
+	u32 intf;
+
+	struct mcp25xxfd_reg_write_buf update_bits_buf;
+	struct mcp25xxfd_crc_buf crc_buf;
+
+	struct gpio_desc *rx_int;
+	struct clk *clk;
+	struct regulator *reg_vdd;
+	struct regulator *reg_xceiver;
+
+	enum mcp25xxfd_model model;
+
+	struct mcp25xxfd_dump dump;
+	atomic_t cnt;
+#ifdef CONFIG_CAN_MCP25XXFD_LOG
+	struct mcp25xxfd_log log[64];
+#endif
+};
+
+static inline u8 mcp25xxfd_first_byte_set(u32 mask)
+{
+	return (mask & 0x0000ffff) ?
+		((mask & 0x000000ff) ? 0 : 1) :
+		((mask & 0x00ff0000) ? 2 : 3);
+}
+
+static inline u8 mcp25xxfd_last_byte_set(u32 mask)
+{
+	return (mask & 0xffff0000) ?
+		((mask & 0xff000000) ? 3 : 2) :
+		((mask & 0x0000ff00) ? 1 : 0);
+}
+
+static inline __be16 mcp25xxfd_cmd_reset(void)
+{
+	return cpu_to_be16(MCP25XXFD_INSTRUCTION_RESET);
+}
+
+static inline __be16 mcp25xxfd_cmd_read(u16 addr)
+{
+	return cpu_to_be16(MCP25XXFD_INSTRUCTION_READ | addr);
+}
+
+static inline __be16 mcp25xxfd_cmd_write(u16 addr)
+{
+	return cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE | addr);
+}
+
+static inline u16
+mcp25xxfd_get_tef_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return sizeof(struct mcp25xxfd_hw_tef_obj) * n;
+}
+
+static inline u16
+mcp25xxfd_get_tef_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tef_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+static inline u16
+mcp25xxfd_get_tx_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tef_obj_rel_addr(priv, priv->tx.obj_num) +
+		priv->tx.obj_size * n;
+}
+
+static inline u16
+mcp25xxfd_get_tx_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tx_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+static inline u16
+mcp25xxfd_get_rx_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tx_obj_rel_addr(priv, priv->tx.obj_num) +
+		priv->rx.obj_size * n;
+}
+
+static inline u16
+mcp25xxfd_get_rx_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_rx_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+static inline u8 mcp25xxfd_get_tef_head(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tef.head & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_tef_tail(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tef.tail & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_tef_len(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tef.head - priv->tef.tail;
+}
+
+static inline u8 mcp25xxfd_get_tef_linear_len(const struct mcp25xxfd_priv *priv)
+{
+	u8 len;
+
+	len = mcp25xxfd_get_tef_len(priv);
+
+	return min_t(u8, len, priv->tx.obj_num - mcp25xxfd_get_tef_tail(priv));
+}
+
+static inline u8 mcp25xxfd_get_tx_head(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tx.head & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_tx_tail(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tx.tail & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_rx_head(const struct mcp25xxfd_priv *priv)
+{
+	return priv->rx.head & (priv->rx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_rx_tail(const struct mcp25xxfd_priv *priv)
+{
+	return priv->rx.tail & (priv->rx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_rx_len(const struct mcp25xxfd_priv *priv)
+{
+	return priv->rx.head - priv->rx.tail;
+}
+
+static inline u8 mcp25xxfd_get_rx_linear_len(const struct mcp25xxfd_priv *priv)
+{
+	u8 len;
+
+	len = mcp25xxfd_get_rx_len(priv);
+
+	return min_t(u8, len, priv->rx.obj_num - mcp25xxfd_get_rx_tail(priv));
+}
+
+void mcp25xxfd_dump(struct mcp25xxfd_priv *priv);
+int mcp25xxfd_regmap_init(struct mcp25xxfd_priv *priv);
+u16 mcp25xxfd_crc16_compute(const void *cmd, size_t cmd_size,
+			    const void *data, size_t data_size);
+
+#endif
diff --git a/include/linux/can/rx-offload.h b/include/linux/can/rx-offload.h
index 1b78a0cfb615..f1b38088b765 100644
--- a/include/linux/can/rx-offload.h
+++ b/include/linux/can/rx-offload.h
@@ -35,6 +35,9 @@ int can_rx_offload_add_timestamp(struct net_device *dev,
 int can_rx_offload_add_fifo(struct net_device *dev,
 			    struct can_rx_offload *offload,
 			    unsigned int weight);
+int can_rx_offload_add_manual(struct net_device *dev,
+			      struct can_rx_offload *offload,
+			      unsigned int weight);
 int can_rx_offload_irq_offload_timestamp(struct can_rx_offload *offload,
 					 u64 reg);
 int can_rx_offload_irq_offload_fifo(struct can_rx_offload *offload);
-- 
2.11.0

