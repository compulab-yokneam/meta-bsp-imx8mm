From 0d96b6a59d255e16c992ed73ce2feee2b939c744 Mon Sep 17 00:00:00 2001
From: Uri Mashiach <uri.mashiach@compulab.co.il>
Date: Wed, 2 Dec 2020 17:59:16 +0200
Subject: [PATCH 42/51] can: mcp25xxfd: update drive

The driver was taken from msperl GitHub:
https://github.com/msperl/linux-rpi/tree/mcp25xxfd-V8.2/drivers/net/can/spi/mcp25xxfd

Signed-off-by: Uri Mashiach <uri.mashiach@compulab.co.il>
---
 drivers/net/can/spi/mcp25xxfd/Kconfig              |   24 +-
 drivers/net/can/spi/mcp25xxfd/Makefile             |   29 +-
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c     | 2302 --------------------
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c     |  685 ------
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c      |  105 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h      |  164 --
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c   |  268 ---
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h          |  757 -------
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c     |  286 +++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h     |   14 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c      |  687 ++++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h      |   56 +
 .../net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c  |  236 ++
 .../net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h  |   44 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c |  352 +++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h |   16 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h   |   69 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c  |  734 +++++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h  |   17 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h |  203 ++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c   |  521 +++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h   |   18 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c   |  795 +++++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h   |   86 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c    |  491 +++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h    |   28 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c      |  401 ++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h      |   86 +
 .../{mcp25xxfd-crc16.c => mcp25xxfd_crc.c}         |   64 +-
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h      |   17 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c  |  116 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h  |   30 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c      |   75 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h      |   16 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c     |  255 +++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h     |   16 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c      |   73 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h      |   15 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h     |   91 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h     |  681 ++++++
 40 files changed, 6580 insertions(+), 4343 deletions(-)
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h
 rename drivers/net/can/spi/mcp25xxfd/{mcp25xxfd-crc16.c => mcp25xxfd_crc.c} (63%)
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h

diff --git a/drivers/net/can/spi/mcp25xxfd/Kconfig b/drivers/net/can/spi/mcp25xxfd/Kconfig
index e5fbaf8e46e1..f720f1377612 100644
--- a/drivers/net/can/spi/mcp25xxfd/Kconfig
+++ b/drivers/net/can/spi/mcp25xxfd/Kconfig
@@ -1,25 +1,5 @@
-# SPDX-License-Identifier: GPL-2.0-only
-
 config CAN_MCP25XXFD
 	tristate "Microchip MCP25xxFD SPI CAN controllers"
+	depends on HAS_DMA
 	help
-	  Driver for the Microchip MCP25XXFD SPI FD-CAN controller
-	  family.
-
-config CAN_MCP25XXFD_SANITY
-	depends on CAN_MCP25XXFD
-	bool "Additional Sanity Checks"
-	help
-	  This option enables additional sanity checks in the driver,
-	  that compares various internal counters with the in chip
-	  variants. This comes with a runtime overhead.
-	  Disable if unsure.
-
-config CAN_MCP25XXFD_LOG
-	depends on CAN_MCP25XXFD
-	bool "Logging"
-	help
-	  This option enables logging of events in the driver, that
-	  help debugging. This comes with a very small runtime
-	  overhead.
-	  Disable if unsure.
+	  Driver for the Microchip MCP25XXFD SPI FD-CAN controller family.
diff --git a/drivers/net/can/spi/mcp25xxfd/Makefile b/drivers/net/can/spi/mcp25xxfd/Makefile
index 9a22a1a73954..04e6fcbb3676 100644
--- a/drivers/net/can/spi/mcp25xxfd/Makefile
+++ b/drivers/net/can/spi/mcp25xxfd/Makefile
@@ -1,11 +1,18 @@
-# SPDX-License-Identifier: GPL-2.0-only
-
-obj-$(CONFIG_CAN_MCP25XXFD) += mcp25xxfd.o
-
-mcp25xxfd-objs :=
-mcp25xxfd-objs += mcp25xxfd-core.o
-mcp25xxfd-objs += mcp25xxfd-crc16.o
-mcp25xxfd-objs += mcp25xxfd-dump.o
-mcp25xxfd-objs += mcp25xxfd-regmap.o
-
-mcp25xxfd-$(CONFIG_CAN_MCP25XXFD_LOG) += mcp25xxfd-log.o
+#
+#  Makefile for the Linux Controller Area Network SPI drivers.
+#
+obj-$(CONFIG_CAN_MCP25XXFD)	+= mcp25xxfd.o
+mcp25xxfd-objs			:= mcp25xxfd_base.o
+mcp25xxfd-objs			+= mcp25xxfd_can.o
+mcp25xxfd-objs			+= mcp25xxfd_can_debugfs.o
+mcp25xxfd-objs			+= mcp25xxfd_can_fifo.o
+mcp25xxfd-objs			+= mcp25xxfd_can_int.o
+mcp25xxfd-objs			+= mcp25xxfd_can_rx.o
+mcp25xxfd-objs			+= mcp25xxfd_can_tx.o
+mcp25xxfd-objs			+= mcp25xxfd_clock.o
+mcp25xxfd-objs			+= mcp25xxfd_cmd.o
+mcp25xxfd-objs			+= mcp25xxfd_crc.o
+mcp25xxfd-objs			+= mcp25xxfd_debugfs.o
+mcp25xxfd-objs			+= mcp25xxfd_ecc.o
+mcp25xxfd-objs			+= mcp25xxfd_gpio.o
+mcp25xxfd-objs			+= mcp25xxfd_int.o
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
deleted file mode 100644
index a74cac6a7cbf..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
+++ /dev/null
@@ -1,2302 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
-//
-// Copyright (c) 2019, 2020 Pengutronix,
-//                          Marc Kleine-Budde <kernel@pengutronix.de>
-//
-// Based on:
-//
-// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
-//
-// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
-//
-
-#include <linux/bitfield.h>
-#include <linux/clk.h>
-#include <linux/device.h>
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/ipu.h>
-
-#include <asm/unaligned.h>
-
-#include "mcp25xxfd.h"
-
-#define DEVICE_NAME "mcp25xxfd"
-
-#define MCP25XXFD_SYSCLOCK_HZ_MAX 40000000
-#define MCP25XXFD_SYSCLOCK_HZ_MIN 1000000
-#define MCP25XXFD_SPICLOCK_HZ_MAX 20000000
-#define MCP25XXFD_OSC_PLL_MULTIPLIER 10
-#define MCP25XXFD_OSC_DELAY_MS 3
-
-/* DS80000792B - MCP2517FD Errata
- *
- * Incorrect CRC for certain READ_CRC commands
- *
- * It is possible that there is a mismatch between the transmitted CRC
- * and the actual CRC for the transmitted data when data is updated at
- * a specific time during the SPI READ_CRC command. In these cases the
- * transmitted CRC is wrong. The data transmitted is correct.
- *
- * Fix/Work Around:
- *
- * If a CRC mismatch occurs, reissue the READ_CRC command. Only bits
- * 7/15/23/31 of the following registers can be affected:
- *
- * - CiTXIF		(*)
- * - CiRXIF		(*)
- * - CiCON
- * - CiTBC
- * - CiINT
- * - CiRXOVIF		(*)
- * - CiTXATIF		(*)
- * - CiTXREQ		(*)
- * - CiTREC
- * - CiBDIAG0
- * - CiBDIAG1
- * - CiTXQSTA
- * - CiFIFOSTAm
- *
- * The occurrence can be minimized by not using FIFOs 7/15/23/31. In
- * these cases, the registers CiTXIF, CiRXIF, CiRXOVIF, CiTXATIF and
- * CiTXREQ are not affected.
- *
- * Bit 31 of RAM reads with CRC could also be affected. This can be
- * avoided by reading from a received FIFO only after the message has
- * been loaded into the FIFO, indicated by the receive flags. This is
- * the recommended procedure independent of the issue described here.
- */
-
-static const struct can_bittiming_const mcp25xxfd_bittiming_const = {
-	.name = DEVICE_NAME,
-	.tseg1_min = 2,
-	.tseg1_max = 256,
-	.tseg2_min = 1,
-	.tseg2_max = 128,
-	.sjw_max = 128,
-	.brp_min = 1,
-	.brp_max = 256,
-	.brp_inc = 1,
-};
-
-static const struct can_bittiming_const mcp25xxfd_data_bittiming_const = {
-	.name = DEVICE_NAME,
-	.tseg1_min = 1,
-	.tseg1_max = 32,
-	.tseg2_min = 1,
-	.tseg2_max = 16,
-	.sjw_max = 16,
-	.brp_min = 1,
-	.brp_max = 256,
-	.brp_inc = 1,
-};
-
-static const char *mcp25xxfd_get_mode_str(const u8 mode)
-{
-	switch (mode) {
-	case MCP25XXFD_CAN_CON_MODE_MIXED:
-		return "Mixed (CAN FD/CAN 2.0)"; break;
-	case MCP25XXFD_CAN_CON_MODE_SLEEP:
-		return "Sleep"; break;
-	case MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK:
-		return "Internal Loopback"; break;
-	case MCP25XXFD_CAN_CON_MODE_LISTENONLY:
-		return "Listen Only"; break;
-	case MCP25XXFD_CAN_CON_MODE_CONFIG:
-		return "Configuration"; break;
-	case MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK:
-		return "External Loopback"; break;
-	case MCP25XXFD_CAN_CON_MODE_CAN2_0:
-		return "CAN 2.0"; break;
-	case MCP25XXFD_CAN_CON_MODE_RESTRICTED:
-		return "Restricted Operation"; break;
-	}
-
-	return "<unknown>";
-}
-
-static inline int mcp25xxfd_vdd_enable(const struct mcp25xxfd_priv *priv)
-{
-	if (!priv->reg_vdd)
-		return 0;
-
-	return regulator_enable(priv->reg_vdd);
-}
-
-static inline int mcp25xxfd_vdd_disable(const struct mcp25xxfd_priv *priv)
-{
-	if (!priv->reg_vdd)
-		return 0;
-
-	return regulator_disable(priv->reg_vdd);
-}
-
-static inline int
-mcp25xxfd_transceiver_enable(const struct mcp25xxfd_priv *priv)
-{
-	if (!priv->reg_xceiver)
-		return 0;
-
-	return regulator_enable(priv->reg_xceiver);
-}
-
-static inline int
-mcp25xxfd_transceiver_disable(const struct mcp25xxfd_priv *priv)
-{
-	if (!priv->reg_xceiver)
-		return 0;
-
-	return regulator_disable(priv->reg_xceiver);
-}
-
-static int mcp25xxfd_clks_and_vdd_enable(const struct mcp25xxfd_priv *priv)
-{
-	int err;
-
-	err = clk_prepare_enable(priv->clk);
-	if (err)
-		return err;
-
-	err = mcp25xxfd_vdd_enable(priv);
-	if (err)
-		clk_disable_unprepare(priv->clk);
-
-	return err;
-}
-
-static int mcp25xxfd_clks_and_vdd_disable(const struct mcp25xxfd_priv *priv)
-{
-	int err;
-
-	err = mcp25xxfd_vdd_disable(priv);
-	if (err)
-		return err;
-
-	clk_disable_unprepare(priv->clk);
-
-	return 0;
-}
-
-static inline int
-mcp25xxfd_cmd_prepare_write(struct mcp25xxfd_reg_write_buf *write_reg_buf,
-			    const u16 reg, const u32 mask, const u32 val)
-{
-	u8 first_byte, last_byte, len;
-	__le32 val_le32;
-
-	first_byte = mcp25xxfd_first_byte_set(mask);
-	last_byte = mcp25xxfd_last_byte_set(mask);
-	len = last_byte - first_byte + 1;
-
-	write_reg_buf->cmd = mcp25xxfd_cmd_write(reg + first_byte);
-	val_le32 = cpu_to_le32(val >> 8 * first_byte);
-	memcpy(write_reg_buf->data, &val_le32, len);
-
-	return sizeof(write_reg_buf->cmd) + len;
-}
-
-static inline int
-mcp25xxfd_tef_obj_tail_get_rel_addr_from_chip(const struct mcp25xxfd_priv *priv,
-					      u16 *tef_obj_tail_rel_addr)
-{
-	int err;
-	u32 tef_ua;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_TEFUA, &tef_ua);
-	if (err)
-		return err;
-
-	*tef_obj_tail_rel_addr = tef_ua;
-
-	return 0;
-}
-
-static inline int
-mcp25xxfd_tef_tail_get_from_chip(const struct mcp25xxfd_priv *priv,
-				 u8 *tef_tail)
-{
-	int err;
-	u16 tef_obj_tail_rel_addr;
-
-	err = mcp25xxfd_tef_obj_tail_get_rel_addr_from_chip(priv,
-							    &tef_obj_tail_rel_addr);
-	if (err)
-		return err;
-
-	*tef_tail = tef_obj_tail_rel_addr / sizeof(struct mcp25xxfd_hw_tef_obj);
-
-	return 0;
-}
-
-static inline int
-mcp25xxfd_rx_obj_tail_get_rel_addr_from_chip(const struct mcp25xxfd_priv *priv,
-					     u16 *rx_obj_tail_rel_addr)
-{
-	int err;
-	u32 fifo_ua;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_FIFOUA(MCP25XXFD_RX_FIFO(0)),
-			  &fifo_ua);
-	if (err)
-		return err;
-
-	*rx_obj_tail_rel_addr = fifo_ua;
-
-	return 0;
-}
-
-static inline int
-mcp25xxfd_rx_tail_get_from_chip(const struct mcp25xxfd_priv *priv, u8 *rx_tail)
-{
-	int err;
-	u16 rx_obj_tail_rel_addr;
-
-	err = mcp25xxfd_rx_obj_tail_get_rel_addr_from_chip(priv,
-							   &rx_obj_tail_rel_addr);
-	if (err)
-		return err;
-
-	rx_obj_tail_rel_addr -= (sizeof(struct mcp25xxfd_hw_tef_obj) +
-				 priv->tx.obj_size) * priv->tx.obj_num;
-	*rx_tail = rx_obj_tail_rel_addr / priv->rx.obj_size;
-
-	return 0;
-}
-
-static void
-mcp25xxfd_tx_ring_init_one(const struct mcp25xxfd_priv *priv,
-			   struct mcp25xxfd_tx_obj *tx_obj, const u8 n)
-{
-	u32 val;
-	u16 addr;
-	u8 len;
-
-	/* FIFO load */
-	addr = mcp25xxfd_get_tx_obj_addr(priv, n);
-	tx_obj->load.buf.cmd = mcp25xxfd_cmd_write(addr);
-	/* len is calculated on the fly */
-
-	spi_message_init_with_transfers(&tx_obj->load.msg,
-					&tx_obj->load.xfer, 1);
-	tx_obj->load.xfer.tx_buf = &tx_obj->load.buf;
-	/* len is assigned on the fly */
-
-	/* FIFO trigger */
-	addr = MCP25XXFD_CAN_FIFOCON(MCP25XXFD_TX_FIFO);
-	val = MCP25XXFD_CAN_FIFOCON_TXREQ | MCP25XXFD_CAN_FIFOCON_UINC;
-	len = mcp25xxfd_cmd_prepare_write(&tx_obj->trigger.buf, addr, val, val);
-
-	spi_message_init_with_transfers(&tx_obj->trigger.msg,
-					&tx_obj->trigger.xfer, 1);
-	tx_obj->trigger.xfer.tx_buf = &tx_obj->trigger.buf;
-	tx_obj->trigger.xfer.len = len;
-}
-
-static void mcp25xxfd_ring_init(struct mcp25xxfd_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(priv->tx.obj); i++) {
-		struct mcp25xxfd_tx_obj *tx_obj = &priv->tx.obj[i];
-
-		mcp25xxfd_tx_ring_init_one(priv, tx_obj, i);
-	}
-
-	priv->tef.head = 0;
-	priv->tef.tail = 0;
-	priv->tx.head = 0;
-	priv->tx.tail = 0;
-	priv->rx.head = 0;
-	priv->rx.tail = 0;
-}
-
-static inline int
-mcp25xxfd_chip_get_mode(const struct mcp25xxfd_priv *priv, u8 *mode)
-{
-	u32 val;
-	int err;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_CON, &val);
-	if (err)
-		return err;
-
-	*mode = FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK, val);
-
-	return 0;
-}
-
-static int
-__mcp25xxfd_chip_set_mode(const struct mcp25xxfd_priv *priv,
-			  const u8 mode_req, bool nowait)
-{
-	u32 con, con_reqop;
-	int err;
-
-	con_reqop = FIELD_PREP(MCP25XXFD_CAN_CON_REQOP_MASK, mode_req);
-	err = regmap_update_bits(priv->map, MCP25XXFD_CAN_CON,
-				 MCP25XXFD_CAN_CON_REQOP_MASK, con_reqop);
-	if (err)
-		return err;
-
-	if (mode_req == MCP25XXFD_CAN_CON_MODE_SLEEP || nowait)
-		return 0;
-
-	err = regmap_read_poll_timeout(priv->map, MCP25XXFD_CAN_CON, con,
-				       FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK,
-						 con) == mode_req,
-				       10000, 1000000);
-	if (err) {
-		u8 mode = FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK, con);
-
-		netdev_err(priv->ndev,
-			   "Controller failed to enter mode %s Mode (%u) and stays in %s Mode (%u).\n",
-			   mcp25xxfd_get_mode_str(mode_req), mode_req,
-			   mcp25xxfd_get_mode_str(mode), mode);
-		return err;
-	}
-
-	return 0;
-}
-
-static inline int
-mcp25xxfd_chip_set_mode(const struct mcp25xxfd_priv *priv,
-			const u8 mode_req)
-{
-	return __mcp25xxfd_chip_set_mode(priv, mode_req, false);
-}
-
-static inline int
-mcp25xxfd_chip_set_mode_nowait(const struct mcp25xxfd_priv *priv,
-			       const u8 mode_req)
-{
-	return __mcp25xxfd_chip_set_mode(priv, mode_req, true);
-}
-
-static int mcp25xxfd_chip_clock_enable(const struct mcp25xxfd_priv *priv)
-{
-	u32 osc, osc_reference, osc_mask;
-	int err;
-
-	/* Set Power On Defaults for "Clock Output Divisor" and remove
-	 * "Oscillator Disable" bit.
-	 */
-	osc = FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK, MCP25XXFD_OSC_CLKODIV_10);
-	osc_reference = MCP25XXFD_OSC_OSCRDY;
-	osc_mask = MCP25XXFD_OSC_OSCRDY | MCP25XXFD_OSC_PLLRDY;
-
-	/* Note:
-	 *
-	 * If the controller is in Sleep Mode the following write only
-	 * removes the "Oscillator Disable" bit and powers it up. All
-	 * other bits are unaffected.
-	 */
-	err = regmap_write(priv->map, MCP25XXFD_OSC, osc);
-	if (err)
-		return err;
-
-	/* Wait for "Oscillator Ready" bit */
-	return regmap_read_poll_timeout(priv->map, MCP25XXFD_OSC, osc,
-					(osc & osc_mask) == osc_reference,
-					10000, 1000000);
-}
-
-static int mcp25xxfd_chip_clock_init(const struct mcp25xxfd_priv *priv)
-{
-	u32 osc;
-	int err;
-
-	/* Activate Low Power Mode on Oscillator Disable. This only
-	 * works on the MCP2518FD. The MCP2517FD will go into normal
-	 * Sleep Mode instead.
-	 */
-	osc = MCP25XXFD_OSC_LPMEN |
-		FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK,
-			   MCP25XXFD_OSC_CLKODIV_10);
-	err = regmap_write(priv->map, MCP25XXFD_OSC, osc);
-	if (err)
-		return err;
-
-	/* Set Time Base Counter Prescaler to 1.
-	 *
-	 * This means an overflow of the 32 bit Time Base Counter
-	 * register at 40 MHz every 107 seconds.
-	 */
-	return regmap_write(priv->map, MCP25XXFD_CAN_TSCON,
-			    MCP25XXFD_CAN_TSCON_TBCEN);
-}
-
-static int mcp25xxfd_chip_softreset(const struct mcp25xxfd_priv *priv)
-{
-	const __be16 cmd = mcp25xxfd_cmd_reset();
-	u8 mode;
-	int err;
-
-	/* The Set Mode and SPI Reset command only seems to works if
-	 * the controller is not in Sleep Mode.
-	 */
-	err = mcp25xxfd_chip_clock_enable(priv);
-	if (err)
-		return err;
-
-	err = mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_CONFIG);
-	if (err)
-		return err;
-
-	/* spi_write_then_read() works with non DMA-safe buffers */
-	err = spi_write_then_read(priv->spi, &cmd, sizeof(cmd), NULL, 0);
-	if (err)
-		return err;
-
-	err = mcp25xxfd_chip_get_mode(priv, &mode);
-	if (err)
-		return err;
-
-	if (mode != MCP25XXFD_CAN_CON_MODE_CONFIG) {
-		netdev_err(priv->ndev,
-			   "Controller not in Config Mode after reset, but in %s Mode (%u).\n",
-			   mcp25xxfd_get_mode_str(mode), mode);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_set_bittiming(const struct mcp25xxfd_priv *priv)
-{
-	const struct can_bittiming *bt = &priv->can.bittiming;
-	const struct can_bittiming *dbt = &priv->can.data_bittiming;
-	u32 val = 0;
-	s8 tdco;
-	int err;
-
-	/* CAN Control Register
-	 *
-	 * - no transmit bandwidth sharing
-	 * - config mode
-	 * - disable transmit queue
-	 * - store in transmit FIFO event
-	 * - transition to restricted operation mode on system error
-	 * - ESI is transmitted recessive when ESI of message is high or
-	 *   CAN controller error passive
-	 * - restricted retransmission attempts,
-	 *   use TQXCON_TXAT and FIFOCON_TXAT
-	 * - wake-up filter bits T11FILTER
-	 * - use CAN bus line filter for wakeup
-	 * - protocol exception is treated as a form error
-	 * - Do not compare data bytes
-	 */
-	val = FIELD_PREP(MCP25XXFD_CAN_CON_REQOP_MASK,
-			 MCP25XXFD_CAN_CON_MODE_CONFIG) |
-		MCP25XXFD_CAN_CON_STEF |
-		MCP25XXFD_CAN_CON_ESIGM |
-		MCP25XXFD_CAN_CON_RTXAT |
-		FIELD_PREP(MCP25XXFD_CAN_CON_WFT_MASK,
-			   MCP25XXFD_CAN_CON_WFT_T11FILTER) |
-		MCP25XXFD_CAN_CON_WAKFIL |
-		MCP25XXFD_CAN_CON_PXEDIS;
-
-	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
-		val |= MCP25XXFD_CAN_CON_ISOCRCEN;
-
-	err = regmap_write(priv->map, MCP25XXFD_CAN_CON, val);
-	if (err)
-		return err;
-
-	/* Nominal Bit Time */
-	val = FIELD_PREP(MCP25XXFD_CAN_NBTCFG_BRP_MASK, bt->brp - 1) |
-		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_TSEG1_MASK,
-			   bt->prop_seg + bt->phase_seg1 - 1) |
-		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_TSEG2_MASK,
-			   bt->phase_seg2 - 1) |
-		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_SJW_MASK, bt->sjw - 1);
-
-	err = regmap_write(priv->map, MCP25XXFD_CAN_NBTCFG, val);
-	if (err)
-		return err;
-
-	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))
-		return 0;
-
-	/* Data Bit Time */
-	val = FIELD_PREP(MCP25XXFD_CAN_DBTCFG_BRP_MASK, dbt->brp - 1) |
-		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_TSEG1_MASK,
-			   dbt->prop_seg + dbt->phase_seg1 - 1) |
-		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_TSEG2_MASK,
-			   dbt->phase_seg2 - 1) |
-		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_SJW_MASK, dbt->sjw - 1);
-
-	err = regmap_write(priv->map, MCP25XXFD_CAN_DBTCFG, val);
-	if (err)
-		return err;
-
-	/* Transmitter Delay Compensation */
-	tdco = clamp_t(int, dbt->brp * (dbt->prop_seg + dbt->phase_seg1),
-		       -64, 63);
-	val = FIELD_PREP(MCP25XXFD_CAN_TDC_TDCMOD_MASK,
-			 MCP25XXFD_CAN_TDC_TDCMOD_AUTO) |
-		FIELD_PREP(MCP25XXFD_CAN_TDC_TDCO_MASK, tdco);
-
-	return regmap_write(priv->map, MCP25XXFD_CAN_TDC, val);
-}
-
-static int mcp25xxfd_chip_pinctrl_init(const struct mcp25xxfd_priv *priv)
-{
-	u32 val;
-
-	if (!priv->rx_int)
-		return 0;
-
-	/* Configure GPIOs:
-	 * - PIN0: GPIO Input
-	 * - PIN1: RX Interrupt
-	 */
-	val = MCP25XXFD_IOCON_PM0 | MCP25XXFD_IOCON_TRIS0;
-	return regmap_write(priv->map, MCP25XXFD_IOCON, val);
-}
-
-static int mcp25xxfd_chip_fifo_compute(struct mcp25xxfd_priv *priv)
-{
-	int tef_obj_size, tx_obj_size, rx_obj_size;
-	int tx_obj_num, rx_obj_num;
-	int ram_free;
-
-	tef_obj_size = sizeof(struct mcp25xxfd_hw_tef_obj);
-	if (priv->can.ctrlmode & CAN_CTRLMODE_FD) {
-		tx_obj_num = MCP25XXFD_TX_OBJ_NUM_CANFD;
-		tx_obj_size = sizeof(struct mcp25xxfd_hw_tx_obj_canfd);
-		rx_obj_size = sizeof(struct mcp25xxfd_hw_rx_obj_canfd);
-	} else {
-		tx_obj_num = MCP25XXFD_TX_OBJ_NUM_CAN;
-		tx_obj_size = sizeof(struct mcp25xxfd_hw_tx_obj_can);
-		rx_obj_size = sizeof(struct mcp25xxfd_hw_rx_obj_can);
-	}
-
-	ram_free = MCP25XXFD_RAM_SIZE - tx_obj_num *
-		(tef_obj_size + tx_obj_size);
-	rx_obj_num = min(ram_free / rx_obj_size, 32);
-	ram_free -= rx_obj_num * rx_obj_size;
-
-	if ((priv->can.ctrlmode & CAN_CTRLMODE_FD &&
-	     rx_obj_num > MCP25XXFD_RX_OBJ_NUM_CANFD) ||
-	    (!(priv->can.ctrlmode & CAN_CTRLMODE_FD) &&
-	     rx_obj_num > MCP25XXFD_RX_OBJ_NUM_CAN)) {
-		netdev_err(priv->ndev,
-			   "Too many rx-objects (calculated=%d, max=%d).\n",
-			   rx_obj_num, priv->can.ctrlmode & CAN_CTRLMODE_FD ?
-			   MCP25XXFD_RX_OBJ_NUM_CANFD :
-			   MCP25XXFD_RX_OBJ_NUM_CAN);
-		return -ENOMEM;
-	}
-
-	priv->tx.obj_num = tx_obj_num;
-	priv->tx.obj_size = tx_obj_size;
-	priv->rx.obj_num = rx_obj_num;
-	priv->rx.obj_size = rx_obj_size;
-
-	netdev_dbg(priv->ndev,
-		   "FIFO setup: tef: %d*%d bytes = %d bytes, tx: %d*%d bytes = %d, rx: %d*%d bytes = %d bytes, free: %d bytes.\n",
-		   tx_obj_num, tef_obj_size, tef_obj_size * tx_obj_num,
-		   tx_obj_num, tx_obj_size, tx_obj_size * tx_obj_num,
-		   rx_obj_num, rx_obj_size, rx_obj_size * rx_obj_num,
-		   ram_free);
-
-	return 0;
-}
-
-static int mcp25xxfd_chip_fifo_init(struct mcp25xxfd_priv *priv)
-{
-	u32 val;
-	int err;
-
-	err = mcp25xxfd_chip_fifo_compute(priv);
-	if (err)
-		return err;
-
-	mcp25xxfd_ring_init(priv);
-
-	/* TEF */
-	val = FIELD_PREP(MCP25XXFD_CAN_TEFCON_FSIZE_MASK,
-			 priv->tx.obj_num - 1) |
-		MCP25XXFD_CAN_TEFCON_TEFTSEN |
-		MCP25XXFD_CAN_TEFCON_TEFOVIE |
-		MCP25XXFD_CAN_TEFCON_TEFNEIE;
-
-	err = regmap_write(priv->map, MCP25XXFD_CAN_TEFCON, val);
-	if (err)
-		return err;
-
-	/* FIFO 1 - TX */
-	val = FIELD_PREP(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK,
-			 priv->tx.obj_num - 1) |
-		MCP25XXFD_CAN_FIFOCON_TXEN |
-		MCP25XXFD_CAN_FIFOCON_TXATIE;
-
-	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
-		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
-				  MCP25XXFD_CAN_FIFOCON_PLSIZE_64);
-	else
-		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
-				  MCP25XXFD_CAN_FIFOCON_PLSIZE_8);
-
-	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
-		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_TXAT_MASK,
-				  MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT);
-	else
-		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_TXAT_MASK,
-				  MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED);
-
-	err = regmap_write(priv->map, MCP25XXFD_CAN_FIFOCON(MCP25XXFD_TX_FIFO),
-			   val);
-	if (err)
-		return err;
-
-	/* FIFO 2 - RX */
-	val = FIELD_PREP(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK,
-			 priv->rx.obj_num - 1) |
-		MCP25XXFD_CAN_FIFOCON_RXTSEN |
-		MCP25XXFD_CAN_FIFOCON_RXOVIE |
-		MCP25XXFD_CAN_FIFOCON_TFNRFNIE;
-
-	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
-		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
-				  MCP25XXFD_CAN_FIFOCON_PLSIZE_64);
-	else
-		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
-				  MCP25XXFD_CAN_FIFOCON_PLSIZE_8);
-
-	err = regmap_write(priv->map,
-			   MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)), val);
-	if (err)
-		return err;
-
-	/* RX Filter */
-	val = MCP25XXFD_CAN_FLTCON_FLTEN0 |
-		FIELD_PREP(MCP25XXFD_CAN_FLTCON_F0BP_MASK,
-			   MCP25XXFD_RX_FIFO(0));
-	return regmap_write(priv->map, MCP25XXFD_CAN_FLTCON(0), val);
-}
-
-static int mcp25xxfd_chip_ecc_init(const struct mcp25xxfd_priv *priv)
-{
-	void *ram;
-	int err;
-
-	ram = kzalloc(MCP25XXFD_RAM_SIZE, GFP_KERNEL);
-	if (!ram)
-		return -ENOMEM;
-
-	err = regmap_raw_write(priv->map, MCP25XXFD_RAM_START, ram,
-			       MCP25XXFD_RAM_SIZE);
-	kfree(ram);
-
-	return err;
-}
-
-static u8 mcp25xxfd_get_normal_mode(const struct mcp25xxfd_priv *priv)
-{
-	u8 mode;
-
-	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
-		mode = MCP25XXFD_CAN_CON_MODE_MIXED;
-	else
-		mode = MCP25XXFD_CAN_CON_MODE_CAN2_0;
-
-	return mode;
-}
-
-static int
-__mcp25xxfd_chip_set_normal_mode(const struct mcp25xxfd_priv *priv,
-				 bool nowait)
-{
-	u8 mode;
-
-	mode = mcp25xxfd_get_normal_mode(priv);
-
-	return __mcp25xxfd_chip_set_mode(priv, mode, nowait);
-}
-
-static inline int
-mcp25xxfd_chip_set_normal_mode(const struct mcp25xxfd_priv *priv)
-{
-	return __mcp25xxfd_chip_set_normal_mode(priv, false);
-}
-
-static inline int
-mcp25xxfd_chip_set_normal_mode_nowait(const struct mcp25xxfd_priv *priv)
-{
-	return __mcp25xxfd_chip_set_normal_mode(priv, true);
-}
-
-static int mcp25xxfd_chip_interrupts_enable(const struct mcp25xxfd_priv *priv)
-{
-	u32 val;
-	int err;
-
-	val = MCP25XXFD_CAN_INT_CERRIE |
-		MCP25XXFD_CAN_INT_SERRIE |
-		MCP25XXFD_CAN_INT_RXOVIE |
-		MCP25XXFD_CAN_INT_TXATIE |
-		MCP25XXFD_CAN_INT_SPICRCIE |
-		MCP25XXFD_CAN_INT_ECCIE |
-		MCP25XXFD_CAN_INT_TEFIE |
-		MCP25XXFD_CAN_INT_MODIE |
-		MCP25XXFD_CAN_INT_RXIE;
-
-	if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
-		val |= MCP25XXFD_CAN_INT_IVMIE;
-
-	err = regmap_write(priv->map, MCP25XXFD_CAN_INT, val);
-	if (err)
-		return err;
-
-	val = MCP25XXFD_CRC_FERRIE |
-		MCP25XXFD_CRC_CRCERRIE;
-	err = regmap_write(priv->map, MCP25XXFD_CRC, val);
-	if (err)
-		return err;
-
-	val = MCP25XXFD_ECCCON_DEDIE |
-		MCP25XXFD_ECCCON_SECIE |
-		MCP25XXFD_ECCCON_ECCEN;
-	return regmap_write(priv->map, MCP25XXFD_ECCCON, val);
-}
-
-static int mcp25xxfd_chip_interrupts_disable(const struct mcp25xxfd_priv *priv)
-{
-	int err;
-
-	err = regmap_write(priv->map, MCP25XXFD_ECCCON, 0);
-	if (err)
-		return err;
-
-	err = regmap_write(priv->map, MCP25XXFD_CRC, 0);
-	if (err)
-		return err;
-
-	return regmap_write(priv->map, MCP25XXFD_CAN_INT, 0);
-}
-
-static int mcp25xxfd_chip_start(struct mcp25xxfd_priv *priv)
-{
-	int err;
-
-	err = mcp25xxfd_chip_softreset(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_chip_clock_init(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_set_bittiming(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_chip_pinctrl_init(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_chip_fifo_init(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_chip_ecc_init(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	/* Note:
-	 *
-	 * First enable the interrupts, then bring the chip into
-	 * Normal Mode. Otherwise on a MCP2517FD a burst of CAN
-	 * messages on the bus may result in overwritten RX FIFO
-	 * contents and ECC errors.
-	 *
-	 * The current theory is that the SPI read access disturbes
-	 * the RX process in the chip.
-	 */
-	priv->can.state = CAN_STATE_ERROR_ACTIVE;
-
-	err = mcp25xxfd_chip_interrupts_enable(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_chip_set_normal_mode(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	return 0;
-
- out_chip_set_mode_sleep:
-	mcp25xxfd_chip_interrupts_disable(priv);
-	mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
-	priv->can.state = CAN_STATE_STOPPED;
-
-	return err;
-}
-
-static int mcp25xxfd_chip_stop(struct mcp25xxfd_priv *priv,
-			       const enum can_state state)
-{
-	priv->can.state = state;
-
-	mcp25xxfd_chip_interrupts_disable(priv);
-	return mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
-}
-
-static int mcp25xxfd_set_mode(struct net_device *ndev, enum can_mode mode)
-{
-	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
-	int err;
-
-	switch (mode) {
-	case CAN_MODE_START:
-		err = mcp25xxfd_chip_start(priv);
-		if (err)
-			return err;
-
-		netif_wake_queue(ndev);
-		break;
-
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_get_berr_counter(const struct net_device *ndev,
-				      struct can_berr_counter *bec)
-{
-	const struct mcp25xxfd_priv *priv = netdev_priv(ndev);
-	u32 trec;
-	int err;
-
-	/* Avoid waking up the controller when the interface is down. */
-	if (!(ndev->flags & IFF_UP))
-		return 0;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_TREC, &trec);
-	if (err)
-		return err;
-
-	bec->txerr = FIELD_GET(MCP25XXFD_CAN_TREC_TEC_MASK, trec);
-	bec->rxerr = FIELD_GET(MCP25XXFD_CAN_TREC_REC_MASK, trec);
-
-	return 0;
-}
-
-static int mcp25xxfd_check_tef_tail(struct mcp25xxfd_priv *priv)
-{
-	u8 tef_tail_chip, tef_tail;
-	int err;
-
-	if (!IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY))
-		return 0;
-
-	err = mcp25xxfd_tef_tail_get_from_chip(priv, &tef_tail_chip);
-	if (err)
-		return err;
-
-	mcp25xxfd_log_hw_tef_tail(priv, tef_tail_chip);
-
-	tef_tail = mcp25xxfd_get_tef_tail(priv);
-	if (tef_tail_chip != tef_tail) {
-		netdev_err(priv->ndev,
-			   "TEF tail of chip (0x%02x) and ours (0x%08x) inconsistent.\n",
-			   tef_tail_chip, tef_tail);
-		return -EILSEQ;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_check_rx_tail(const struct mcp25xxfd_priv *priv)
-{
-	u8 rx_tail_chip, rx_tail;
-	int err;
-
-	if (!IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY))
-		return 0;
-
-	err = mcp25xxfd_rx_tail_get_from_chip(priv, &rx_tail_chip);
-	if (err)
-		return err;
-
-	rx_tail = mcp25xxfd_get_rx_tail(priv);
-	if (rx_tail_chip != rx_tail) {
-		netdev_err(priv->ndev,
-			   "RX tail of chip (%d) and ours (%d) inconsistent.\n",
-			   rx_tail_chip, rx_tail);
-		return -EILSEQ;
-	}
-
-	return 0;
-}
-
-static int
-mcp25xxfd_handle_tefif_recover(const struct mcp25xxfd_priv *priv, const u32 seq)
-{
-	u32 tef_sta;
-	int err;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_TEFSTA, &tef_sta);
-	if (err)
-		return err;
-
-	if (tef_sta & MCP25XXFD_CAN_TEFSTA_TEFOVIF) {
-		netdev_err(priv->ndev,
-			   "Transmit Event FIFO buffer overflow.\n");
-		return -ENOBUFS;
-	}
-
-	netdev_info(priv->ndev,
-		   "Transmit Event FIFO buffer %s (seq=0x%08x, tef_tail=0x%08x, tef_head=0x%08x, tx_head=0x%08x)\n",
-		   tef_sta & MCP25XXFD_CAN_TEFSTA_TEFNEIF ?
-		   "empty." : "not empty anymore?",
-		   seq, priv->tef.tail, priv->tef.head, priv->tx.head);
-
-	return -EAGAIN;
-}
-
-static int
-mcp25xxfd_handle_tefif_one(struct mcp25xxfd_priv *priv,
-			   const struct mcp25xxfd_hw_tef_obj *hw_tef_obj)
-{
-	struct net_device_stats *stats = &priv->ndev->stats;
-	u32 seq, seq_masked, tef_tail_masked;
-	int err;
-
-	seq = FIELD_GET(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
-			hw_tef_obj->flags);
-
-	/* Use the MCP2517FD mask on the MCP2518FD, too. We only
-	 * compare 7 bits, this should be enough to detect
-	 * net-yet-completed, i.e. old TEF objects.
-	 */
-	seq_masked = seq &
-		field_mask(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
-	tef_tail_masked = priv->tef.tail &
-		field_mask(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
-	if (seq_masked != tef_tail_masked)
-		return mcp25xxfd_handle_tefif_recover(priv, seq);
-
-	mcp25xxfd_log(priv, hw_tef_obj->id);
-
-	stats->tx_bytes +=
-		can_rx_offload_get_echo_skb(&priv->offload,
-					    mcp25xxfd_get_tef_tail(priv),
-					    hw_tef_obj->ts);
-	stats->tx_packets++;
-
-	/* finally increment the TEF pointer */
-	err = regmap_update_bits(priv->map, MCP25XXFD_CAN_TEFCON,
-				 GENMASK(15, 8),
-				 MCP25XXFD_CAN_TEFCON_UINC);
-	if (err)
-		return err;
-
-	priv->tx.tail++;
-	priv->tef.tail++;
-
-	return mcp25xxfd_check_tef_tail(priv);
-}
-
-static int mcp25xxfd_tef_ring_update(struct mcp25xxfd_priv *priv)
-{
-	u32 fifo_sta, new_head;
-	u8 tx_ci;
-	int err;
-
-	/* guess head */
-	err = regmap_read(priv->map, MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_TX_FIFO),
-			  &fifo_sta);
-	if (err)
-		return err;
-
-	tx_ci = FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, fifo_sta);
-	new_head = round_down(priv->tef.head, priv->tx.obj_num) + tx_ci;
-
-	if (new_head <= priv->tef.head)
-		new_head += priv->tx.obj_num;
-
-	priv->tef.head = min(new_head, priv->tx.head);
-
-	mcp25xxfd_log_hw_tx_ci(priv, tx_ci);
-
-	return mcp25xxfd_check_tef_tail(priv);
-}
-
-static inline int
-mcp25xxfd_tef_obj_read(const struct mcp25xxfd_priv *priv,
-		       struct mcp25xxfd_hw_tef_obj *hw_tef_obj,
-		       const u8 offset, const u8 len)
-{
-	if (IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY) &&
-	    (offset > priv->tx.obj_num ||
-	     len > priv->tx.obj_num ||
-	     offset + len > priv->tx.obj_num)) {
-		netdev_err(priv->ndev,
-			   "Trying to read to many TEF objects (max=%d, offset=%d, len=%d).\n",
-			   priv->tx.obj_num, offset, len);
-		return -ERANGE;
-	}
-
-	return regmap_bulk_read(priv->map,
-				mcp25xxfd_get_tef_obj_addr(priv, offset),
-				hw_tef_obj,
-				sizeof(*hw_tef_obj) / sizeof(u32) * len);
-}
-
-static int mcp25xxfd_handle_tefif(struct mcp25xxfd_priv *priv)
-{
-	struct mcp25xxfd_hw_tef_obj hw_tef_obj[MCP25XXFD_TX_OBJ_NUM_MAX];
-	u8 tef_tail, len, l;
-	int err, i;
-
-	err = mcp25xxfd_tef_ring_update(priv);
-	if (err)
-		return err;
-
-	tef_tail = mcp25xxfd_get_tef_tail(priv);
-	len = mcp25xxfd_get_tef_len(priv);
-	l = mcp25xxfd_get_tef_linear_len(priv);
-	err = mcp25xxfd_tef_obj_read(priv, hw_tef_obj, tef_tail, l);
-	if (err)
-		return err;
-
-	if (l < len) {
-		err = mcp25xxfd_tef_obj_read(priv, &hw_tef_obj[l], 0, len - l);
-		if (err)
-			return err;
-	}
-
-	for (i = 0; i < len; i++) {
-		err = mcp25xxfd_handle_tefif_one(priv, &hw_tef_obj[i]);
-		/* -EAGAIN means the Sequence Number in the TEF
-		 * doesn't match our tef_tail. This can happen if we
-		 * read the TEF objects too early. Leave loop let the
-		 * interrupt handler call us again.
-		 */
-		if (err == -EAGAIN)
-			goto out_netif_wake_queue;
-		if (err)
-			return err;
-	}
-
- out_netif_wake_queue:
-	mcp25xxfd_log_wake(priv, hw_tef_obj->id);
-	netif_wake_queue(priv->ndev);
-
-	return 0;
-}
-
-static int mcp25xxfd_rx_ring_update(struct mcp25xxfd_priv *priv)
-{
-	u32 fifo_sta, new_head;
-	u8 rx_ci;
-	int err;
-
-	err = regmap_read(priv->map,
-			  MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_RX_FIFO(0)),
-			  &fifo_sta);
-	if (err)
-		return err;
-
-	rx_ci = FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, fifo_sta);
-	new_head = round_down(priv->rx.head, priv->rx.obj_num) + rx_ci;
-
-	if (new_head <= priv->rx.head)
-		new_head += priv->rx.obj_num;
-
-	priv->rx.head = new_head;
-
-	return mcp25xxfd_check_rx_tail(priv);
-}
-
-static void
-mcp25xxfd_hw_rx_obj_to_skb(const struct mcp25xxfd_priv *priv,
-			   const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj,
-			   struct sk_buff *skb)
-{
-	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
-
-	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_IDE) {
-		u32 sid, eid;
-
-		eid = FIELD_GET(MCP25XXFD_OBJ_ID_EID_MASK, hw_rx_obj->id);
-		sid = FIELD_GET(MCP25XXFD_OBJ_ID_SID_MASK, hw_rx_obj->id);
-
-		cfd->can_id = CAN_EFF_FLAG |
-			FIELD_PREP(MCP25XXFD_CAN_FRAME_EFF_EID_MASK, eid) |
-			FIELD_PREP(MCP25XXFD_CAN_FRAME_EFF_SID_MASK, sid);
-	} else {
-		cfd->can_id = FIELD_GET(MCP25XXFD_OBJ_ID_SID_MASK,
-					hw_rx_obj->id);
-	}
-
-	/* CANFD */
-	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_FDF) {
-		u8 dlc;
-
-		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_ESI)
-			cfd->flags |= CANFD_ESI;
-
-		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_BRS)
-			cfd->flags |= CANFD_BRS;
-
-		dlc = FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_rx_obj->flags);
-		cfd->len = can_dlc2len(get_canfd_dlc(dlc));
-	} else {
-		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_RTR)
-			cfd->can_id |= CAN_RTR_FLAG;
-
-		cfd->len = get_can_dlc(FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC,
-						 hw_rx_obj->flags));
-	}
-
-	memcpy(cfd->data, hw_rx_obj->data, cfd->len);
-}
-
-static int
-mcp25xxfd_handle_rxif_one(struct mcp25xxfd_priv *priv,
-			  const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj)
-{
-	struct net_device_stats *stats = &priv->ndev->stats;
-	struct sk_buff *skb;
-	struct canfd_frame *cfd;
-	int err;
-
-	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_FDF)
-		skb = alloc_canfd_skb(priv->ndev, &cfd);
-	else
-		skb = alloc_can_skb(priv->ndev, (struct can_frame **)&cfd);
-
-	if (!cfd) {
-		stats->rx_dropped++;
-		return 0;
-	}
-
-	mcp25xxfd_hw_rx_obj_to_skb(priv, hw_rx_obj, skb);
-	err = can_rx_offload_queue_sorted(&priv->offload, skb, hw_rx_obj->ts);
-	if (err)
-		stats->rx_fifo_errors++;
-
-	priv->rx.tail++;
-
-	/* finally increment the RX pointer */
-	return regmap_update_bits(priv->map,
-				  MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)),
-				  GENMASK(15, 8),
-				  MCP25XXFD_CAN_FIFOCON_UINC);
-}
-
-static inline int
-mcp25xxfd_rx_obj_read(const struct mcp25xxfd_priv *priv,
-		      struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj,
-		      const u8 offset, const u8 len)
-{
-	return regmap_bulk_read(priv->map,
-				mcp25xxfd_get_rx_obj_addr(priv, offset),
-				hw_rx_obj,
-				len * priv->rx.obj_size / sizeof(u32));
-}
-
-static int mcp25xxfd_handle_rxif(struct mcp25xxfd_priv *priv)
-{
-	struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj = priv->rx.obj;
-	u8 rx_tail, len, l;
-	int err, i;
-
-	err = mcp25xxfd_rx_ring_update(priv);
-	if (err)
-		return err;
-
-	rx_tail = mcp25xxfd_get_rx_tail(priv);
-	len = mcp25xxfd_get_rx_len(priv);
-	l = mcp25xxfd_get_rx_linear_len(priv);
-	err = mcp25xxfd_rx_obj_read(priv, hw_rx_obj, rx_tail, l);
-	if (err)
-		return err;
-
-	if (l < len) {
-		err = mcp25xxfd_rx_obj_read(priv, (void *)hw_rx_obj +
-					    l * priv->rx.obj_size, 0, len - l);
-		if (err)
-			return err;
-	}
-
-	for (i = 0; i < len; i++) {
-		err = mcp25xxfd_handle_rxif_one(priv, (void *)hw_rx_obj +
-						i * priv->rx.obj_size);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-static inline int mcp25xxfd_get_timestamp(const struct mcp25xxfd_priv *priv,
-					  u32 *timestamp)
-{
-	return regmap_read(priv->map, MCP25XXFD_CAN_TBC, timestamp);
-}
-
-static struct sk_buff *
-mcp25xxfd_alloc_can_err_skb(const struct mcp25xxfd_priv *priv,
-			    struct can_frame **cf, u32 *timestamp)
-{
-	int err;
-
-	err = mcp25xxfd_get_timestamp(priv, timestamp);
-	if (err)
-		return NULL;
-
-	return alloc_can_err_skb(priv->ndev, cf);
-}
-
-static int mcp25xxfd_handle_rxovif(struct mcp25xxfd_priv *priv)
-{
-	struct net_device_stats *stats = &priv->ndev->stats;
-	struct sk_buff *skb;
-	struct can_frame *cf;
-	u32 timestamp, rxovif;
-	int err, i;
-
-	stats->rx_over_errors++;
-	stats->rx_errors++;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_RXOVIF, &rxovif);
-	if (err)
-		return err;
-
-	for (i = 0; i < MCP25XXFD_RX_FIFO_NUM; i++) {
-		const u8 rx_fifo = MCP25XXFD_RX_FIFO(i);
-
-		if (rxovif & BIT(rx_fifo)) {
-			netdev_warn(priv->ndev,
-				   "RX-FIFO overflow in FIFO %d.\n", rx_fifo);
-
-			err = regmap_update_bits(priv->map,
-						 MCP25XXFD_CAN_FIFOSTA(rx_fifo),
-						 MCP25XXFD_CAN_FIFOSTA_RXOVIF,
-						 0x0);
-			if (err)
-				return err;
-		}
-	}
-
-	skb = mcp25xxfd_alloc_can_err_skb(priv, &cf, &timestamp);
-	if (!skb)
-		return 0;
-
-	cf->can_id |= CAN_ERR_CRTL;
-	cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
-
-	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
-	if (err)
-		stats->rx_fifo_errors++;
-
-	return 0;
-}
-
-static int mcp25xxfd_handle_txatif(struct mcp25xxfd_priv *priv)
-{
-	netdev_info(priv->ndev, "%s\n", __func__);
-
-	return 0;
-}
-
-static int mcp25xxfd_handle_ivmif(struct mcp25xxfd_priv *priv)
-{
-	struct net_device_stats *stats = &priv->ndev->stats;
-	u32 bdiag1, timestamp;
-	struct sk_buff *skb;
-	struct can_frame *cf = NULL;
-	int err;
-
-	err = mcp25xxfd_get_timestamp(priv, &timestamp);
-	if (err)
-		return err;
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_BDIAG1, &bdiag1);
-	if (err)
-		return err;
-
-	/* Write 0s to clear error bits, don't write 1s to non active
-	 * bits, as they will be set.
-	 */
-	err = regmap_write(priv->map, MCP25XXFD_CAN_BDIAG1, 0x0);
-	if (err)
-		return err;
-
-	priv->can.can_stats.bus_error++;
-
-	skb = alloc_can_err_skb(priv->ndev, &cf);
-	if (cf)
-		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
-
-	/* Controller misconfiguration */
-	if (WARN_ON(bdiag1 & MCP25XXFD_CAN_BDIAG1_DLCMM))
-		netdev_err(priv->ndev,
-			   "recv'd DLC is larger than PLSIZE of FIFO element.");
-
-	/* RX errors */
-	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DCRCERR |
-		      MCP25XXFD_CAN_BDIAG1_NCRCERR)) {
-		stats->rx_errors++;
-		if (cf)
-			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
-	}
-	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DSTUFERR |
-		      MCP25XXFD_CAN_BDIAG1_NSTUFERR)) {
-		stats->rx_errors++;
-		if (cf)
-			cf->data[2] |= CAN_ERR_PROT_STUFF;
-	}
-	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DFORMERR |
-		      MCP25XXFD_CAN_BDIAG1_NFORMERR)) {
-		stats->rx_errors++;
-		if (cf)
-			cf->data[2] |= CAN_ERR_PROT_FORM;
-	}
-
-	/* TX errors */
-	if (bdiag1 & MCP25XXFD_CAN_BDIAG1_NACKERR) {
-		stats->tx_errors++;
-		if (cf) {
-			cf->can_id |= CAN_ERR_ACK;
-			cf->data[2] |= CAN_ERR_PROT_TX;
-		}
-	}
-	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DBIT1ERR |
-		      MCP25XXFD_CAN_BDIAG1_NBIT1ERR)) {
-		stats->tx_errors++;
-		if (cf)
-			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT1;
-	}
-	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DBIT0ERR |
-		      MCP25XXFD_CAN_BDIAG1_NBIT0ERR)) {
-		stats->tx_errors++;
-		if (cf)
-			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT0;
-	}
-
-	if (!cf)
-		return 0;
-
-	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
-	if (err)
-		stats->rx_fifo_errors++;
-
-	return 0;
-}
-
-static int mcp25xxfd_handle_cerrif(struct mcp25xxfd_priv *priv)
-{
-	struct net_device_stats *stats = &priv->ndev->stats;
-	struct sk_buff *skb;
-	struct can_frame *cf = NULL;
-	enum can_state new_state, rx_state, tx_state;
-	u32 trec, timestamp;
-	int err;
-
-	/* The skb allocation might fail, but can_change_state()
-	 * handles cf == NULL.
-	 */
-	skb = mcp25xxfd_alloc_can_err_skb(priv, &cf, &timestamp);
-
-	err = regmap_read(priv->map, MCP25XXFD_CAN_TREC, &trec);
-	if (err)
-		return err;
-
-	if (trec & MCP25XXFD_CAN_TREC_TXBO)
-		tx_state = CAN_STATE_BUS_OFF;
-	else if (trec & MCP25XXFD_CAN_TREC_TXBP)
-		tx_state = CAN_STATE_ERROR_PASSIVE;
-	else if (trec & MCP25XXFD_CAN_TREC_TXWARN)
-		tx_state = CAN_STATE_ERROR_WARNING;
-	else
-		tx_state = CAN_STATE_ERROR_ACTIVE;
-
-	if (trec & MCP25XXFD_CAN_TREC_RXBP)
-		rx_state = CAN_STATE_ERROR_PASSIVE;
-	else if (trec & MCP25XXFD_CAN_TREC_RXWARN)
-		rx_state = CAN_STATE_ERROR_WARNING;
-	else
-		rx_state = CAN_STATE_ERROR_ACTIVE;
-
-	new_state = max(tx_state, rx_state);
-	if (new_state == priv->can.state)
-		return 0;
-
-	can_change_state(priv->ndev, cf, tx_state, rx_state);
-
-	if (new_state == CAN_STATE_BUS_OFF) {
-		mcp25xxfd_chip_stop(priv, CAN_STATE_BUS_OFF);
-		can_bus_off(priv->ndev);
-	}
-
-	if (!skb)
-		return 0;
-
-	if (new_state != CAN_STATE_BUS_OFF) {
-		struct can_berr_counter bec;
-
-		err = mcp25xxfd_get_berr_counter(priv->ndev, &bec);
-		cf->data[6] = bec.txerr;
-		cf->data[7] = bec.rxerr;
-	}
-
-	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
-	if (err)
-		stats->rx_fifo_errors++;
-
-	return 0;
-}
-
-static int mcp25xxfd_handle_modif(const struct mcp25xxfd_priv *priv)
-{
-	const u8 mode_reference = mcp25xxfd_get_normal_mode(priv);
-	u8 mode;
-	int err;
-
-	err = mcp25xxfd_chip_get_mode(priv, &mode);
-	if (err)
-		return err;
-
-	if (mode == mode_reference)
-		return 0;
-
-	/* According to MCP2517FD errata DS80000792B, during a TX MAB
-	 * underflow, the controller will transition to Restricted
-	 * Operation Mode or Listen Only Mode (depending on SERR2LOM).
-	 *
-	 * However this is not always the case. When SERR2LOM is
-	 * configured for Restricted Operation Mode (SERR2LOM not set)
-	 * the MCP2517FD will sometimes transition to Listen Only Mode
-	 * first. When polling this bit we see that it will transition
-	 * to Restricted Operation Mode shortly after.
-	 */
-	if (mode == MCP25XXFD_CAN_CON_MODE_RESTRICTED ||
-	    mode == MCP25XXFD_CAN_CON_MODE_LISTENONLY)
-		netdev_dbg(priv->ndev,
-			    "Controller changed into %s Mode (%u).\n",
-			    mcp25xxfd_get_mode_str(mode), mode);
-	else
-		netdev_err(priv->ndev,
-			   "Controller changed into %s Mode (%u).\n",
-			   mcp25xxfd_get_mode_str(mode), mode);
-
-	/* After the application requests Normal mode, the CAN FD
-	 * Controller will automatically attempt to retransmit the
-	 * message that caused the TX MAB underflow.
-	 */
-	return mcp25xxfd_chip_set_normal_mode_nowait(priv);
-}
-
-static int mcp25xxfd_handle_serrif(struct mcp25xxfd_priv *priv)
-{
-	struct net_device_stats *stats = &priv->ndev->stats;
-
-	/* TX MAB underflow
-	 *
-	 * According to the MCP2517FD Errata DS80000792B a TX MAB
-	 * underflow is indicated by SERRIF and MODIF.
-	 *
-	 * Due to the corresponding Bus Errors, a IVMIF can be seen as
-	 * well.
-	 */
-	if ((priv->intf & MCP25XXFD_CAN_INT_MODIF) &&
-	    (priv->intf & MCP25XXFD_CAN_INT_IVMIF)) {
-		stats->tx_aborted_errors++;
-		stats->tx_errors++;
-
-		return 0;
-	}
-
-	/* RX MAB overflow
-	 *
-	 * According to the MCP2517FD Errata DS80000792B a RX MAB
-	 * overflow is indicated by SERRIF.
-	 */
-	if (priv->intf & MCP25XXFD_CAN_INT_RXIF) {
-		stats->rx_dropped++;
-		stats->rx_errors++;
-
-		return 0;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_handle_eccif(struct mcp25xxfd_priv *priv)
-{
-	int err;
-	u32 ecc_stat;
-
-	err = regmap_read(priv->map, MCP25XXFD_ECCSTAT, &ecc_stat);
-	if (err)
-		return err;
-
-	err = regmap_update_bits(priv->map, MCP25XXFD_ECCSTAT,
-				 MCP25XXFD_ECCSTAT_IF_MASK,
-				 ~ecc_stat);
-	if (err)
-		return err;
-
-	if (ecc_stat & MCP25XXFD_ECCSTAT_SECIF)
-		netdev_info(priv->ndev,
-			    "Single ECC Error corrected at address 0x%04lx.\n",
-			    FIELD_GET(MCP25XXFD_ECCSTAT_ERRADDR_MASK,
-				      ecc_stat));
-	else if (ecc_stat & MCP25XXFD_ECCSTAT_DEDIF)
-		netdev_notice(priv->ndev,
-			      "Double ECC Error detected at address 0x%04lx.\n",
-			      FIELD_GET(MCP25XXFD_ECCSTAT_ERRADDR_MASK,
-					ecc_stat));
-
-	return 0;
-}
-
-static int mcp25xxfd_handle_spicrcif(struct mcp25xxfd_priv *priv)
-{
-	int err;
-	u32 crc;
-
-	err = regmap_read(priv->map, MCP25XXFD_CRC, &crc);
-	if (err)
-		return err;
-
-	err = regmap_update_bits(priv->map, MCP25XXFD_CRC,
-				 MCP25XXFD_CRC_IF_MASK,
-				 ~crc);
-	if (err)
-		return err;
-
-	if (crc & MCP25XXFD_CRC_FERRIF)
-		netdev_info(priv->ndev, "CRC Command Format Error.\n");
-	else if (crc & MCP25XXFD_CRC_CRCERRIF)
-		netdev_notice(priv->ndev, "CRC Error detected. CRC=0x%04lx.\n",
-			      FIELD_GET(MCP25XXFD_CRC_MASK, crc));
-
-	return 0;
-}
-
-#define mcp25xxfd_handle(priv, irq, ...) \
-({ \
-	int err; \
-\
-	err = mcp25xxfd_handle_##irq(priv, ## __VA_ARGS__); \
-	if (err) \
-		netdev_err(priv->ndev, \
-			"IRQ handler mcp25xxfd_handle_%s() returned %d.\n", \
-			__stringify(irq), err); \
-	err; \
-})
-
-static irqreturn_t mcp25xxfd_irq(int irq, void *dev_id)
-{
-	struct mcp25xxfd_priv *priv = dev_id;
-	irqreturn_t handled = IRQ_NONE;
-	int err;
-
-	if (priv->rx_int)
-		do {
-			int rx_pending;
-
-			rx_pending = gpiod_get_value_cansleep(priv->rx_int);
-			if (!rx_pending)
-				break;
-
-			err = mcp25xxfd_handle(priv, rxif);
-			if (err)
-				goto out_fail;
-
-			handled = IRQ_HANDLED;
-		} while (1);
-
-	do {
-		u32 intf_pending, intf_pending_clearable;
-
-		err = regmap_read(priv->map, MCP25XXFD_CAN_INT, &priv->intf);
-		if (err)
-			goto out_fail;
-
-		intf_pending = FIELD_GET(MCP25XXFD_CAN_INT_IF_MASK, priv->intf) &
-			FIELD_GET(MCP25XXFD_CAN_INT_IE_MASK, priv->intf);
-
-		if (!(intf_pending))
-			return handled;
-
-		/* Some interrupts must be ACKed in the
-		 * MCP25XXFD_CAN_INT register.
-		 * - First ACK then handle, to avoid lost-IRQ race
-		 *   condition on fast re-occuring interrupts.
-		 * - Write "0" to clear active IRQs, "1" to all other,
-		 *   to avoid r/m/w race condition on the
-		 *   MCP25XXFD_CAN_INT register.
-		 */
-		intf_pending_clearable = intf_pending &
-			MCP25XXFD_CAN_INT_IF_CLEARABLE_MASK;
-		if (intf_pending_clearable) {
-			err = regmap_update_bits(priv->map, MCP25XXFD_CAN_INT,
-						 MCP25XXFD_CAN_INT_IF_MASK,
-						 ~intf_pending_clearable);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_MODIF) {
-			err = mcp25xxfd_handle(priv, modif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_RXIF) {
-			err = mcp25xxfd_handle(priv, rxif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_TEFIF) {
-			err = mcp25xxfd_handle(priv, tefif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_RXOVIF) {
-			err = mcp25xxfd_handle(priv, rxovif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_TXATIF) {
-			err = mcp25xxfd_handle(priv, txatif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_IVMIF) {
-			err = mcp25xxfd_handle(priv, ivmif);
-			if (err)
-				goto out_fail;
-		}
-
-		/* On the MCP2527FD and MCP2518FD, we don't get a
-		 * CERRIF IRQ on the transition TX ERROR_WARNING -> TX
-		 * ERROR_ACTIVE.
-		 */
-		if (intf_pending & MCP25XXFD_CAN_INT_CERRIF ||
-		    priv->can.state > CAN_STATE_ERROR_ACTIVE) {
-			err = mcp25xxfd_handle(priv, cerrif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_SERRIF) {
-			err = mcp25xxfd_handle(priv, serrif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_ECCIF) {
-			err = mcp25xxfd_handle(priv, eccif);
-			if (err)
-				goto out_fail;
-		}
-
-		if (intf_pending & MCP25XXFD_CAN_INT_SPICRCIE) {
-			err = mcp25xxfd_handle(priv, spicrcif);
-			if (err)
-				goto out_fail;
-		}
-
-		handled = IRQ_HANDLED;
-	} while (1);
-
- out_fail:
-	netdev_err(priv->ndev, "IRQ handler returned %d.\n", err);
-	mcp25xxfd_dump(priv);
-	mcp25xxfd_log_dump(priv);
-	mcp25xxfd_chip_interrupts_disable(priv);
-
-	return handled;
-}
-
-static inline struct
-mcp25xxfd_tx_obj *mcp25xxfd_get_tx_obj_next(struct mcp25xxfd_priv *priv)
-{
-	u8 tx_head;
-
-	tx_head = mcp25xxfd_get_tx_head(priv);
-
-	return &priv->tx.obj[tx_head];
-}
-
-static void
-mcp25xxfd_tx_obj_from_skb(const struct mcp25xxfd_priv *priv,
-			  struct mcp25xxfd_tx_obj *tx_obj,
-			  const struct sk_buff *skb)
-{
-	const struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
-	struct mcp25xxfd_hw_tx_obj_raw *hw_tx_obj = &tx_obj->load.buf.hw_tx_obj;
-	u32 id, flags, len;
-
-	if (cfd->can_id & CAN_EFF_FLAG) {
-		u32 sid, eid;
-
-		sid = FIELD_GET(MCP25XXFD_CAN_FRAME_EFF_SID_MASK, cfd->can_id);
-		eid = FIELD_GET(MCP25XXFD_CAN_FRAME_EFF_EID_MASK, cfd->can_id);
-
-		id = FIELD_PREP(MCP25XXFD_OBJ_ID_EID_MASK, eid) |
-			FIELD_PREP(MCP25XXFD_OBJ_ID_SID_MASK, sid);
-
-		flags = MCP25XXFD_OBJ_FLAGS_IDE;
-	} else {
-		id = FIELD_PREP(MCP25XXFD_OBJ_ID_SID_MASK, cfd->can_id);
-		flags = 0;
-	}
-
-	/* Use the MCP2518FD mask even on the MCP2517FD. It doesn't
-	 * harm, only the lower 7 bits will be transferred into the
-	 * TEF object.
-	 */
-	flags |= FIELD_PREP(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
-			    priv->tx.head) |
-		FIELD_PREP(MCP25XXFD_OBJ_FLAGS_DLC, can_len2dlc(cfd->len));
-
-	if (cfd->can_id & CAN_RTR_FLAG)
-		flags |= MCP25XXFD_OBJ_FLAGS_RTR;
-
-	/* CANFD */
-	if (can_is_canfd_skb(skb)) {
-		if (cfd->flags & CANFD_ESI)
-			flags |= MCP25XXFD_OBJ_FLAGS_ESI;
-
-		flags |= MCP25XXFD_OBJ_FLAGS_FDF;
-
-		if (cfd->flags & CANFD_BRS)
-			flags |= MCP25XXFD_OBJ_FLAGS_BRS;
-	}
-
-	put_unaligned_le32(id, &hw_tx_obj->id);
-	put_unaligned_le32(flags, &hw_tx_obj->flags);
-
-	// FIXME: what does the controller send in CANFD if can_dlc2len(can_len2dlc(cfd->len)) > cfd->len?
-	memset(hw_tx_obj->data + round_down(cfd->len, sizeof(u32)),
-	       0x0, sizeof(u32));
-	memcpy(hw_tx_obj->data, cfd->data, cfd->len);
-
-	len = sizeof(tx_obj->load.buf.cmd);
-	len += sizeof(hw_tx_obj->id) + sizeof(hw_tx_obj->flags);
-	len += round_up(cfd->len, sizeof(u32));
-
-	tx_obj->load.xfer.len = len;
-}
-
-static int mcp25xxfd_tx_obj_write(const struct mcp25xxfd_priv *priv,
-				  struct mcp25xxfd_tx_obj *tx_obj)
-{
-	int err;
-
-	err = spi_async(priv->spi, &tx_obj->load.msg);
-	if (err)
-		return err;
-
-	return spi_async(priv->spi, &tx_obj->trigger.msg);
-}
-
-static netdev_tx_t mcp25xxfd_start_xmit(struct sk_buff *skb,
-					struct net_device *ndev)
-{
-	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
-	struct mcp25xxfd_tx_obj *tx_obj;
-	const canid_t can_id = ((struct canfd_frame *)skb->data)->can_id;
-	u8 tx_head;
-	int err;
-
-	if (can_dropped_invalid_skb(ndev, skb))
-		return NETDEV_TX_OK;
-
-	mcp25xxfd_log(priv, can_id);
-
-	if (priv->tx.head - priv->tx.tail >= priv->tx.obj_num) {
-		netdev_info(priv->ndev,
-			   "Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\n",
-			   priv->tx.head, priv->tx.tail,
-			   priv->tx.head - priv->tx.tail);
-
-		mcp25xxfd_log_busy(priv, can_id);
-		netif_stop_queue(ndev);
-
-		return NETDEV_TX_BUSY;
-	}
-
-	tx_obj = mcp25xxfd_get_tx_obj_next(priv);
-	mcp25xxfd_tx_obj_from_skb(priv, tx_obj, skb);
-
-	// FIXME:
-	// if (!netdev_xmit_more() ||
-	//	netif_xmit_stopped(netdev_get_tx_queue(netdev, 0)))
-
-	/* Stop queue if we occupy the complete TX FIFO */
-	tx_head = mcp25xxfd_get_tx_head(priv);
-	priv->tx.head++;
-	if (priv->tx.head - priv->tx.tail >= priv->tx.obj_num) {
-		mcp25xxfd_log_stop(priv, can_id);
-		netif_stop_queue(ndev);
-	}
-
-	can_put_echo_skb(skb, ndev, tx_head);
-
-	err = mcp25xxfd_tx_obj_write(priv, tx_obj);
-	if (err)
-		goto out_err;
-
-	return NETDEV_TX_OK;
-
- out_err:
-	netdev_err(priv->ndev, "ERROR in %s: %d\n", __func__, err);
-	mcp25xxfd_dump(priv);
-	mcp25xxfd_log_dump(priv);
-
-	return NETDEV_TX_OK;
-}
-
-static int mcp25xxfd_open(struct net_device *ndev)
-{
-	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
-	const struct spi_device *spi = priv->spi;
-	int err;
-
-	err = pm_runtime_get_sync(ndev->dev.parent);
-	if (err < 0)
-		return err;
-
-	err = open_candev(ndev);
-	if (err)
-		goto out_pm_runtime_put;
-
-	err = request_threaded_irq(spi->irq, NULL, mcp25xxfd_irq,
-				   IRQF_ONESHOT, dev_name(&spi->dev),
-				   priv);
-	if (err)
-		goto out_close;
-
-	err = mcp25xxfd_transceiver_enable(priv);
-	if (err)
-		goto out_free_irq;
-
-	can_rx_offload_enable(&priv->offload);
-
-	err = mcp25xxfd_chip_start(priv);
-	if (err)
-		goto out_can_rx_offload_disable;
-
-	netif_start_queue(ndev);
-
-	return 0;
-
- out_can_rx_offload_disable:
-	can_rx_offload_disable(&priv->offload);
-	mcp25xxfd_transceiver_disable(priv);
- out_free_irq:
-	free_irq(spi->irq, priv);
- out_close:
-	close_candev(ndev);
- out_pm_runtime_put:
-	mcp25xxfd_chip_stop(priv, CAN_STATE_STOPPED);
-	pm_runtime_put(ndev->dev.parent);
-
-	return err;
-}
-
-static int mcp25xxfd_stop(struct net_device *ndev)
-{
-	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
-
-	netif_stop_queue(ndev);
-	mcp25xxfd_chip_stop(priv, CAN_STATE_STOPPED);
-	can_rx_offload_disable(&priv->offload);
-	mcp25xxfd_transceiver_disable(priv);
-	free_irq(ndev->irq, priv);
-	close_candev(ndev);
-
-	pm_runtime_put(ndev->dev.parent);
-
-	return 0;
-}
-
-static const struct net_device_ops mcp25xxfd_netdev_ops = {
-	.ndo_open = mcp25xxfd_open,
-	.ndo_stop = mcp25xxfd_stop,
-	.ndo_start_xmit	= mcp25xxfd_start_xmit,
-	.ndo_change_mtu = can_change_mtu,
-};
-
-static int mcp25xxfd_register_chip_detect(struct mcp25xxfd_priv *priv)
-{
-	const struct net_device *ndev = priv->ndev;
-	u32 osc, osc_reference;
-	enum mcp25xxfd_model model;
-	int err;
-
-	osc_reference = MCP25XXFD_OSC_OSCRDY |
-		FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK,
-			   MCP25XXFD_OSC_CLKODIV_10);
-
-	/* check reset defaults of OSC reg */
-	err = regmap_read(priv->map, MCP25XXFD_OSC, &osc);
-	if (err)
-		return err;
-
-	if (osc != osc_reference) {
-		netdev_err(ndev,
-			   "Chip failed to soft reset. osc=0x%08x, reference value=0x%08x\n",
-			   osc, osc_reference);
-		return -ENODEV;
-	}
-
-	/* The OSC_LPMEN is only supported on MCP2518FD, so use it to
-	 * autodetect the model.
-	 */
-	err = regmap_update_bits(priv->map, MCP25XXFD_OSC,
-				 MCP25XXFD_OSC_LPMEN, MCP25XXFD_OSC_LPMEN);
-	if (err)
-		return err;
-
-	err = regmap_read(priv->map, MCP25XXFD_OSC, &osc);
-	if (err)
-		return err;
-
-	if (osc & MCP25XXFD_OSC_LPMEN)
-		model = CAN_MCP2518FD;
-	else
-		model = CAN_MCP2517FD;
-
-	if (priv->model != CAN_MCP25XXFD &&
-	    priv->model != model) {
-		netdev_info(ndev,
-			    "Detected MCP%xFD, but firmware specifies a MCP%xFD. Fixing up.",
-			    model, priv->model);
-	}
-	priv->model = model;
-
-	return 0;
-}
-
-static int mcp25xxfd_register_check_rx_int(struct mcp25xxfd_priv *priv)
-{
-	int err, rx_pending;
-
-	if (!priv->rx_int)
-		return 0;
-
-	err = mcp25xxfd_chip_pinctrl_init(priv);
-	if (err)
-		return err;
-
-	/* Check if RX_INT is properly working. The RX-INT should not
-	 * be active after a softreset.
-	 */
-	rx_pending = gpiod_get_value_cansleep(priv->rx_int);
-	if (!rx_pending)
-		return 0;
-
-	netdev_info(priv->ndev,
-		   "RX-INT active after softreset, disabling RX-INT support.");
-	devm_gpiod_put(&priv->spi->dev, priv->rx_int);
-	priv->rx_int = NULL;
-
-	return 0;
-}
-
-static int mcp25xxfd_register(struct mcp25xxfd_priv *priv)
-{
-	struct net_device *ndev = priv->ndev;
-	int err;
-
-	err = mcp25xxfd_clks_and_vdd_enable(priv);
-	if (err)
-		return err;
-
-	pm_runtime_get_noresume(ndev->dev.parent);
-	err = pm_runtime_set_active(ndev->dev.parent);
-	if (err)
-		goto out_runtime_put_noidle;
-	pm_runtime_enable(ndev->dev.parent);
-
-	/* Wait for oscillator startup timer after power up */
-	mdelay(MCP25XXFD_OSC_DELAY_MS);
-
-	err = mcp25xxfd_chip_softreset(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_register_chip_detect(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = mcp25xxfd_register_check_rx_int(priv);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	err = register_candev(ndev);
-	if (err)
-		goto out_chip_set_mode_sleep;
-
-	if (priv->model == CAN_MCP2517FD) {
-		netdev_info(ndev, "MCP%xFD %ssuccessfully initialized.\n",
-			    priv->model, priv->rx_int ? "(+RX-INT) " : "");
-	} else {
-		u32 devid;
-
-		err = regmap_read(priv->map, MCP25XXFD_DEVID, &devid);
-		if (err)
-			goto out_unregister_candev;
-
-		netdev_info(ndev, "MCP%xFD rev%lu.%lu %ssuccessfully initialized.\n",
-			    priv->model,
-			    FIELD_GET(MCP25XXFD_DEVID_ID_MASK, devid),
-			    FIELD_GET(MCP25XXFD_DEVID_REV_MASK, devid),
-			    priv->rx_int ? "(+RX-INT) " : "");
-	}
-
-	/* Put core into sleep mode and let pm_runtime_put() disable
-	 * the clocks and vdd. If CONFIG_PM is not enabled, the clocks
-	 * and vdd will stay powered.
-	 */
-	err = mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
-	if (err)
-		goto out_unregister_candev;
-
-	pm_runtime_put(ndev->dev.parent);
-
-	return 0;
-
- out_unregister_candev:
-	unregister_candev(ndev);
- out_chip_set_mode_sleep:
-	mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
-	pm_runtime_disable(ndev->dev.parent);
- out_runtime_put_noidle:
-	pm_runtime_put_noidle(ndev->dev.parent);
-	mcp25xxfd_clks_and_vdd_disable(priv);
-
-	return err;
-}
-
-static inline void mcp25xxfd_unregister(struct mcp25xxfd_priv *priv)
-{
-	struct net_device *ndev	= priv->ndev;
-
-	unregister_candev(ndev);
-
-	pm_runtime_get_sync(ndev->dev.parent);
-	pm_runtime_put_noidle(ndev->dev.parent);
-	mcp25xxfd_clks_and_vdd_disable(priv);
-	pm_runtime_disable(ndev->dev.parent);
-}
-
-static const struct of_device_id mcp25xxfd_of_match[] = {
-	{
-		.compatible = "microchip,mcp2517fd",
-		.data = (void *)CAN_MCP2517FD,
-	}, {
-		.compatible = "microchip,mcp2518fd",
-		.data = (void *)CAN_MCP2518FD,
-	}, {
-		.compatible = "microchip,mcp25xxfd",
-		.data = (void *)CAN_MCP25XXFD,
-	}, {
-		/* sentinel */
-	},
-};
-MODULE_DEVICE_TABLE(of, mcp25xxfd_of_match);
-
-static const struct spi_device_id mcp25xxfd_id_table[] = {
-	{
-		.name = "mcp2517fd",
-		.driver_data = (kernel_ulong_t)CAN_MCP2517FD,
-	}, {
-		.name = "mcp2518fd",
-		.driver_data = (kernel_ulong_t)CAN_MCP2518FD,
-	}, {
-		.name = "mcp25xxfd",
-		.driver_data = (kernel_ulong_t)CAN_MCP25XXFD,
-	}, {
-		/* sentinel */
-	},
-};
-MODULE_DEVICE_TABLE(spi, mcp25xxfd_id_table);
-
-static int mcp25xxfd_probe(struct spi_device *spi)
-{
-#if 0
-	const void *match;
-#endif/*0*/
-	struct net_device *ndev;
-	struct mcp25xxfd_priv *priv;
-	struct gpio_desc *rx_int;
-	struct regulator *reg_vdd, *reg_xceiver;
-	struct clk *clk;
-	u32 freq;
-	int err;
-
-	rx_int = devm_gpiod_get_optional(&spi->dev, "rx-int", GPIOD_IN);
-	if (PTR_ERR(rx_int) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-	else if (IS_ERR(rx_int))
-		return PTR_ERR(rx_int);
-
-	reg_vdd = devm_regulator_get_optional(&spi->dev, "vdd");
-	if (PTR_ERR(reg_vdd) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-	else if (PTR_ERR(reg_vdd) == -ENODEV)
-		reg_vdd = NULL;
-	else if (IS_ERR(reg_vdd))
-		return PTR_ERR(reg_vdd);
-
-	reg_xceiver = devm_regulator_get_optional(&spi->dev, "xceiver");
-	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-	else if (PTR_ERR(reg_xceiver) == -ENODEV)
-		reg_xceiver = NULL;
-	else if (IS_ERR(reg_xceiver))
-		return PTR_ERR(reg_xceiver);
-
-	clk = devm_clk_get(&spi->dev, NULL);
-	if (IS_ERR(clk)) {
-		dev_err(&spi->dev, "No Oscillator (clock) defined.\n");
-		return PTR_ERR(clk);
-	}
-	freq = clk_get_rate(clk);
-
-	/* Sanity check */
-	if (freq < MCP25XXFD_SYSCLOCK_HZ_MIN ||
-	    freq > MCP25XXFD_SYSCLOCK_HZ_MAX) {
-		dev_err(&spi->dev, "Oscillator frequency is too low.\n");
-		return -ERANGE;
-	}
-
-	if (freq < MCP25XXFD_SYSCLOCK_HZ_MAX /
-	    MCP25XXFD_OSC_PLL_MULTIPLIER) {
-		dev_err(&spi->dev,
-			"Oscillator frequency is too low and PLL in not supported.\n");
-		return -ERANGE;
-	}
-
-	ndev = alloc_candev(sizeof(struct mcp25xxfd_priv),
-			    MCP25XXFD_TX_OBJ_NUM_MAX);
-	if (!ndev)
-		return -ENOMEM;
-
-	SET_NETDEV_DEV(ndev, &spi->dev);
-
-	ndev->netdev_ops = &mcp25xxfd_netdev_ops;
-	ndev->irq = spi->irq;
-	ndev->flags |= IFF_ECHO;
-
-	priv = netdev_priv(ndev);
-	spi_set_drvdata(spi, priv);
-	priv->can.clock.freq = freq;
-	priv->can.do_set_mode = mcp25xxfd_set_mode;
-	priv->can.do_get_berr_counter = mcp25xxfd_get_berr_counter;
-	priv->can.bittiming_const = &mcp25xxfd_bittiming_const;
-	priv->can.data_bittiming_const = &mcp25xxfd_data_bittiming_const;
-	priv->can.ctrlmode_supported = CAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_FD |
-		CAN_CTRLMODE_BERR_REPORTING;
-	priv->ndev = ndev;
-	priv->spi = spi;
-	priv->rx_int = rx_int;
-	priv->clk = clk;
-	priv->reg_vdd = reg_vdd;
-	priv->reg_xceiver = reg_xceiver;
-	atomic_set(&priv->cnt, 0);
-#if 0
-	match = device_get_match_data(&spi->dev);
-	if (match)
-		priv->model = (enum mcp25xxfd_model)match;
-	else
-#endif/*0*/
-		priv->model = spi_get_device_id(spi)->driver_data;
-
-	spi->bits_per_word = 8;
-	/* SPI clock must be less or equal SYSCLOCK / 2 */
-	spi->max_speed_hz = min(spi->max_speed_hz, freq / 2);
-	err = spi_setup(spi);
-	if (err)
-		goto out_free_candev;
-
-	err = mcp25xxfd_regmap_init(priv);
-	if (err)
-		goto out_free_candev;
-
-	err = can_rx_offload_add_manual(ndev, &priv->offload,
-					MCP25XXFD_NAPI_WEIGHT);
-	if (err)
-		goto out_free_candev;
-
-	err = mcp25xxfd_register(priv);
-	if (err)
-		goto out_free_candev;
-
-	return 0;
-
- out_free_candev:
-	free_candev(ndev);
-
-	return err;
-}
-
-static int mcp25xxfd_remove(struct spi_device *spi)
-{
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	struct net_device *ndev = priv->ndev;
-
-	can_rx_offload_del(&priv->offload);
-	mcp25xxfd_unregister(priv);
-	free_candev(ndev);
-
-	return 0;
-}
-
-static int __maybe_unused mcp25xxfd_runtime_suspend(struct device *device)
-{
-	const struct mcp25xxfd_priv *priv = dev_get_drvdata(device);
-
-	return mcp25xxfd_clks_and_vdd_disable(priv);
-}
-
-static int __maybe_unused mcp25xxfd_runtime_resume(struct device *device)
-{
-	const struct mcp25xxfd_priv *priv = dev_get_drvdata(device);
-
-	return mcp25xxfd_clks_and_vdd_enable(priv);
-}
-
-static const struct dev_pm_ops mcp25xxfd_pm_ops = {
-	SET_RUNTIME_PM_OPS(mcp25xxfd_runtime_suspend,
-			   mcp25xxfd_runtime_resume, NULL)
-};
-
-static struct spi_driver mcp25xxfd_driver = {
-	.driver = {
-		.name = DEVICE_NAME,
-		.pm = &mcp25xxfd_pm_ops,
-		.of_match_table = mcp25xxfd_of_match,
-	},
-	.probe = mcp25xxfd_probe,
-	.remove = mcp25xxfd_remove,
-	.id_table = mcp25xxfd_id_table,
-};
-module_spi_driver(mcp25xxfd_driver);
-
-MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutornix.de>");
-MODULE_DESCRIPTION("Microchip MCP25xxFD Family CAN controller driver");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
deleted file mode 100644
index b04ec5000968..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
+++ /dev/null
@@ -1,685 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
-//
-// Copyright (c) 2019, 2020 Pengutronix,
-//                          Marc Kleine-Budde <kernel@pengutronix.de>
-//
-
-#include <linux/bitfield.h>
-#include <linux/kernel.h>
-
-#include "mcp25xxfd.h"
-
-#define __dump_bit(val, prefix, bit, desc) \
-	pr_info("%16s   %s\t\t%s\n", __stringify(bit), \
-		(val) & prefix##_##bit ? "x" : " ", desc)
-
-#define __dump_mask(val, prefix, mask, fmt, desc) \
-	pr_info("%16s = " fmt "\t\t%s\n", \
-		__stringify(mask), \
-		FIELD_GET(prefix##_##mask##_MASK, (val)), \
-		desc)
-
-static void mcp25xxfd_dump_reg_con(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("CON: con(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_mask(val, MCP25XXFD_CAN_CON, TXBWS, "0x%02lx", "Transmit Bandwidth Sharing");
-	__dump_bit(val, MCP25XXFD_CAN_CON, ABAT, "Abort All Pending Transmissions");
-	__dump_mask(val, MCP25XXFD_CAN_CON, REQOP, "0x%02lx", "Request Operation Mode");
-	__dump_mask(val, MCP25XXFD_CAN_CON, OPMOD, "0x%02lx", "Operation Mode Status");
-	__dump_bit(val, MCP25XXFD_CAN_CON, TXQEN, "Enable Transmit Queue");
-	__dump_bit(val, MCP25XXFD_CAN_CON, STEF, "Store in Transmit Event FIFO");
-	__dump_bit(val, MCP25XXFD_CAN_CON, SERR2LOM, "Transition to Listen Only Mode on System Error");
-	__dump_bit(val, MCP25XXFD_CAN_CON, ESIGM, "Transmit ESI in Gateway Mode");
-	__dump_bit(val, MCP25XXFD_CAN_CON, RTXAT, "Restrict Retransmission Attempts");
-	__dump_bit(val, MCP25XXFD_CAN_CON, BRSDIS, "Bit Rate Switching Disable");
-	__dump_bit(val, MCP25XXFD_CAN_CON, BUSY, "CAN Module is Busy");
-	__dump_mask(val, MCP25XXFD_CAN_CON, WFT, "0x%02lx", "Selectable Wake-up Filter Time");
-	__dump_bit(val, MCP25XXFD_CAN_CON, WAKFIL, "Enable CAN Bus Line Wake-up Filter");
-	__dump_bit(val, MCP25XXFD_CAN_CON, PXEDIS, "Protocol Exception Event Detection Disabled");
-	__dump_bit(val, MCP25XXFD_CAN_CON, ISOCRCEN, "Enable ISO CRC in CAN FD Frames");
-	__dump_mask(val, MCP25XXFD_CAN_CON, DNCNT, "0x%02lx", "Device Net Filter Bit Number");
-}
-
-static void mcp25xxfd_dump_reg_tbc(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("TBC: tbc(0x%03x)=0x%08x\n", addr, val);
-}
-
-static void mcp25xxfd_dump_reg_vec(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	u8 rx_code, tx_code, i_code;
-
-	pr_info("VEC: vec(0x%03x)=0x%08x\n", addr, val);
-
-	rx_code = FIELD_GET(MCP25XXFD_CAN_VEC_RXCODE_MASK, val);
-	tx_code = FIELD_GET(MCP25XXFD_CAN_VEC_TXCODE_MASK, val);
-	i_code = FIELD_GET(MCP25XXFD_CAN_VEC_ICODE_MASK, val);
-
-	pr_info("\trxcode: ");
-	if (rx_code == 0x40)
-		pr_cont("No Interrupt");
-	else if (rx_code < 0x20)
-		pr_cont("FIFO %u", rx_code);
-	else
-		pr_cont("Reserved");
-	pr_cont(" (0x%02x)\n", rx_code);
-
-	pr_info("\ttxcode: ");
-	if (tx_code == 0x40)
-		pr_cont("No Interrupt");
-	else if (tx_code < 0x20)
-		pr_cont("FIFO %u", tx_code);
-	else
-		pr_cont("Reserved");
-	pr_cont(" (0x%02x)\n", tx_code);
-
-	pr_info("\ticode: ");
-	if (i_code == 0x4a)
-		pr_cont("Transmit Attempt Interrupt");
-	else if (i_code == 0x49)
-		pr_cont("Transmit Event FIFO Interrupt");
-	else if (i_code == 0x48)
-		pr_cont("Invalid Message Occurred");
-	else if (i_code == 0x47)
-		pr_cont("Operation Mode Changed");
-	else if (i_code == 0x46)
-		pr_cont("TBC Overflow");
-	else if (i_code == 0x45)
-		pr_cont("RX/TX MAB Overflow/Underflow");
-	else if (i_code == 0x44)
-		pr_cont("Address Error Interrupt");
-	else if (i_code == 0x43)
-		pr_cont("Receive FIFO Overflow Interrupt");
-	else if (i_code == 0x42)
-		pr_cont("Wake-up Interrupt");
-	else if (i_code == 0x41)
-		pr_cont("Error Interrupt");
-	else if (i_code == 0x40)
-		pr_cont("No Interrupt");
-	else if (i_code < 0x20)
-		pr_cont("FIFO %u", i_code);
-	else
-		pr_cont("Reserved");
-	pr_cont(" (0x%02x)\n", i_code);
-}
-
-#define __dump_int(val, bit, desc) \
-	pr_info("\t" __stringify(bit) "\t%s\t%s\t%s\t%s\n", \
-		 (val) & MCP25XXFD_CAN_INT_##bit##E ? "x" : "", \
-		 (val) & MCP25XXFD_CAN_INT_##bit##F ? "x" : "", \
-		 FIELD_GET(MCP25XXFD_CAN_INT_IF_MASK, val) & \
-		 FIELD_GET(MCP25XXFD_CAN_INT_IE_MASK, val) & \
-		 MCP25XXFD_CAN_INT_##bit##F ? "x" : "", \
-		 desc)
-
-static void mcp25xxfd_dump_reg_intf(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("INT: intf(0x%03x)=0x%08x\n", addr, val);
-
-	pr_info("\t\tIE\tIF\tIE & IF\n");
-	__dump_int(val, IVMI, "Invalid Message Interrupt");
-	__dump_int(val, WAKI, "Bus Wake Up Interrupt");
-	__dump_int(val, CERRI, "CAN Bus Error Interrupt");
-	__dump_int(val, SERRI, "System Error Interrupt");
-	__dump_int(val, RXOVI, "Receive FIFO Overflow Interrupt");
-	__dump_int(val, TXATI, "Transmit Attempt Interrupt");
-	__dump_int(val, SPICRCI, "SPI CRC Error Interrupt");
-	__dump_int(val, ECCI, "ECC Error Interrupt");
-	__dump_int(val, TEFI, "Transmit Event FIFO Interrupt");
-	__dump_int(val, MODI, "Mode Change Interrupt");
-	__dump_int(val, TBCI, "Time Base Counter Interrupt");
-	__dump_int(val, RXI, "Receive FIFO Interrupt");
-	__dump_int(val, TXI, "Transmit FIFO Interrupt");
-}
-
-#undef __dump_int
-
-#define __create_dump_fifo_bitmask(fifo, name, description) \
-static void mcp25xxfd_dump_reg_##fifo(const struct mcp25xxfd_priv *priv, u32 val, u16 addr) \
-{ \
-	int i; \
-\
-	pr_info(__stringify(name) ": " __stringify(fifo) "(0x%03x)=0x%08x\n", addr, val); \
-	pr_info(description ":\n"); \
-	if (!val) { \
-		pr_info("\t\t-none-\n"); \
-		return; \
-	} \
-\
-	pr_info("\t\t"); \
-	for (i = 0; i < sizeof(val); i++) { \
-		if (val & BIT(i)) \
-			pr_cont("%d ", i); \
-	} \
-\
-	pr_cont("\n"); \
-}
-
-__create_dump_fifo_bitmask(rxif, RXIF, "Receive FIFO Interrupt Pending bits");
-__create_dump_fifo_bitmask(rxovif, RXOVIF, "Receive FIFO Overflow Interrupt Pending bits");
-__create_dump_fifo_bitmask(txif, TXIF, "Transmit FIFO Interrupt Pending bits");
-__create_dump_fifo_bitmask(txatif, TXATIF, "Transmit FIFO Attempt Interrupt Pending bits");
-__create_dump_fifo_bitmask(txreq, TXREQ, "Message Send Request bits");
-
-#undef __create_dump_fifo_bitmask
-
-static void mcp25xxfd_dump_reg_trec(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("TREC: trec(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_bit(val, MCP25XXFD_CAN_TREC, TXBO, "Transmitter in Bus Off State");
-	__dump_bit(val, MCP25XXFD_CAN_TREC, TXBP, "Transmitter in Error Passive State");
-	__dump_bit(val, MCP25XXFD_CAN_TREC, RXBP, "Receiver in Error Passive State");
-	__dump_bit(val, MCP25XXFD_CAN_TREC, TXWARN, "Transmitter in Error Warning State");
-	__dump_bit(val, MCP25XXFD_CAN_TREC, RXWARN, "Receiver in Error Warning State");
-	__dump_bit(val, MCP25XXFD_CAN_TREC, EWARN, "Transmitter or Receiver is in Error Warning State");
-
-	__dump_mask(val, MCP25XXFD_CAN_TREC, TEC, "%3lu", "Transmit Error Counter");
-	__dump_mask(val, MCP25XXFD_CAN_TREC, REC, "%3lu", "Receive Error Counter");
-}
-
-static void mcp25xxfd_dump_reg_bdiag0(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("BDIAG0: bdiag0(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, DTERRCNT, "%3lu", "Data Bit Rate Transmit Error Counter");
-	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, DRERRCNT, "%3lu", "Data Bit Rate Receive Error Counter");
-	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, NTERRCNT, "%3lu", "Nominal Bit Rate Transmit Error Counter");
-	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, NRERRCNT, "%3lu", "Nominal Bit Rate Receive Error Counter");
-}
-
-static void mcp25xxfd_dump_reg_bdiag1(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("BDIAG1: bdiag1(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DLCMM, "DLC Mismatch");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, ESI, "ESI flag of a received CAN FD message was set");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DCRCERR, "Data CRC Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DSTUFERR, "Data Bit Stuffing Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DFORMERR, "Data Format Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DBIT1ERR, "Data BIT1 Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DBIT0ERR, "Data BIT0 Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, TXBOERR, "Device went to bus-off (and auto-recovered)");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NCRCERR, "CRC Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NSTUFERR, "Bit Stuffing Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NFORMERR, "Format Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NACKERR, "Transmitted message was not acknowledged");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NBIT1ERR, "Bit1 Error");
-	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NBIT0ERR, "Bit0 Error");
-	__dump_mask(val, MCP25XXFD_CAN_BDIAG1, EFMSGCNT, "%3lu", "Error Free Message Counter bits");
-}
-
-static void mcp25xxfd_dump_reg_osc(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("OSC: osc(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_bit(val, MCP25XXFD_OSC, SCLKRDY, "Synchronized SCLKDIV");
-	__dump_bit(val, MCP25XXFD_OSC, OSCRDY, "Clock Ready");
-	__dump_bit(val, MCP25XXFD_OSC, PLLRDY, "PLL Ready");
-	__dump_mask(val, MCP25XXFD_OSC, CLKODIV, "%2lu", "Clock Output Divisor");
-	__dump_bit(val, MCP25XXFD_OSC, SCLKDIV, "System Clock Divisor");
-	__dump_bit(val, MCP25XXFD_OSC, LPMEN, "Low Power Mode (LPM) Enable (MCP2518FD only)");
-	__dump_bit(val, MCP25XXFD_OSC, OSCDIS, "Clock (Oscillator) Disable");
-	__dump_bit(val, MCP25XXFD_OSC, PLLEN, "PLL Enable");
-}
-
-static void mcp25xxfd_dump_reg_tefcon(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("TEFCON: tefcon(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_mask(val, MCP25XXFD_CAN_TEFCON, FSIZE, "%3lu", "FIFO Size");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, FRESET, "FIFO Reset");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, UINC, "Increment Tail");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFTSEN, "Transmit Event FIFO Time Stamp Enable");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFOVIE, "Transmit Event FIFO Overflow Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFFIE, "Transmit Event FIFO Full Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFHIE, "Transmit Event FIFO Half Full Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFNEIE, "Transmit Event FIFO Not Empty Interrupt Enable");
-}
-
-static void mcp25xxfd_dump_reg_tefsta(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("TEFSTA: tefsta(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFOVIF, "Transmit Event FIFO Overflow Interrupt Flag");
-	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFFIF, "Transmit Event FIFO Full Interrupt Flag (0 = not full)");
-	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFHIF, "Transmit Event FIFO Half Full Interrupt Flag (0= < half full)");
-	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFNEIF, "Transmit Event FIFO Not Empty Interrupt Flag (0=empty)");
-}
-
-static void mcp25xxfd_dump_reg_tefua(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("TEFUA: tefua(0x%03x)=0x%08x\n", addr, val);
-}
-
-static void mcp25xxfd_dump_reg_fifocon(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("FIFOCON: fifocon(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, PLSIZE, "%3lu", "Payload Size");
-	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, FSIZE, "%3lu", "FIFO Size");
-	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, TXAT, "%3lu", "Retransmission Attempts");
-	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, TXPRI, "%3lu", "Message Transmit Priority");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, FRESET, "FIFO Reset");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXREQ, "Message Send Request");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, UINC, "Increment Head/Tail");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXEN, "TX/RX FIFO Selection (0=RX, 1=TX)");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RTREN, "Auto RTR Enable");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RXTSEN, "Received Message Time Stamp Enable");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXATIE, "Transmit Attempts Exhausted Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RXOVIE, "Overflow Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFERFFIE, "Transmit/Receive FIFO Empty/Full Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFHRFHIE, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Enable");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFNRFNIE, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Enable");
-}
-
-static void mcp25xxfd_dump_reg_fifosta(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("FIFOSTA: fifosta(0x%03x)=0x%08x\n", addr, val);
-
-	__dump_mask(val, MCP25XXFD_CAN_FIFOSTA, FIFOCI, "%3lu", "FIFO Message Index");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXABT, "Message Aborted Status (1=aborted, 0=completed successfully)");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXLARB, "Message Lost Arbitration Status");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXERR, "Error Detected During Transmission");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXATIF, "Transmit Attempts Exhausted Interrupt Pending");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, RXOVIF, "Receive FIFO Overflow Interrupt Flag");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFERFFIF, "Transmit/Receive FIFO Empty/Full Interrupt Flag");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFHRFHIF, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Flag");
-	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFNRFNIF, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Flag");
-}
-
-static void mcp25xxfd_dump_reg_fifoua(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
-{
-	pr_info("FIFOUA: fifoua(0x%03x)=0x%08x\n", addr, val);
-}
-
-#define __dump_call(regs, val) \
-do { \
-	mcp25xxfd_dump_reg_##val(priv, (regs)->val, (u16)offsetof(typeof(*(regs)), val)); \
-	pr_info("\n"); \
-} while (0)
-
-#define __dump_call_fifo(reg, val) \
-do { \
-	mcp25xxfd_dump_reg_##reg(priv, regs->val, (u16)offsetof(typeof(*regs), val)); \
-	pr_info("\n"); \
-} while (0)
-
-static void
-mcp25xxfd_dump_regs(const struct mcp25xxfd_priv *priv,
-		    const struct mcp25xxfd_dump_regs *regs,
-		    const struct mcp25xxfd_dump_regs_mcp25xxfd *regs_mcp25xxfd)
-{
-	netdev_info(priv->ndev, "-------------------- register dump --------------------\n");
-	__dump_call(regs_mcp25xxfd, osc);
-	__dump_call(regs, con);
-	__dump_call(regs, tbc);
-	__dump_call(regs, vec);
-	__dump_call(regs, intf);
-	__dump_call(regs, rxif);
-	__dump_call(regs, rxovif);
-	__dump_call(regs, txif);
-	__dump_call(regs, txatif);
-	__dump_call(regs, txreq);
-	__dump_call(regs, trec);
-	__dump_call(regs, bdiag0);
-	__dump_call(regs, bdiag1);
-	pr_info("-------------------- TEF --------------------\n");
-	__dump_call(regs, tefcon);
-	__dump_call(regs, tefsta);
-	__dump_call(regs, tefua);
-	pr_info("-------------------- TX_FIFO --------------------\n");
-	__dump_call_fifo(fifocon, fifo[MCP25XXFD_TX_FIFO].con);
-	__dump_call_fifo(fifosta, fifo[MCP25XXFD_TX_FIFO].sta);
-	__dump_call_fifo(fifoua, fifo[MCP25XXFD_TX_FIFO].ua);
-	pr_info(" -------------------- RX_FIFO --------------------\n");
-	__dump_call_fifo(fifocon, fifo[MCP25XXFD_RX_FIFO(0)].con);
-	__dump_call_fifo(fifosta, fifo[MCP25XXFD_RX_FIFO(0)].sta);
-	__dump_call_fifo(fifoua, fifo[MCP25XXFD_RX_FIFO(0)].ua);
-	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
-}
-
-#undef __dump_call
-#undef __dump_call_fifo
-
-static u8 mcp25xxfd_dump_get_fifo_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u32 fifo_con)
-{
-	u8 obj_size;
-
-	obj_size = FIELD_GET(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK, fifo_con);
-	switch (obj_size) {
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_8:
-		return 8;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_12:
-		return 12;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_16:
-		return 16;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_20:
-		return 20;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_24:
-		return 24;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_32:
-		return 32;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_48:
-		return 48;
-	case MCP25XXFD_CAN_FIFOCON_PLSIZE_64:
-		return 64;
-	}
-
-	return 0;
-}
-
-static u8 mcp25xxfd_dump_get_fifo_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u32 fifo_con)
-{
-	u8 obj_num;
-
-	obj_num = FIELD_GET(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK, fifo_con);
-
-	return obj_num + 1;
-}
-
-static void mcp25xxfd_dump_ram_fifo_obj_data(const struct mcp25xxfd_priv *priv, const u8 *data, u8 dlc)
-{
-	int i;
-	u8 len;
-
-	len = can_dlc2len(get_canfd_dlc(dlc));
-
-	if (!len) {
-		pr_info("%16s = -none-\n", "data");
-		return;
-	}
-
-	for (i = 0; i < len; i++) {
-		if ((i % 8) == 0) {
-			if (i == 0)
-				pr_info("%16s = %02x", "data", data[i]);
-			else
-				pr_info("                   %02x", data[i]);
-		} else if ((i % 4) == 0) {
-			pr_cont("  %02x", data[i]);
-		} else if ((i % 8) == 7) {
-			pr_cont(" %02x\n", data[i]);
-		} else {
-			pr_cont(" %02x", data[i]);
-		}
-	}
-
-	if (i % 8)
-		pr_cont("\n");
-}
-
-/* TEF */
-
-static u8 mcp25xxfd_dump_get_tef_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->tef.con);
-}
-
-static u8 mcp25xxfd_dump_get_tef_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return regs->tefua / sizeof(struct mcp25xxfd_hw_tef_obj);
-}
-
-static u16 mcp25xxfd_dump_get_tef_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return sizeof(struct mcp25xxfd_hw_tef_obj) * n;
-}
-
-static u16 mcp25xxfd_dump_get_tef_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return mcp25xxfd_dump_get_tef_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
-}
-
-/* TX */
-
-static u8 mcp25xxfd_dump_get_tx_obj_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return sizeof(struct mcp25xxfd_hw_tx_obj_can) -
-		FIELD_SIZEOF(struct mcp25xxfd_hw_tx_obj_can, data) +
-		mcp25xxfd_dump_get_fifo_size(priv, regs, regs->tx_fifo.con);
-}
-
-static u8 mcp25xxfd_dump_get_tx_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->tx_fifo.con);
-}
-
-static u16 mcp25xxfd_dump_get_tx_obj_rel_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
-{
-	return mcp25xxfd_dump_get_tef_obj_rel_addr(priv, mcp25xxfd_dump_get_tef_obj_num(priv, regs)) +
-		mcp25xxfd_dump_get_tx_obj_size(priv, regs) * n;
-}
-
-static u16 mcp25xxfd_dump_get_tx_obj_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
-{
-	return mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, n) + MCP25XXFD_RAM_START;
-}
-
-static u8 mcp25xxfd_dump_get_tx_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return (regs->fifo[MCP25XXFD_TX_FIFO].ua -
-		mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, 0)) /
-		mcp25xxfd_dump_get_tx_obj_size(priv, regs);
-}
-
-static u8 mcp25xxfd_dump_get_tx_head(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP25XXFD_TX_FIFO].sta);
-}
-
-/* RX */
-
-static u8 mcp25xxfd_dump_get_rx_obj_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return sizeof(struct mcp25xxfd_hw_rx_obj_can) -
-		FIELD_SIZEOF(struct mcp25xxfd_hw_rx_obj_can, data) +
-		mcp25xxfd_dump_get_fifo_size(priv, regs, regs->rx_fifo.con);
-}
-
-static u8 mcp25xxfd_dump_get_rx_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->rx_fifo.con);
-}
-
-static u16 mcp25xxfd_dump_get_rx_obj_rel_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
-{
-	return mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, mcp25xxfd_dump_get_tx_obj_num(priv, regs)) +
-		mcp25xxfd_dump_get_rx_obj_size(priv, regs) * n;
-}
-
-static u16 mcp25xxfd_dump_get_rx_obj_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
-{
-	return mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, n) + MCP25XXFD_RAM_START;
-}
-
-static u8 mcp25xxfd_dump_get_rx_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return (regs->fifo[MCP25XXFD_RX_FIFO(0)].ua -
-		mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, 0)) /
-		mcp25xxfd_dump_get_rx_obj_size(priv, regs);
-}
-
-static u8 mcp25xxfd_dump_get_rx_head(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
-{
-	return FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP25XXFD_RX_FIFO(0)].sta);
-}
-
-/* dump TEF */
-
-static void mcp25xxfd_dump_ram_tef_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_tef_obj *hw_tef_obj, u8 n)
-{
-	pr_info("TEF Object: 0x%02x (0x%03x)%s%s%s%s%s\n",
-		n, mcp25xxfd_dump_get_tef_obj_addr(priv, n),
-		mcp25xxfd_get_tef_head(priv) == n ? "  priv-HEAD" : "",
-		mcp25xxfd_dump_get_tef_tail(priv, regs) == n ? "  chip-TAIL" : "",
-		mcp25xxfd_get_tef_tail(priv) == n ? "  priv-TAIL" : "",
-		(mcp25xxfd_dump_get_tef_tail(priv, regs) == n ?
-		 ((regs->tef.sta & MCP25XXFD_CAN_TEFSTA_TEFFIF) ? "  chip-FIFO-full" :
-		  !(regs->tef.sta & MCP25XXFD_CAN_TEFSTA_TEFNEIF) ? "  chip-FIFO-empty" : "") :
-		 ("")),
-		(mcp25xxfd_get_tef_head(priv) == mcp25xxfd_get_tef_tail(priv) &&
-		 mcp25xxfd_get_tef_tail(priv) == n ?
-		 (priv->tef.head == priv->tef.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
-		 ("")));
-	pr_info("%16s = 0x%08x\n", "id", hw_tef_obj->id);
-	pr_info("%16s = 0x%08x\n", "flags", hw_tef_obj->flags);
-	pr_info("%16s = 0x%08x\n", "ts", hw_tef_obj->ts);
-	__dump_mask(hw_tef_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ, "0x%06lx", "Sequence");
-	pr_info("\n");
-}
-
-static void mcp25xxfd_dump_ram_tef_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
-{
-	int i;
-
-	pr_info("\nTEF Overview:\n");
-	pr_info("%16s =        0x%02x    0x%08x\n", "head (p)", mcp25xxfd_get_tef_head(priv), priv->tef.head);
-	pr_info("%16s = 0x%02x   0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_tef_tail(priv, regs), mcp25xxfd_get_tef_tail(priv), priv->tef.tail);
-	pr_info("\n");
-
-	for (i = 0; i < mcp25xxfd_dump_get_tef_obj_num(priv, regs); i++) {
-		const struct mcp25xxfd_hw_tef_obj *hw_tef_obj;
-		u16 hw_tef_obj_rel_addr;
-
-		hw_tef_obj_rel_addr = mcp25xxfd_dump_get_tef_obj_rel_addr(priv, i);
-
-		hw_tef_obj = (const struct mcp25xxfd_hw_tef_obj *)&ram->ram[hw_tef_obj_rel_addr];
-		mcp25xxfd_dump_ram_tef_obj_one(priv, regs, hw_tef_obj, i);
-	}
-}
-
-/* dump TX */
-
-static void mcp25xxfd_dump_ram_tx_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_tx_obj_canfd *hw_tx_obj, u8 n)
-{
-	pr_info("TX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
-		n, mcp25xxfd_dump_get_tx_obj_addr(priv, regs, n),
-		mcp25xxfd_dump_get_tx_head(priv, regs) == n ? "  chip-HEAD" : "",
-		mcp25xxfd_get_tx_head(priv) == n ? "  priv-HEAD" : "",
-		mcp25xxfd_dump_get_tx_tail(priv, regs) == n ? "  chip-TAIL" : "",
-		mcp25xxfd_get_tx_tail(priv) == n ? "  priv-TAIL" : "",
-		mcp25xxfd_dump_get_tx_tail(priv, regs) == n ?
-		(!(regs->tx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-full" :
-		 (regs->tx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFERFFIF) ? "  chip-FIFO-empty" : "") :
-		(""),
-		(mcp25xxfd_get_tx_head(priv) == mcp25xxfd_get_tx_tail(priv) &&
-		 mcp25xxfd_get_tx_tail(priv) == n ?
-		 (priv->tx.head == priv->tx.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
-		 ("")));
-	pr_info("%16s = 0x%08x\n", "id", hw_tx_obj->id);
-	pr_info("%16s = 0x%08x\n", "flags", hw_tx_obj->flags);
-	__dump_mask(hw_tx_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ_MCP2517FD, "0x%06lx", "Sequence (MCP2517)");
-	__dump_mask(hw_tx_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ_MCP2518FD, "0x%06lx", "Sequence (MCP2518)");
-	mcp25xxfd_dump_ram_fifo_obj_data(priv, hw_tx_obj->data, FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_tx_obj->flags));
-	pr_info("\n");
-}
-
-static void mcp25xxfd_dump_ram_tx_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
-{
-	int i;
-
-	pr_info("\nTX Overview:\n");
-	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)", mcp25xxfd_dump_get_tx_head(priv, regs), mcp25xxfd_get_tx_head(priv), priv->tx.head);
-	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_tx_tail(priv, regs), mcp25xxfd_get_tx_tail(priv), priv->tx.tail);
-	pr_info("\n");
-
-	for (i = 0; i < mcp25xxfd_dump_get_tx_obj_num(priv, regs); i++) {
-		const struct mcp25xxfd_hw_tx_obj_canfd *hw_tx_obj;
-		u16 hw_tx_obj_rel_addr;
-
-		hw_tx_obj_rel_addr = mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, i);
-		hw_tx_obj = (const struct mcp25xxfd_hw_tx_obj_canfd *)&ram->ram[hw_tx_obj_rel_addr];
-
-		mcp25xxfd_dump_ram_tx_obj_one(priv, regs, hw_tx_obj, i);
-	}
-}
-
-/* dump RX */
-
-static void mcp25xxfd_dump_ram_rx_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj, u8 n)
-{
-	pr_info("RX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
-		n, mcp25xxfd_dump_get_rx_obj_addr(priv, regs, n),
-		mcp25xxfd_dump_get_rx_head(priv, regs) == n ? "  chip-HEAD" : "",
-		mcp25xxfd_get_rx_head(priv) == n ? "  priv-HEAD" : "",
-		mcp25xxfd_dump_get_rx_tail(priv, regs) == n ? "  chip-TAIL" : "",
-		mcp25xxfd_get_rx_tail(priv) == n ? "  priv-TAIL" : "",
-		mcp25xxfd_dump_get_rx_tail(priv, regs) == n ?
-		((regs->rx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFERFFIF) ? "  chip-FIFO-full" :
-		 !(regs->rx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-empty" : "") :
-		(""),
-		(mcp25xxfd_get_rx_head(priv) == mcp25xxfd_get_rx_tail(priv) &&
-		 mcp25xxfd_get_rx_tail(priv) == n ?
-		 (priv->rx.head == priv->rx.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
-		 ("")));
-	pr_info("%16s = 0x%08x\n", "id", hw_rx_obj->id);
-	pr_info("%16s = 0x%08x\n", "flags", hw_rx_obj->flags);
-	pr_info("%16s = 0x%08x\n", "ts", hw_rx_obj->ts);
-	mcp25xxfd_dump_ram_fifo_obj_data(priv, hw_rx_obj->data, FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_rx_obj->flags));
-	pr_info("\n");
-}
-
-static void mcp25xxfd_dump_ram_rx_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
-{
-	int i;
-
-	pr_info("\nRX Overview:\n");
-	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)", mcp25xxfd_dump_get_rx_head(priv, regs), mcp25xxfd_get_rx_head(priv), priv->rx.head);
-	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_rx_tail(priv, regs), mcp25xxfd_get_rx_tail(priv), priv->rx.tail);
-	pr_info("\n");
-
-	for (i = 0; i < mcp25xxfd_dump_get_rx_obj_num(priv, regs); i++) {
-		const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj;
-		u16 hw_rx_obj_rel_addr;
-
-		hw_rx_obj_rel_addr = mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, i);
-		hw_rx_obj = (const struct mcp25xxfd_hw_rx_obj_canfd *)&ram->ram[hw_rx_obj_rel_addr];
-
-		mcp25xxfd_dump_ram_rx_obj_one(priv, regs, hw_rx_obj, i);
-	}
-}
-
-#undef __dump_mask
-#undef __dump_bit
-
-static void mcp25xxfd_dump_ram(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
-{
-	netdev_info(priv->ndev, "----------------------- RAM dump ----------------------\n");
-	mcp25xxfd_dump_ram_tef_obj(priv, regs, ram);
-	mcp25xxfd_dump_ram_tx_obj(priv, regs, ram);
-	mcp25xxfd_dump_ram_rx_obj(priv, regs, ram);
-	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
-}
-
-void mcp25xxfd_dump(struct mcp25xxfd_priv *priv)
-{
-	struct mcp25xxfd_dump_regs *regs = &priv->dump.regs;
-	struct mcp25xxfd_dump_ram *ram = &priv->dump.ram;
-	struct mcp25xxfd_dump_regs_mcp25xxfd *regs_mcp25xxfd = &priv->dump.regs_mcp25xxfd;
-	int err;
-
-	BUILD_BUG_ON(sizeof(struct mcp25xxfd_dump_regs) !=
-		     MCP25XXFD_CAN_FIFOUA(31) - MCP25XXFD_CAN_CON + 4);
-
-	err = regmap_bulk_read(priv->map, MCP25XXFD_CAN_CON,
-			       regs, sizeof(*regs) / sizeof(u32));
-	if (err)
-		return;
-
-	err = regmap_bulk_read(priv->map, MCP25XXFD_RAM_START,
-			       ram, sizeof(*ram) / sizeof(u32));
-	if (err)
-		return;
-
-	err = regmap_bulk_read(priv->map, MCP25XXFD_OSC,
-			       regs_mcp25xxfd, sizeof(*regs_mcp25xxfd) / sizeof(u32));
-	if (err)
-		return;
-
-	mcp25xxfd_dump_regs(priv, regs, regs_mcp25xxfd);
-	mcp25xxfd_dump_ram(priv, regs, ram);
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
deleted file mode 100644
index d1a70513d5e4..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
+++ /dev/null
@@ -1,105 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
-//
-// Copyright (c) 2019 Pengutronix,
-//                    Marc Kleine-Budde <kernel@pengutronix.de>
-//
-
-#include "mcp25xxfd.h"
-#include "mcp25xxfd-log.h"
-
-struct mcp25xxfd_log *___mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
-{
-	struct mcp25xxfd_log *log;
-	int cnt;
-
-	cnt = atomic_add_return(1, &priv->cnt);
-	cnt &= ARRAY_SIZE(priv->log) - 1;
-
-	log = &priv->log[cnt];
-	log->func = func;
-	log->can_id = can_id;
-	log->tef_head = priv->tef.head;
-	log->tef_tail = priv->tef.tail;
-	log->tx_head = priv->tx.head;
-	log->tx_tail = priv->tx.tail;
-	log->flags = 0;
-
-	return log;
-}
-
-static void mcp25xxfd_log_dump_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_log *last_log, const struct mcp25xxfd_log *log, int n)
-{
-	pr_info("%04d: %30s: ",
-		n, log->func);
-
-	if (log->can_id != -1 &&
-	    last_log->can_id != log->can_id)
-		pr_cont("id=%03x ", log->can_id);
-	else
-		pr_cont(" ---   ");
-
-	if (last_log->tef_head != log->tef_head)
-		pr_cont("tef_h=%08x/%02x ", log->tef_head, log->tef_head & (priv->tx.obj_num - 1));
-	else
-		pr_cont("    ---           ");
-
-	if (log->hw_tx_ci != -1 &&
-	    last_log->hw_tx_ci != log->hw_tx_ci)
-		pr_cont("hw_tx_ci=%02x ", log->hw_tx_ci);
-	else
-		pr_cont("       ---  ");
-
-	if (last_log->tef_tail != log->tef_tail)
-		pr_cont("tef_t=%08x/%02x ", log->tef_tail, log->tef_tail & (priv->tx.obj_num - 1));
-	else
-		pr_cont("    ---           ");
-
-	if (log->hw_tef_tail != -1 &&
-	    last_log->hw_tef_tail != log->hw_tef_tail)
-		pr_cont("hw_tef_t=%02x ", log->hw_tef_tail);
-	else
-		pr_cont("       ---  ");
-
-	if (last_log->tx_head != log->tx_head)
-		pr_cont("tx_h=%08x/%02x ", log->tx_head, log->tx_head & (priv->tx.obj_num - 1));
-	else
-		pr_cont("   ---           ");
-
-	if (last_log->tx_tail != log->tx_tail)
-		pr_cont("tx_t=%08x/%02x ", log->tx_tail, log->tx_tail & (priv->tx.obj_num - 1));
-	else
-		pr_cont("   ---           ");
-
-	pr_cont("%s%s%s\n",
-		log->flags & MCP25XXFD_LOG_STOP ? "s" : " ",
-		log->flags & MCP25XXFD_LOG_WAKE ? "w" : " ",
-		log->flags & MCP25XXFD_LOG_BUSY ? "b" : " ");
-}
-
-void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv)
-{
-	int cnt;
-	int i, n = 0;
-
-	cnt = atomic_read(&priv->cnt);
-	cnt &= ARRAY_SIZE(priv->log) - 1;
-
-	i = cnt;
-
-	if (cnt == 0) {
-		mcp25xxfd_log_dump_one(priv, &priv->log[ARRAY_SIZE(priv->log) - 2], &priv->log[0], n++);
-		i++;
-	}
-
-	for (/* nix */; i < ARRAY_SIZE(priv->log); i++)
-		mcp25xxfd_log_dump_one(priv, &priv->log[i - 1], &priv->log[i], n++);
-
-	if (cnt) {
-		mcp25xxfd_log_dump_one(priv, &priv->log[ARRAY_SIZE(priv->log) - 2], &priv->log[0], n++);
-		if (cnt > 1)
-			for (i = 1; i < cnt; i++)
-				mcp25xxfd_log_dump_one(priv, &priv->log[i - 1], &priv->log[i], n++);
-	}
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
deleted file mode 100644
index cadb07780ee1..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
- *
- * Copyright (c) 2019 Pengutronix,
- *                    Marc Kleine-Budde <kernel@pengutronix.de>
- */
-
-#ifndef _MCP25XXFD_LOG_H
-#define _MCP25XXFD_LOG_H
-
-struct mcp25xxfd_priv;
-
-#ifdef CONFIG_CAN_MCP25XXFD_LOG
-
-struct mcp25xxfd_log {
-	const char *func;
-	canid_t can_id;
-	u32 tef_head;
-	u32 tef_tail;
-	u32 tx_head;
-	u32 tx_tail;
-
-#define MCP25XXFD_LOG_STOP BIT(0)
-#define MCP25XXFD_LOG_WAKE BIT(1)
-#define MCP25XXFD_LOG_BUSY BIT(2)
-	u32 flags;
-
-	u32 hw_tx_ci;
-	u32 hw_tef_tail;
-};
-
-struct mcp25xxfd_log *___mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id);
-void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv);
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
-{
-	struct mcp25xxfd_log *log;
-
-	log = ___mcp25xxfd_log(priv, func, can_id);
-	log->hw_tx_ci = -1;
-	log->hw_tef_tail = -1;
-
-	return log;
-}
-
-#define mcp25xxfd_log(priv, ...) __mcp25xxfd_log(priv, __func__, ## __VA_ARGS__)
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log_no_canid(struct mcp25xxfd_priv *priv, const char *func)
-{
-	struct mcp25xxfd_log *log;
-
-	log = __mcp25xxfd_log(priv, func, -1);
-	log->can_id = -1;
-
-	return log;
-}
-
-#define mcp25xxfd_log_no_canid(priv, ...) __mcp25xxfd_log_no_canid(priv, __func__, ## __VA_ARGS__)
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log_stop(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
-{
-	struct mcp25xxfd_log *log;
-
-	log = __mcp25xxfd_log(priv, func, can_id);
-	log->flags |= MCP25XXFD_LOG_STOP;
-
-	return log;
-}
-
-#define mcp25xxfd_log_stop(priv, ...) __mcp25xxfd_log_stop(priv, __func__, ## __VA_ARGS__)
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log_wake(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
-{
-	struct mcp25xxfd_log *log;
-
-	log = __mcp25xxfd_log(priv, func, can_id);
-	log->flags |= MCP25XXFD_LOG_WAKE;
-
-	return log;
-}
-
-#define mcp25xxfd_log_wake(priv, ...) __mcp25xxfd_log_wake(priv, __func__, ## __VA_ARGS__)
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log_busy(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
-{
-	struct mcp25xxfd_log *log;
-
-	log = __mcp25xxfd_log(priv, func, can_id);
-	log->flags |= MCP25XXFD_LOG_BUSY;
-
-	return log;
-}
-
-#define mcp25xxfd_log_busy(priv, ...) __mcp25xxfd_log_busy(priv, __func__, ## __VA_ARGS__)
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log_hw_tx_ci(struct mcp25xxfd_priv *priv, const char *func, u32 tx_ci)
-{
-	struct mcp25xxfd_log *log;
-
-	log = __mcp25xxfd_log_no_canid(priv, func);
-	log->hw_tx_ci = tx_ci;
-
-	return log;
-}
-
-#define mcp25xxfd_log_hw_tx_ci(priv, ...) __mcp25xxfd_log_hw_tx_ci(priv, __func__, ## __VA_ARGS__)
-
-static inline struct mcp25xxfd_log *__mcp25xxfd_log_hw_tef_tail(struct mcp25xxfd_priv *priv, const char *func, u32 tef_tail)
-{
-	struct mcp25xxfd_log *log;
-
-	log = __mcp25xxfd_log_no_canid(priv, func);
-	log->hw_tef_tail = tef_tail;
-
-	return log;
-}
-
-#define mcp25xxfd_log_hw_tef_tail(priv, ...) __mcp25xxfd_log_hw_tef_tail(priv, __func__, ## __VA_ARGS__)
-
-#else
-
-static inline void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv)
-{
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log(struct mcp25xxfd_priv *priv, canid_t can_id)
-{
-	return NULL;
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log_no_canid(struct mcp25xxfd_priv *priv)
-{
-	return NULL;
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log_stop(struct mcp25xxfd_priv *priv, canid_t can_id)
-{
-	return NULL;
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log_wake(struct mcp25xxfd_priv *priv, canid_t can_id)
-{
-	return NULL;
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log_busy(struct mcp25xxfd_priv *priv, canid_t can_id)
-{
-	return NULL;
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log_hw_tx_ci(struct mcp25xxfd_priv *priv, u32 tx_ci)
-{
-	return NULL;
-}
-
-static inline struct mcp25xxfd_log *mcp25xxfd_log_hw_tef_tail(struct mcp25xxfd_priv *priv, u32 tef_tail)
-{
-	return NULL;
-}
-
-#endif
-
-#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
deleted file mode 100644
index c2628653d48c..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
+++ /dev/null
@@ -1,268 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
-//
-// Copyright (c) 2019, 2020 Pengutronix,
-//                          Marc Kleine-Budde <kernel@pengutronix.de>
-//
-
-#include "mcp25xxfd.h"
-
-static int mcp25xxfd_regmap_write(void *context, const void *data, size_t count)
-{
-	struct spi_device *spi = context;
-
-	return spi_write(spi, data, count);
-}
-
-static int mcp25xxfd_regmap_gather_write(void *context,
-					 const void *reg, size_t reg_len,
-					 const void *val, size_t val_len)
-{
-	struct spi_device *spi = context;
-	struct spi_transfer xfer[] = {
-		{
-			.tx_buf = reg,
-			.len = reg_len,
-		}, {
-			.tx_buf = val,
-			.len = val_len,
-		},
-	};
-
-	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
-}
-
-static inline bool mcp25xxfd_update_bits_read_reg(unsigned int reg)
-{
-	switch (reg) {
-	case MCP25XXFD_CAN_INT:
-	case MCP25XXFD_CAN_TEFCON:
-	case MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)):
-	case MCP25XXFD_ECCSTAT:
-	case MCP25XXFD_CRC:
-		return false;
-	case MCP25XXFD_CAN_BDIAG1:
-	case MCP25XXFD_CAN_CON:
-	case MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_RX_FIFO(0)):
-	case MCP25XXFD_OSC:
-		return true;
-	default:
-		WARN(1, "Status of reg=%03x unknown.\n", reg);
-	}
-
-	return true;
-}
-
-static int mcp25xxfd_regmap_update_bits(void *context, unsigned int reg,
-					unsigned int mask, unsigned int val)
-
-{
-	struct spi_device *spi = context;
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	struct mcp25xxfd_reg_write_buf *buf = &priv->update_bits_buf;
-	__be16 cmd;
-	__le32 orig_le32 = 0, mask_le32, val_le32, tmp_le32;
-	u8 first_byte, last_byte, len;
-	int err;
-
-	first_byte = mcp25xxfd_first_byte_set(mask);
-	last_byte = mcp25xxfd_last_byte_set(mask);
-	len = last_byte - first_byte + 1;
-
-	if (mcp25xxfd_update_bits_read_reg(reg)) {
-		cmd = mcp25xxfd_cmd_read(reg + first_byte);
-		/* spi_write_then_read() works with non DMA-safe buffers */
-		err = spi_write_then_read(priv->spi,
-					  &cmd, sizeof(cmd), &orig_le32, len);
-
-		if (err)
-			return err;
-	}
-
-	mask_le32 = cpu_to_le32(mask >> 8 * first_byte);
-	val_le32 = cpu_to_le32(val >> 8 * first_byte);
-
-	tmp_le32 = orig_le32 & ~mask_le32;
-	tmp_le32 |= val_le32 & mask_le32;
-
-	buf->cmd = mcp25xxfd_cmd_write(reg + first_byte);
-	memcpy(buf->data, &tmp_le32, len);
-
-	return spi_write(spi, buf, sizeof(buf->cmd) + len);
-}
-
-static int mcp25xxfd_regmap_read(void *context,
-				 const void *reg, size_t reg_len,
-				 void *val_buf, size_t val_len)
-{
-	struct spi_device *spi = context;
-	struct spi_transfer xfer[] = {
-		{
-			.tx_buf = reg,
-			.len = reg_len,
-		}, {
-			.rx_buf = val_buf,
-			.len = val_len,
-		},
-	};
-
-	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
-}
-
-static int mcp25xxfd_regmap_crc_gather_write(void *context,
-					     const void *reg, size_t reg_len,
-					     const void *val, size_t val_len)
-{
-	struct spi_device *spi = context;
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	struct spi_transfer xfer[] = {
-		{
-			.tx_buf = &priv->crc_buf.addr,
-			.len = sizeof(priv->crc_buf.addr),
-		}, {
-			.tx_buf = val,
-			.len = val_len,
-		}, {
-			.rx_buf = &priv->crc_buf.crc,
-			.len = sizeof(priv->crc_buf.crc),
-		},
-	};
-	u16 crc;
-
-	priv->crc_buf.addr.cmd = *(__be16 *)reg;
-	priv->crc_buf.addr.len = val_len;
-
-	crc = mcp25xxfd_crc16_compute(xfer[0].tx_buf, xfer[0].len,
-				      xfer[1].rx_buf, xfer[1].len);
-	priv->crc_buf.crc = cpu_to_be16(crc);
-
-	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
-}
-
-static int mcp25xxfd_regmap_crc_write(void *context,
-				      const void *data, size_t count)
-{
-	struct spi_device *spi = context;
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-
-	return mcp25xxfd_regmap_crc_gather_write(context, data,
-						 sizeof(priv->crc_buf.addr),
-						 data + 4, count - 4);
-}
-
-static int mcp25xxfd_regmap_crc_read(void *context,
-				     const void *reg, size_t reg_len,
-				     void *val_buf, size_t val_len)
-{
-	struct spi_device *spi = context;
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	struct spi_transfer xfer[] = {
-		{
-			.tx_buf = &priv->crc_buf.addr,
-			.len = sizeof(priv->crc_buf.addr),
-		}, {
-			.rx_buf = val_buf,
-			.len = val_len,
-		}, {
-			.rx_buf = &priv->crc_buf.crc,
-			.len = sizeof(priv->crc_buf.crc),
-		},
-	};
-	u16 crc_received, crc_calculated;
-	int err;
-
-	priv->crc_buf.addr.cmd = *(__be16 *)reg;
-	priv->crc_buf.addr.len = val_len;
-
-	err = spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
-	if (err)
-		return err;
-
-	crc_received = be16_to_cpu(priv->crc_buf.crc);
-	crc_calculated = mcp25xxfd_crc16_compute(xfer[0].tx_buf, xfer[0].len,
-						 xfer[1].rx_buf, xfer[1].len);
-	if (crc_received != crc_calculated) {
-		__dump(xfer[0].tx_buf, xfer[0].len);
-		__dump(xfer[1].rx_buf, xfer[1].len);
-		__dump(&crc_received, sizeof(crc_received));
-		__dump(&crc_calculated, sizeof(crc_calculated));
-		return -EBADMSG;
-	}
-
-	return 0;
-}
-
-static const struct regmap_range mcp25xxfd_reg_table_yes_range[] = {
-	regmap_reg_range(0x000, 0x2ec),	/* CAN FD Controller Module SFR */
-	regmap_reg_range(0x400, 0xbfc),	/* RAM */
-	regmap_reg_range(0xe00, 0xe14),	/* MCP2517/18FD SFR */
-};
-
-static const struct regmap_access_table mcp25xxfd_reg_table = {
-	.yes_ranges = mcp25xxfd_reg_table_yes_range,
-	.n_yes_ranges = ARRAY_SIZE(mcp25xxfd_reg_table_yes_range),
-};
-
-static const struct regmap_config mcp25xxfd_regmap = {
-	.reg_bits = 16,
-	.reg_stride = 4,
-	.pad_bits = 0,
-	.val_bits = 32,
-	.max_register = 0xffc,
-	.wr_table = &mcp25xxfd_reg_table,
-	.rd_table = &mcp25xxfd_reg_table,
-	.cache_type = REGCACHE_NONE,
-	.read_flag_mask = (__force unsigned long)
-		cpu_to_be16(MCP25XXFD_INSTRUCTION_READ),
-	.write_flag_mask = (__force unsigned long)
-		cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE),
-};
-
-static const struct regmap_bus mcp25xxfd_bus = {
-	.write = mcp25xxfd_regmap_write,
-	.gather_write = mcp25xxfd_regmap_gather_write,
-	.reg_update_bits = mcp25xxfd_regmap_update_bits,
-	.read = mcp25xxfd_regmap_read,
-	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
-	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
-};
-
-static const struct regmap_config mcp25xxfd_regmap_crc = {
-	.name = "crc",
-	.reg_bits = 16,
-	.reg_stride = 4,
-	.pad_bits = 16,		/* keep data bits aligned */
-	.val_bits = 32,
-	.max_register = 0xffc,
-	.wr_table = &mcp25xxfd_reg_table,
-	.rd_table = &mcp25xxfd_reg_table,
-	.cache_type = REGCACHE_NONE,
-	.read_flag_mask = (__force unsigned long)
-		cpu_to_be16(MCP25XXFD_INSTRUCTION_READ_CRC),
-	.write_flag_mask = (__force unsigned long)
-		cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE_CRC),
-};
-
-static const struct regmap_bus mcp25xxfd_bus_crc = {
-	.write = mcp25xxfd_regmap_crc_write,
-	.gather_write = mcp25xxfd_regmap_crc_gather_write,
-	.read = mcp25xxfd_regmap_crc_read,
-	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
-	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
-	.max_raw_read = 256 - 4,
-	.max_raw_write = 256 - 4,
-};
-
-int mcp25xxfd_regmap_init(struct mcp25xxfd_priv *priv)
-{
-	priv->map = devm_regmap_init(&priv->spi->dev, &mcp25xxfd_bus,
-				     priv->spi, &mcp25xxfd_regmap);
-	if (IS_ERR(priv->map))
-		return PTR_ERR(priv->map);
-
-	priv->map_crc = devm_regmap_init(&priv->spi->dev, &mcp25xxfd_bus_crc,
-					 priv->spi, &mcp25xxfd_regmap_crc);
-	return PTR_ERR_OR_ZERO(priv->map_crc);
-
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
deleted file mode 100644
index 119cdbdbe9d2..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
+++ /dev/null
@@ -1,757 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
- *
- * Copyright (c) 2019 Pengutronix,
- *                    Marc Kleine-Budde <kernel@pengutronix.de>
- * Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef _MCP25XXFD_H
-#define _MCP25XXFD_H
-
-#include <linux/can/core.h>
-#include <linux/can/dev.h>
-#include <linux/can/rx-offload.h>
-#include <linux/gpio/consumer.h>
-#include <linux/kernel.h>
-#include <linux/regmap.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd-log.h"
-
-static inline void __dump(const void *d, unsigned int len)
-{
-	const u8 *data = d;
-	unsigned int i;
-
-	for (i = 0; i < len; i++) {
-		if ((i % 8) == 0) {
-			if (i == 0)
-				pr_info("%16s = %02x", "data", data[i]);
-			else
-				pr_info("                   %02x", data[i]);
-		} else if ((i % 4) == 0) {
-			pr_cont("  %02x", data[i]);
-		} else if ((i % 8) == 7) {
-			pr_cont(" %02x\n", data[i]);
-		} else {
-			pr_cont(" %02x", data[i]);
-		}
-	}
-
-	if (i % 8)
-		pr_cont("\n");
-}
-
-/* MPC25xx registers */
-
-/* CAN FD Controller Module SFR */
-#define MCP25XXFD_CAN_CON 0x00
-#define MCP25XXFD_CAN_CON_TXBWS_MASK GENMASK(31, 28)
-#define MCP25XXFD_CAN_CON_ABAT BIT(27)
-#define MCP25XXFD_CAN_CON_REQOP_MASK GENMASK(26, 24)
-#define MCP25XXFD_CAN_CON_MODE_MIXED 0
-#define MCP25XXFD_CAN_CON_MODE_SLEEP 1
-#define MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK 2
-#define MCP25XXFD_CAN_CON_MODE_LISTENONLY 3
-#define MCP25XXFD_CAN_CON_MODE_CONFIG 4
-#define MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK 5
-#define MCP25XXFD_CAN_CON_MODE_CAN2_0 6
-#define MCP25XXFD_CAN_CON_MODE_RESTRICTED 7
-#define MCP25XXFD_CAN_CON_OPMOD_MASK GENMASK(23, 21)
-#define MCP25XXFD_CAN_CON_TXQEN BIT(20)
-#define MCP25XXFD_CAN_CON_STEF BIT(19)
-#define MCP25XXFD_CAN_CON_SERR2LOM BIT(18)
-#define MCP25XXFD_CAN_CON_ESIGM BIT(17)
-#define MCP25XXFD_CAN_CON_RTXAT BIT(16)
-#define MCP25XXFD_CAN_CON_BRSDIS BIT(12)
-#define MCP25XXFD_CAN_CON_BUSY BIT(11)
-#define MCP25XXFD_CAN_CON_WFT_MASK GENMASK(10, 9)
-#define MCP25XXFD_CAN_CON_WFT_T00FILTER 0x0
-#define MCP25XXFD_CAN_CON_WFT_T01FILTER 0x1
-#define MCP25XXFD_CAN_CON_WFT_T10FILTER 0x2
-#define MCP25XXFD_CAN_CON_WFT_T11FILTER 0x3
-#define MCP25XXFD_CAN_CON_WAKFIL BIT(8)
-#define MCP25XXFD_CAN_CON_PXEDIS BIT(6)
-#define MCP25XXFD_CAN_CON_ISOCRCEN BIT(5)
-#define MCP25XXFD_CAN_CON_DNCNT_MASK GENMASK(4, 0)
-
-#define MCP25XXFD_CAN_NBTCFG 0x04
-#define MCP25XXFD_CAN_NBTCFG_BRP_MASK GENMASK(31, 24)
-#define MCP25XXFD_CAN_NBTCFG_TSEG1_MASK GENMASK(23, 16)
-#define MCP25XXFD_CAN_NBTCFG_TSEG2_MASK GENMASK(14, 8)
-#define MCP25XXFD_CAN_NBTCFG_SJW_MASK GENMASK(6, 0)
-
-#define MCP25XXFD_CAN_DBTCFG 0x08
-#define MCP25XXFD_CAN_DBTCFG_BRP_MASK GENMASK(31, 24)
-#define MCP25XXFD_CAN_DBTCFG_TSEG1_MASK GENMASK(20, 16)
-#define MCP25XXFD_CAN_DBTCFG_TSEG2_MASK GENMASK(11, 8)
-#define MCP25XXFD_CAN_DBTCFG_SJW_MASK GENMASK(3, 0)
-
-#define MCP25XXFD_CAN_TDC 0x0c
-#define MCP25XXFD_CAN_TDC_EDGFLTEN BIT(25)
-#define MCP25XXFD_CAN_TDC_SID11EN BIT(24)
-#define MCP25XXFD_CAN_TDC_TDCMOD_MASK GENMASK(17, 16)
-#define MCP25XXFD_CAN_TDC_TDCMOD_AUTO 2
-#define MCP25XXFD_CAN_TDC_TDCMOD_MANUAL 1
-#define MCP25XXFD_CAN_TDC_TDCMOD_DISABLED 0
-#define MCP25XXFD_CAN_TDC_TDCO_MASK GENMASK(14, 8)
-#define MCP25XXFD_CAN_TDC_TDCV_MASK GENMASK(5, 0)
-
-#define MCP25XXFD_CAN_TBC 0x10
-
-#define MCP25XXFD_CAN_TSCON 0x14
-#define MCP25XXFD_CAN_TSCON_TSRES BIT(18)
-#define MCP25XXFD_CAN_TSCON_TSEOF BIT(17)
-#define MCP25XXFD_CAN_TSCON_TBCEN BIT(16)
-#define MCP25XXFD_CAN_TSCON_TBCPRE_MASK GENMASK(9, 0)
-
-#define MCP25XXFD_CAN_VEC 0x18
-#define MCP25XXFD_CAN_VEC_RXCODE_MASK GENMASK(30, 24)
-#define MCP25XXFD_CAN_VEC_TXCODE_MASK GENMASK(22, 16)
-#define MCP25XXFD_CAN_VEC_FILHIT_MASK GENMASK(12, 8)
-#define MCP25XXFD_CAN_VEC_ICODE_MASK GENMASK(6, 0)
-
-#define MCP25XXFD_CAN_INT 0x1c
-#define MCP25XXFD_CAN_INT_IF_MASK GENMASK(15, 0)
-#define MCP25XXFD_CAN_INT_IE_MASK GENMASK(31, 16)
-#define MCP25XXFD_CAN_INT_IVMIE BIT(31)
-#define MCP25XXFD_CAN_INT_WAKIE BIT(30)
-#define MCP25XXFD_CAN_INT_CERRIE BIT(29)
-#define MCP25XXFD_CAN_INT_SERRIE BIT(28)
-#define MCP25XXFD_CAN_INT_RXOVIE BIT(27)
-#define MCP25XXFD_CAN_INT_TXATIE BIT(26)
-#define MCP25XXFD_CAN_INT_SPICRCIE BIT(25)
-#define MCP25XXFD_CAN_INT_ECCIE BIT(24)
-#define MCP25XXFD_CAN_INT_TEFIE BIT(20)
-#define MCP25XXFD_CAN_INT_MODIE BIT(19)
-#define MCP25XXFD_CAN_INT_TBCIE BIT(18)
-#define MCP25XXFD_CAN_INT_RXIE BIT(17)
-#define MCP25XXFD_CAN_INT_TXIE BIT(16)
-#define MCP25XXFD_CAN_INT_IVMIF BIT(15)
-#define MCP25XXFD_CAN_INT_WAKIF BIT(14)
-#define MCP25XXFD_CAN_INT_CERRIF BIT(13)
-#define MCP25XXFD_CAN_INT_SERRIF BIT(12)
-#define MCP25XXFD_CAN_INT_RXOVIF BIT(11)
-#define MCP25XXFD_CAN_INT_TXATIF BIT(10)
-#define MCP25XXFD_CAN_INT_SPICRCIF BIT(9)
-#define MCP25XXFD_CAN_INT_ECCIF BIT(8)
-#define MCP25XXFD_CAN_INT_TEFIF BIT(4)
-#define MCP25XXFD_CAN_INT_MODIF BIT(3)
-#define MCP25XXFD_CAN_INT_TBCIF BIT(2)
-#define MCP25XXFD_CAN_INT_RXIF BIT(1)
-#define MCP25XXFD_CAN_INT_TXIF BIT(0)
-/* These IRQ flags must be cleared by SW in the CAN_INT register */
-#define MCP25XXFD_CAN_INT_IF_CLEARABLE_MASK \
-	(MCP25XXFD_CAN_INT_IVMIF | MCP25XXFD_CAN_INT_WAKIF | \
-	 MCP25XXFD_CAN_INT_CERRIF |  MCP25XXFD_CAN_INT_SERRIF | \
-	 MCP25XXFD_CAN_INT_MODIF)
-
-#define MCP25XXFD_CAN_RXIF 0x20
-#define MCP25XXFD_CAN_TXIF 0x24
-#define MCP25XXFD_CAN_RXOVIF 0x28
-#define MCP25XXFD_CAN_TXATIF 0x2c
-#define MCP25XXFD_CAN_TXREQ 0x30
-
-#define MCP25XXFD_CAN_TREC 0x34
-#define MCP25XXFD_CAN_TREC_TXBO BIT(21)
-#define MCP25XXFD_CAN_TREC_TXBP BIT(20)
-#define MCP25XXFD_CAN_TREC_RXBP BIT(19)
-#define MCP25XXFD_CAN_TREC_TXWARN BIT(18)
-#define MCP25XXFD_CAN_TREC_RXWARN BIT(17)
-#define MCP25XXFD_CAN_TREC_EWARN BIT(16)
-#define MCP25XXFD_CAN_TREC_TEC_MASK GENMASK(15, 8)
-#define MCP25XXFD_CAN_TREC_REC_MASK GENMASK(7, 0)
-
-#define MCP25XXFD_CAN_BDIAG0 0x38
-#define MCP25XXFD_CAN_BDIAG0_DTERRCNT_MASK GENMASK(31, 24)
-#define MCP25XXFD_CAN_BDIAG0_DRERRCNT_MASK GENMASK(23, 16)
-#define MCP25XXFD_CAN_BDIAG0_NTERRCNT_MASK GENMASK(15, 8)
-#define MCP25XXFD_CAN_BDIAG0_NRERRCNT_MASK GENMASK(7, 0)
-
-#define MCP25XXFD_CAN_BDIAG1 0x3c
-#define MCP25XXFD_CAN_BDIAG1_DLCMM BIT(31)
-#define MCP25XXFD_CAN_BDIAG1_ESI BIT(30)
-#define MCP25XXFD_CAN_BDIAG1_DCRCERR BIT(29)
-#define MCP25XXFD_CAN_BDIAG1_DSTUFERR BIT(28)
-#define MCP25XXFD_CAN_BDIAG1_DFORMERR BIT(27)
-#define MCP25XXFD_CAN_BDIAG1_DBIT1ERR BIT(25)
-#define MCP25XXFD_CAN_BDIAG1_DBIT0ERR BIT(24)
-#define MCP25XXFD_CAN_BDIAG1_TXBOERR BIT(23)
-#define MCP25XXFD_CAN_BDIAG1_NCRCERR BIT(21)
-#define MCP25XXFD_CAN_BDIAG1_NSTUFERR BIT(20)
-#define MCP25XXFD_CAN_BDIAG1_NFORMERR BIT(19)
-#define MCP25XXFD_CAN_BDIAG1_NACKERR BIT(18)
-#define MCP25XXFD_CAN_BDIAG1_NBIT1ERR BIT(17)
-#define MCP25XXFD_CAN_BDIAG1_NBIT0ERR BIT(16)
-#define MCP25XXFD_CAN_BDIAG1_BERR_MASK \
-	(MCP25XXFD_CAN_BDIAG1_DLCMM | MCP25XXFD_CAN_BDIAG1_ESI | \
-	 MCP25XXFD_CAN_BDIAG1_DCRCERR | MCP25XXFD_CAN_BDIAG1_DSTUFERR | \
-	 MCP25XXFD_CAN_BDIAG1_DFORMERR | MCP25XXFD_CAN_BDIAG1_DBIT1ERR | \
-	 MCP25XXFD_CAN_BDIAG1_DBIT0ERR | MCP25XXFD_CAN_BDIAG1_TXBOERR | \
-	 MCP25XXFD_CAN_BDIAG1_NCRCERR | MCP25XXFD_CAN_BDIAG1_NSTUFERR | \
-	 MCP25XXFD_CAN_BDIAG1_NFORMERR | MCP25XXFD_CAN_BDIAG1_NACKERR | \
-	 MCP25XXFD_CAN_BDIAG1_NBIT1ERR | MCP25XXFD_CAN_BDIAG1_NBIT0ERR)
-#define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_MASK GENMASK(15, 0)
-
-#define MCP25XXFD_CAN_TEFCON 0x40
-#define MCP25XXFD_CAN_TEFCON_FSIZE_MASK GENMASK(28, 24)
-#define MCP25XXFD_CAN_TEFCON_FRESET BIT(10)
-#define MCP25XXFD_CAN_TEFCON_UINC BIT(8)
-#define MCP25XXFD_CAN_TEFCON_TEFTSEN BIT(5)
-#define MCP25XXFD_CAN_TEFCON_TEFOVIE BIT(3)
-#define MCP25XXFD_CAN_TEFCON_TEFFIE BIT(2)
-#define MCP25XXFD_CAN_TEFCON_TEFHIE BIT(1)
-#define MCP25XXFD_CAN_TEFCON_TEFNEIE BIT(0)
-
-#define MCP25XXFD_CAN_TEFSTA 0x44
-#define MCP25XXFD_CAN_TEFSTA_TEFOVIF BIT(3)
-#define MCP25XXFD_CAN_TEFSTA_TEFFIF BIT(2)
-#define MCP25XXFD_CAN_TEFSTA_TEFHIF BIT(1)
-#define MCP25XXFD_CAN_TEFSTA_TEFNEIF BIT(0)
-
-#define MCP25XXFD_CAN_TEFUA 0x48
-
-#define MCP25XXFD_CAN_TXQCON 0x50
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_MASK GENMASK(31, 29)
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_8 0
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_12 1
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_16 2
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_20 3
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_24 4
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_32 5
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_48 6
-#define MCP25XXFD_CAN_TXQCON_PLSIZE_64 7
-#define MCP25XXFD_CAN_TXQCON_FSIZE_MASK GENMASK(28, 24)
-#define MCP25XXFD_CAN_TXQCON_TXAT_UNLIMITED 3
-#define MCP25XXFD_CAN_TXQCON_TXAT_THREE_SHOT 1
-#define MCP25XXFD_CAN_TXQCON_TXAT_ONE_SHOT 0
-#define MCP25XXFD_CAN_TXQCON_TXAT_MASK GENMASK(22, 21)
-#define MCP25XXFD_CAN_TXQCON_TXPRI_MASK GENMASK(20, 16)
-#define MCP25XXFD_CAN_TXQCON_FRESET BIT(10)
-#define MCP25XXFD_CAN_TXQCON_TXREQ BIT(9)
-#define MCP25XXFD_CAN_TXQCON_UINC BIT(8)
-#define MCP25XXFD_CAN_TXQCON_TXEN BIT(7)
-#define MCP25XXFD_CAN_TXQCON_TXATIE BIT(4)
-#define MCP25XXFD_CAN_TXQCON_TXQEIE BIT(2)
-#define MCP25XXFD_CAN_TXQCON_TXQNIE BIT(0)
-
-#define MCP25XXFD_CAN_TXQSTA 0x54
-#define MCP25XXFD_CAN_TXQSTA_TXQCI_MASK GENMASK(12, 8)
-#define MCP25XXFD_CAN_TXQSTA_TXABT BIT(7)
-#define MCP25XXFD_CAN_TXQSTA_TXLARB BIT(6)
-#define MCP25XXFD_CAN_TXQSTA_TXERR BIT(5)
-#define MCP25XXFD_CAN_TXQSTA_TXATIF BIT(4)
-#define MCP25XXFD_CAN_TXQSTA_TXQEIF BIT(2)
-#define MCP25XXFD_CAN_TXQSTA_TXQNIF BIT(0)
-
-#define MCP25XXFD_CAN_TXQUA 0x58
-
-#define MCP25XXFD_CAN_FIFOCON(x) (0x50 + 0xc * (x))
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK GENMASK(31, 29)
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_8 0
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_12 1
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_16 2
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_20 3
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_24 4
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_32 5
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_48 6
-#define MCP25XXFD_CAN_FIFOCON_PLSIZE_64 7
-#define MCP25XXFD_CAN_FIFOCON_FSIZE_MASK GENMASK(28, 24)
-#define MCP25XXFD_CAN_FIFOCON_TXAT_MASK GENMASK(22, 21)
-#define MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT 0
-#define MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT 1
-#define MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED 3
-#define MCP25XXFD_CAN_FIFOCON_TXPRI_MASK GENMASK(20, 16)
-#define MCP25XXFD_CAN_FIFOCON_FRESET BIT(10)
-#define MCP25XXFD_CAN_FIFOCON_TXREQ BIT(9)
-#define MCP25XXFD_CAN_FIFOCON_UINC BIT(8)
-#define MCP25XXFD_CAN_FIFOCON_TXEN BIT(7)
-#define MCP25XXFD_CAN_FIFOCON_RTREN BIT(6)
-#define MCP25XXFD_CAN_FIFOCON_RXTSEN BIT(5)
-#define MCP25XXFD_CAN_FIFOCON_TXATIE BIT(4)
-#define MCP25XXFD_CAN_FIFOCON_RXOVIE BIT(3)
-#define MCP25XXFD_CAN_FIFOCON_TFERFFIE BIT(2)
-#define MCP25XXFD_CAN_FIFOCON_TFHRFHIE BIT(1)
-#define MCP25XXFD_CAN_FIFOCON_TFNRFNIE BIT(0)
-
-#define MCP25XXFD_CAN_FIFOSTA(x) (0x54 + 0xc * (x))
-#define MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK GENMASK(12, 8)
-#define MCP25XXFD_CAN_FIFOSTA_TXABT BIT(7)
-#define MCP25XXFD_CAN_FIFOSTA_TXLARB BIT(6)
-#define MCP25XXFD_CAN_FIFOSTA_TXERR BIT(5)
-#define MCP25XXFD_CAN_FIFOSTA_TXATIF BIT(4)
-#define MCP25XXFD_CAN_FIFOSTA_RXOVIF BIT(3)
-#define MCP25XXFD_CAN_FIFOSTA_TFERFFIF BIT(2)
-#define MCP25XXFD_CAN_FIFOSTA_TFHRFHIF BIT(1)
-#define MCP25XXFD_CAN_FIFOSTA_TFNRFNIF BIT(0)
-
-#define MCP25XXFD_CAN_FIFOUA(x) (0x58 + 0xc * (x))
-
-#define MCP25XXFD_CAN_FLTCON(x) (0x1d0 + (x))
-#define MCP25XXFD_CAN_FLTCON_FLTEN3 BIT(31)
-#define MCP25XXFD_CAN_FLTCON_F3BP_MASK GENMASK(28, 24)
-#define MCP25XXFD_CAN_FLTCON_FLTEN2 BIT(23)
-#define MCP25XXFD_CAN_FLTCON_F2BP_MASK GENMASK(20, 16)
-#define MCP25XXFD_CAN_FLTCON_FLTEN1 BIT(15)
-#define MCP25XXFD_CAN_FLTCON_F1BP_MASK GENMASK(12, 8)
-#define MCP25XXFD_CAN_FLTCON_FLTEN0 BIT(7)
-#define MCP25XXFD_CAN_FLTCON_F0BP_MASK GENMASK(4, 0)
-
-#define MCP25XXFD_CAN_FLTOBJ(x) (0x1f0 + 8 * (x))
-#define MCP25XXFD_CAN_FLTOBJ_EXIDE BIT(30)
-#define MCP25XXFD_CAN_FLTOBJ_SID11 BIT(29)
-#define MCP25XXFD_CAN_FLTOBJ_EID_MASK GENMASK(28, 11)
-#define MCP25XXFD_CAN_FLTOBJ_SID_MASK GENMASK(10, 0)
-
-#define MCP25XXFD_CAN_FLTMASK(x) (0x1f4 + 8 * (x))
-#define MCP25XXFD_CAN_MASK_MIDE BIT(30)
-#define MCP25XXFD_CAN_MASK_MSID11 BIT(29)
-#define MCP25XXFD_CAN_MASK_MEID_MASK GENMASK(28, 11)
-#define MCP25XXFD_CAN_MASK_MSID_MASK GENMASK(10, 0)
-
-/* RAM */
-#define MCP25XXFD_RAM_SIZE 2048
-#define MCP25XXFD_RAM_START 0x400
-
-/* Message Object */
-#define MCP25XXFD_OBJ_ID_SID11 BIT(29)
-#define MCP25XXFD_OBJ_ID_EID_MASK GENMASK(28, 11)
-#define MCP25XXFD_OBJ_ID_SID_MASK GENMASK(10, 0)
-#define MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK GENMASK(31, 9)
-#define MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK GENMASK(15, 9)
-#define MCP25XXFD_OBJ_FLAGS_SEQ_MASK MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK
-#define MCP25XXFD_OBJ_FLAGS_ESI BIT(8)
-#define MCP25XXFD_OBJ_FLAGS_FDF BIT(7)
-#define MCP25XXFD_OBJ_FLAGS_BRS BIT(6)
-#define MCP25XXFD_OBJ_FLAGS_RTR BIT(5)
-#define MCP25XXFD_OBJ_FLAGS_IDE BIT(4)
-#define MCP25XXFD_OBJ_FLAGS_DLC GENMASK(3, 0)
-
-#define MCP25XXFD_CAN_FRAME_EFF_SID_MASK GENMASK(28, 18)
-#define MCP25XXFD_CAN_FRAME_EFF_EID_MASK GENMASK(17, 0)
-
-/* MCP2517/18FD SFR */
-#define MCP25XXFD_OSC 0xe00
-#define MCP25XXFD_OSC_SCLKRDY BIT(12)
-#define MCP25XXFD_OSC_OSCRDY BIT(10)
-#define MCP25XXFD_OSC_PLLRDY BIT(8)
-#define MCP25XXFD_OSC_CLKODIV_10 3
-#define MCP25XXFD_OSC_CLKODIV_4 2
-#define MCP25XXFD_OSC_CLKODIV_2 1
-#define MCP25XXFD_OSC_CLKODIV_1 0
-#define MCP25XXFD_OSC_CLKODIV_MASK GENMASK(6, 5)
-#define MCP25XXFD_OSC_SCLKDIV BIT(4)
-#define MCP25XXFD_OSC_LPMEN BIT(3)	/* MCP2518FD only */
-#define MCP25XXFD_OSC_OSCDIS BIT(2)
-#define MCP25XXFD_OSC_PLLEN BIT(0)
-
-#define MCP25XXFD_IOCON 0xe04
-#define MCP25XXFD_IOCON_INTOD BIT(30)
-#define MCP25XXFD_IOCON_SOF BIT(29)
-#define MCP25XXFD_IOCON_TXCANOD BIT(28)
-#define MCP25XXFD_IOCON_PM1 BIT(25)
-#define MCP25XXFD_IOCON_PM0 BIT(24)
-#define MCP25XXFD_IOCON_GPIO1 BIT(17)
-#define MCP25XXFD_IOCON_GPIO0 BIT(16)
-#define MCP25XXFD_IOCON_LAT1 BIT(9)
-#define MCP25XXFD_IOCON_LAT0 BIT(8)
-#define MCP25XXFD_IOCON_XSTBYEN BIT(6)
-#define MCP25XXFD_IOCON_TRIS1 BIT(1)
-#define MCP25XXFD_IOCON_TRIS0 BIT(0)
-
-#define MCP25XXFD_CRC 0xe08
-#define MCP25XXFD_CRC_FERRIE BIT(25)
-#define MCP25XXFD_CRC_CRCERRIE BIT(24)
-#define MCP25XXFD_CRC_FERRIF BIT(17)
-#define MCP25XXFD_CRC_CRCERRIF BIT(16)
-#define MCP25XXFD_CRC_IF_MASK GENMASK(17, 16)
-#define MCP25XXFD_CRC_MASK GENMASK(15, 0)
-
-#define MCP25XXFD_ECCCON 0xe0c
-#define MCP25XXFD_ECCCON_PARITY_MASK GENMASK(14, 8)
-#define MCP25XXFD_ECCCON_DEDIE BIT(2)
-#define MCP25XXFD_ECCCON_SECIE BIT(1)
-#define MCP25XXFD_ECCCON_ECCEN BIT(0)
-
-#define MCP25XXFD_ECCSTAT 0xe10
-#define MCP25XXFD_ECCSTAT_ERRADDR_MASK GENMASK(27, 16)
-#define MCP25XXFD_ECCSTAT_IF_MASK GENMASK(2, 1)
-#define MCP25XXFD_ECCSTAT_DEDIF BIT(2)
-#define MCP25XXFD_ECCSTAT_SECIF BIT(1)
-
-#define MCP25XXFD_DEVID 0xe14	/* MCP2518FD only */
-#define MCP25XXFD_DEVID_ID_MASK GENMASK(7, 4)
-#define MCP25XXFD_DEVID_REV_MASK GENMASK(3, 0)
-
-/* number of TX FIFO objects, depending on CAN mode
- *
- * FIFO setup: tef: 8*12 bytes = 96 bytes, tx: 8*16 bytes = 128, rx: 32*20 bytes =  640 bytes, free: 1184 bytes.
- * FIFO setup: tef: 4*12 bytes = 48 bytes, tx: 4*72 bytes = 288, rx: 22*76 bytes = 1672 bytes, free:   40 bytes.
- */
-#define MCP25XXFD_TX_OBJ_NUM_CAN 8
-#define MCP25XXFD_TX_OBJ_NUM_CANFD 4
-
-#if MCP25XXFD_TX_OBJ_NUM_CAN > MCP25XXFD_TX_OBJ_NUM_CANFD
-#define MCP25XXFD_TX_OBJ_NUM_MAX MCP25XXFD_TX_OBJ_NUM_CAN
-#else
-#define MCP25XXFD_TX_OBJ_NUM_MAX MCP25XXFD_TX_OBJ_NUM_CANFD
-#endif
-
-/* The actual number of RX objects is calculated in
- * mcp25xxfd_chip_fifo_compute(), but we allocate memory
- * beforehand.
- */
-#define MCP25XXFD_RX_OBJ_NUM_CAN 32
-#define MCP25XXFD_RX_OBJ_NUM_CANFD 22
-
-#define MCP25XXFD_NAPI_WEIGHT 32
-#define MCP25XXFD_TX_FIFO 1
-#define MCP25XXFD_RX_FIFO(x) (MCP25XXFD_TX_FIFO + 1 + (x))
-#define MCP25XXFD_RX_FIFO_NUM (1)
-
-/* SPI commands */
-#define MCP25XXFD_INSTRUCTION_RESET 0x0000
-#define MCP25XXFD_INSTRUCTION_WRITE 0x2000
-#define MCP25XXFD_INSTRUCTION_READ 0x3000
-#define MCP25XXFD_INSTRUCTION_WRITE_CRC 0xa000
-#define MCP25XXFD_INSTRUCTION_READ_CRC 0xb000
-#define MCP25XXFD_INSTRUCTION_WRITE_SAVE 0xc000
-
-struct mcp25xxfd_dump_regs_fifo {
-	u32 con;
-	u32 sta;
-	u32 ua;
-};
-
-struct mcp25xxfd_dump_regs {
-	u32 con;
-	u32 nbtcfg;
-	u32 dbtcfg;
-	u32 tdc;
-	u32 tbc;
-	u32 tscon;
-	u32 vec;
-	u32 intf;
-	u32 rxif;
-	u32 txif;
-	u32 rxovif;
-	u32 txatif;
-	u32 txreq;
-	u32 trec;
-	u32 bdiag0;
-	u32 bdiag1;
-	union {
-		struct {
-			u32 tefcon;
-			u32 tefsta;
-			u32 tefua;
-		};
-		struct mcp25xxfd_dump_regs_fifo tef;
-	};
-	u32 reserved0;
-	union {
-		struct {
-			struct mcp25xxfd_dump_regs_fifo txq;
-			struct mcp25xxfd_dump_regs_fifo tx_fifo;
-			struct mcp25xxfd_dump_regs_fifo rx_fifo;
-		};
-		struct mcp25xxfd_dump_regs_fifo fifo[32];
-	};
-};
-
-struct mcp25xxfd_dump_ram {
-	u8 ram[MCP25XXFD_RAM_SIZE];
-};
-
-struct mcp25xxfd_dump_regs_mcp25xxfd {
-	u32 osc;
-	u32 iocon;
-	u32 crc;
-	u32 ecccon;
-	u32 eccstat;
-	u32 devid;		/* MCP2518FD only */
-};
-
-struct mcp25xxfd_dump {
-	struct mcp25xxfd_dump_regs regs;
-	struct mcp25xxfd_dump_ram ram;
-	struct mcp25xxfd_dump_regs_mcp25xxfd regs_mcp25xxfd;
-};
-
-struct mcp25xxfd_hw_tef_obj {
-	u32 id;
-	u32 flags;
-	u32 ts;
-};
-
-/* The tx_obj_raw version is used in spi async, i.e. without
- * regmap. We have to take care of endianness ourselves.
- */
-struct mcp25xxfd_hw_tx_obj_raw {
-	__le32 id;
-	__le32 flags;
-	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
-};
-
-struct mcp25xxfd_hw_tx_obj_can {
-	u32 id;
-	u32 flags;
-	u8 data[FIELD_SIZEOF(struct can_frame, data)];
-};
-
-struct mcp25xxfd_hw_tx_obj_canfd {
-	u32 id;
-	u32 flags;
-	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
-};
-
-struct mcp25xxfd_hw_rx_obj_can {
-	u32 id;
-	u32 flags;
-	u32 ts;
-	u8 data[FIELD_SIZEOF(struct can_frame, data)];
-};
-
-struct mcp25xxfd_hw_rx_obj_canfd {
-	u32 id;
-	u32 flags;
-	u32 ts;
-	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
-};
-
-struct __packed mcp25xxfd_tx_obj_load_buf {
-	__be16 cmd;
-	struct mcp25xxfd_hw_tx_obj_raw hw_tx_obj;
-} ____cacheline_aligned;
-
-struct __packed mcp25xxfd_reg_write_buf {
-	__be16 cmd;
-	u8 data[4];
-} ____cacheline_aligned;
-
-struct mcp25xxfd_crc_buf {
-	struct __packed {
-		__be16 cmd;
-		u8 len;
-	} addr;
-	__be16 crc;
-} ____cacheline_aligned;
-
-struct mcp25xxfd_tef_ring {
-	unsigned int head;
-	unsigned int tail;
-
-	/* u8 obj_num equals tx_ring->obj_num */
-	/* u8 obj_size equals sizeof(struct mcp25xxfd_hw_tef_obj) */
-};
-
-struct mcp25xxfd_tx_obj {
-	struct {
-		struct spi_message msg;
-		struct spi_transfer xfer;
-		struct mcp25xxfd_tx_obj_load_buf buf;
-	} load;
-
-	struct {
-		struct spi_message msg;
-		struct spi_transfer xfer;
-		struct mcp25xxfd_reg_write_buf buf;
-	} trigger;
-};
-
-struct mcp25xxfd_tx_ring {
-	unsigned int head;
-	unsigned int tail;
-
-	u8 obj_num;
-	u8 obj_size;
-
-	struct mcp25xxfd_tx_obj obj[MCP25XXFD_TX_OBJ_NUM_MAX];
-};
-
-struct mcp25xxfd_rx_ring {
-	unsigned int head;
-	unsigned int tail;
-
-	u8 obj_num;
-	u8 obj_size;
-
-	struct mcp25xxfd_hw_rx_obj_canfd obj[MCP25XXFD_RX_OBJ_NUM_CANFD];
-};
-
-struct mcp25xxfd_regs_status {
-	u32 intf;
-};
-
-enum mcp25xxfd_model {
-	CAN_MCP2517FD = 0x2517,
-	CAN_MCP2518FD = 0x2518,
-	CAN_MCP25XXFD = 0xffff,		/* autodetect model */
-};
-
-struct mcp25xxfd_priv {
-	struct can_priv can;
-	struct can_rx_offload offload;
-	struct net_device *ndev;
-
-	struct regmap *map;
-	struct regmap *map_crc;
-	struct spi_device *spi;
-
-	struct mcp25xxfd_tef_ring tef;
-	struct mcp25xxfd_tx_ring tx;
-	struct mcp25xxfd_rx_ring rx;
-
-	u32 intf;
-
-	struct mcp25xxfd_reg_write_buf update_bits_buf;
-	struct mcp25xxfd_crc_buf crc_buf;
-
-	struct gpio_desc *rx_int;
-	struct clk *clk;
-	struct regulator *reg_vdd;
-	struct regulator *reg_xceiver;
-
-	enum mcp25xxfd_model model;
-
-	struct mcp25xxfd_dump dump;
-	atomic_t cnt;
-#ifdef CONFIG_CAN_MCP25XXFD_LOG
-	struct mcp25xxfd_log log[64];
-#endif
-};
-
-static inline u8 mcp25xxfd_first_byte_set(u32 mask)
-{
-	return (mask & 0x0000ffff) ?
-		((mask & 0x000000ff) ? 0 : 1) :
-		((mask & 0x00ff0000) ? 2 : 3);
-}
-
-static inline u8 mcp25xxfd_last_byte_set(u32 mask)
-{
-	return (mask & 0xffff0000) ?
-		((mask & 0xff000000) ? 3 : 2) :
-		((mask & 0x0000ff00) ? 1 : 0);
-}
-
-static inline __be16 mcp25xxfd_cmd_reset(void)
-{
-	return cpu_to_be16(MCP25XXFD_INSTRUCTION_RESET);
-}
-
-static inline __be16 mcp25xxfd_cmd_read(u16 addr)
-{
-	return cpu_to_be16(MCP25XXFD_INSTRUCTION_READ | addr);
-}
-
-static inline __be16 mcp25xxfd_cmd_write(u16 addr)
-{
-	return cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE | addr);
-}
-
-static inline u16
-mcp25xxfd_get_tef_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return sizeof(struct mcp25xxfd_hw_tef_obj) * n;
-}
-
-static inline u16
-mcp25xxfd_get_tef_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return mcp25xxfd_get_tef_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
-}
-
-static inline u16
-mcp25xxfd_get_tx_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return mcp25xxfd_get_tef_obj_rel_addr(priv, priv->tx.obj_num) +
-		priv->tx.obj_size * n;
-}
-
-static inline u16
-mcp25xxfd_get_tx_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return mcp25xxfd_get_tx_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
-}
-
-static inline u16
-mcp25xxfd_get_rx_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return mcp25xxfd_get_tx_obj_rel_addr(priv, priv->tx.obj_num) +
-		priv->rx.obj_size * n;
-}
-
-static inline u16
-mcp25xxfd_get_rx_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
-{
-	return mcp25xxfd_get_rx_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
-}
-
-static inline u8 mcp25xxfd_get_tef_head(const struct mcp25xxfd_priv *priv)
-{
-	return priv->tef.head & (priv->tx.obj_num - 1);
-}
-
-static inline u8 mcp25xxfd_get_tef_tail(const struct mcp25xxfd_priv *priv)
-{
-	return priv->tef.tail & (priv->tx.obj_num - 1);
-}
-
-static inline u8 mcp25xxfd_get_tef_len(const struct mcp25xxfd_priv *priv)
-{
-	return priv->tef.head - priv->tef.tail;
-}
-
-static inline u8 mcp25xxfd_get_tef_linear_len(const struct mcp25xxfd_priv *priv)
-{
-	u8 len;
-
-	len = mcp25xxfd_get_tef_len(priv);
-
-	return min_t(u8, len, priv->tx.obj_num - mcp25xxfd_get_tef_tail(priv));
-}
-
-static inline u8 mcp25xxfd_get_tx_head(const struct mcp25xxfd_priv *priv)
-{
-	return priv->tx.head & (priv->tx.obj_num - 1);
-}
-
-static inline u8 mcp25xxfd_get_tx_tail(const struct mcp25xxfd_priv *priv)
-{
-	return priv->tx.tail & (priv->tx.obj_num - 1);
-}
-
-static inline u8 mcp25xxfd_get_rx_head(const struct mcp25xxfd_priv *priv)
-{
-	return priv->rx.head & (priv->rx.obj_num - 1);
-}
-
-static inline u8 mcp25xxfd_get_rx_tail(const struct mcp25xxfd_priv *priv)
-{
-	return priv->rx.tail & (priv->rx.obj_num - 1);
-}
-
-static inline u8 mcp25xxfd_get_rx_len(const struct mcp25xxfd_priv *priv)
-{
-	return priv->rx.head - priv->rx.tail;
-}
-
-static inline u8 mcp25xxfd_get_rx_linear_len(const struct mcp25xxfd_priv *priv)
-{
-	u8 len;
-
-	len = mcp25xxfd_get_rx_len(priv);
-
-	return min_t(u8, len, priv->rx.obj_num - mcp25xxfd_get_rx_tail(priv));
-}
-
-void mcp25xxfd_dump(struct mcp25xxfd_priv *priv);
-int mcp25xxfd_regmap_init(struct mcp25xxfd_priv *priv);
-u16 mcp25xxfd_crc16_compute(const void *cmd, size_t cmd_size,
-			    const void *data, size_t data_size);
-
-#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c
new file mode 100644
index 000000000000..d9396e8819e8
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include "mcp25xxfd_base.h"
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_clock.h"
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_debugfs.h"
+#include "mcp25xxfd_ecc.h"
+#include "mcp25xxfd_gpio.h"
+#include "mcp25xxfd_int.h"
+#include "mcp25xxfd_priv.h"
+
+/* Device description and rational:
+ *
+ * The mcp25xxfd is a CanFD controller that also supports can2.0 only
+ * modes.
+ * It is connected via spi to the host and requires at minimum a single
+ * irq line in addition to the SPI lines - it is not mentioned explicitly
+ * in the documentation but in principle SPI 3-wire should be possible.
+ *
+ * The clock connected is typically 4MHz, 20MHz or 40MHz.
+ * When using a 4MHz clock the controller can use an integrated PLL to
+ * get 40MHz.
+ *
+ * The controller itself has 2KB of SRAM for CAN-data.
+ * ECC can get enabled for SRAM.
+ * CRC-16 checksumming of SPI transfers can get implemented
+ *   - some optimization options may not be efficient in such a situation.
+ *   - more SPI bus bandwidth is used for transfer of CRCs and
+ *     transfer length information
+ *
+ * It also contains 2 GPIO pins that can get used either as interrupt lines
+ * or GPIO IN or Out or STANDBY flags.
+ * In addition there is a PIN that allows output of a (divided) clock out
+ * or as a SOF (Start of Can FRAME) interrupt line - e.g for wakeup.
+ */
+
+int mcp25xxfd_base_power_enable(struct regulator *reg, int enable)
+{
+	if (IS_ERR_OR_NULL(reg))
+		return 0;
+
+	if (enable)
+		return regulator_enable(reg);
+	else
+		return regulator_disable(reg);
+}
+
+static const struct of_device_id mcp25xxfd_of_match[] = {
+	{
+		.compatible	= "microchip,mcp2517fd",
+		.data		= (void *)CAN_MCP2517FD,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mcp25xxfd_of_match);
+
+static int mcp25xxfd_base_probe(struct spi_device *spi)
+{
+	const struct of_device_id *of_id =
+		of_match_device(mcp25xxfd_of_match, &spi->dev);
+	struct mcp25xxfd_priv *priv;
+	int ret;
+
+	/* as irq_create_fwspec_mapping() can return 0, check for it */
+	if (spi->irq <= 0) {
+		dev_err(&spi->dev, "no valid irq line defined: irq = %i\n",
+			spi->irq);
+		return -EINVAL;
+	}
+
+	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* cross assigns */
+	spi_set_drvdata(spi, priv);
+	priv->spi = spi;
+
+	/* assign name */
+	snprintf(priv->device_name, sizeof(priv->device_name),
+		 DEVICE_NAME "-%s", dev_name(&priv->spi->dev));
+
+	/* assign model from of or driver_data */
+	if (of_id)
+		priv->model = (enum mcp25xxfd_model)of_id->data;
+	else
+		priv->model = spi_get_device_id(spi)->driver_data;
+
+	mutex_init(&priv->spi_rxtx_lock);
+
+	ret = mcp25xxfd_clock_init(priv);
+	if (ret)
+		goto out_free;
+
+	/* Configure the SPI bus */
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		goto out_clk;
+
+	priv->power = devm_regulator_get_optional(&spi->dev, "vdd");
+	if (PTR_ERR(priv->power) == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto out_clk;
+	}
+
+	ret = mcp25xxfd_base_power_enable(priv->power, 1);
+	if (ret)
+		goto out_clk;
+
+	/* this will also enable the MCP25XXFD_CLK_USER_CAN clock */
+	ret = mcp25xxfd_clock_probe(priv);
+	if (ret)
+		goto out_probe;
+
+	/* enable the can controller clock */
+	ret = mcp25xxfd_clock_start(priv, MCP25XXFD_CLK_USER_CAN);
+	if (ret)
+		goto out_probe;
+
+	/* try to identify the can-controller - we need the clock here */
+	ret = mcp25xxfd_can_probe(priv);
+	if (ret)
+		goto out_ctlclk;
+
+	/* add debugfs */
+	mcp25xxfd_debugfs_setup(priv);
+
+	/* disable interrupts */
+	ret = mcp25xxfd_int_enable(priv, false);
+	if (ret)
+		goto out_debugfs;
+
+	/* setup ECC for SRAM */
+	ret = mcp25xxfd_ecc_enable(priv);
+	if (ret)
+		goto out_debugfs;
+
+	/* setting up GPIO */
+	ret = mcp25xxfd_gpio_setup(priv);
+	if (ret)
+		goto out_debugfs;
+
+	/* setting up CAN */
+	ret = mcp25xxfd_can_setup(priv);
+	if (ret)
+		goto out_gpio;
+
+	/* and put controller to sleep by stopping the can clock */
+	ret = mcp25xxfd_clock_stop(priv, MCP25XXFD_CLK_USER_CAN);
+	if (ret)
+		goto out_can;
+
+	dev_info(&spi->dev,
+		 "MCP%x successfully initialized.\n", priv->model);
+	return 0;
+
+out_can:
+	mcp25xxfd_can_remove(priv);
+out_gpio:
+	mcp25xxfd_gpio_remove(priv);
+out_debugfs:
+	mcp25xxfd_debugfs_remove(priv);
+out_ctlclk:
+	mcp25xxfd_clock_stop(priv, MCP25XXFD_CLK_USER_CAN);
+out_probe:
+	mcp25xxfd_base_power_enable(priv->power, 0);
+out_clk:
+	mcp25xxfd_clock_release(priv);
+out_free:
+	dev_err(&spi->dev, "Probe failed, err=%d\n", -ret);
+	return ret;
+}
+
+static int mcp25xxfd_base_remove(struct spi_device *spi)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+
+	/* remove can */
+	mcp25xxfd_can_remove(priv);
+
+	/* remove gpio */
+	mcp25xxfd_gpio_remove(priv);
+
+	/* clear all running clocks */
+	mcp25xxfd_clock_stop(priv, priv->clk_user_mask);
+
+	mcp25xxfd_debugfs_remove(priv);
+
+	mcp25xxfd_base_power_enable(priv->power, 0);
+
+	mcp25xxfd_clock_release(priv);
+
+	return 0;
+}
+
+static int __maybe_unused mcp25xxfd_base_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+
+	mutex_lock(&priv->clk_user_lock);
+	priv->clk_sleep_mask = priv->clk_user_mask;
+	mutex_unlock(&priv->clk_user_lock);
+
+	/* disable interrupts */
+	mcp25xxfd_int_enable(priv, false);
+
+	/* stop the clocks */
+	mcp25xxfd_clock_stop(priv, priv->clk_sleep_mask);
+
+	/* disable power to controller */
+	return mcp25xxfd_base_power_enable(priv->power, 0);
+}
+
+static int __maybe_unused mcp25xxfd_base_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	int ret = 0;
+
+	/* enable power to controller */
+	mcp25xxfd_base_power_enable(priv->power, 1);
+
+	/* if there is no sleep mask, then there is nothing to wake */
+	if (!priv->clk_sleep_mask)
+		return 0;
+
+	/* start the clocks */
+	ret = mcp25xxfd_clock_start(priv, priv->clk_sleep_mask);
+	if (ret)
+		return 0;
+
+	/* clear the sleep mask */
+	mutex_lock(&priv->clk_user_lock);
+	priv->clk_sleep_mask = 0;
+	mutex_unlock(&priv->clk_user_lock);
+
+	/* enable the interrupts again */
+	return mcp25xxfd_int_enable(priv, true);
+}
+
+static SIMPLE_DEV_PM_OPS(mcp25xxfd_base_pm_ops, mcp25xxfd_base_suspend,
+			 mcp25xxfd_base_resume);
+
+static const struct spi_device_id mcp25xxfd_id_table[] = {
+	{
+		.name		= "mcp2517fd",
+		.driver_data	= (kernel_ulong_t)CAN_MCP2517FD,
+	},
+	{
+		.name		= "mcp2518fd",
+		.driver_data	= (kernel_ulong_t)CAN_MCP2518FD,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, mcp25xxfd_id_table);
+
+static struct spi_driver mcp25xxfd_can_driver = {
+	.driver = {
+		.name = DEVICE_NAME,
+		.of_match_table = mcp25xxfd_of_match,
+		.pm = &mcp25xxfd_base_pm_ops,
+	},
+	.id_table = mcp25xxfd_id_table,
+	.probe = mcp25xxfd_base_probe,
+	.remove = mcp25xxfd_base_remove,
+};
+module_spi_driver(mcp25xxfd_can_driver);
+
+MODULE_AUTHOR("Martin Sperl <kernel@martin.sperl.org>");
+MODULE_DESCRIPTION("Microchip 25XXFD CAN driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h
new file mode 100644
index 000000000000..4559ac60645c
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_BASE_H
+#define __MCP25XXFD_BASE_H
+
+#include <linux/regulator/consumer.h>
+
+int mcp25xxfd_base_power_enable(struct regulator *reg, int enable);
+
+#endif /* __MCP25XXFD_BASE_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c
new file mode 100644
index 000000000000..187717a3623e
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c
@@ -0,0 +1,687 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+/* controller details
+ *
+ *  It has 32 FIFOs (of up to 32 CAN-frames).
+ *
+ * There are 4 Fifo types which can get configured:
+ * * TEF - Transmission Event Fifo - which consumes FIFO 0
+ *   even if it is not configured
+ * * Tansmission Queue - for up to 32 Frames.
+ *   this queue reorders CAN frames to get transmitted following the
+ *   typical CAN dominant/recessive rules on the can bus itself.
+ *   This FIFO is optional.
+ * * TX FIFO: generic TX fifos that can contain arbitrary data
+ *   and which come with a configurable priority for transmission
+ *   It is also possible to have the Controller automatically trigger
+ *   a transfer when a Filter Rule for a RTR frame matches.
+ *   Each of these fifos in principle can get configured for distinct
+ *   dlc sizes (8 thru 64 bytes)
+ * * RX FIFO: generic RX fifo which is filled via filter-rules.
+ *   Each of these fifos in principle can get configured for distinct
+ *   dlc sizes (8 thru 64 bytes)
+ *   Unfortunately there is no filter rule that would allow triggering
+ *   on different frame sizes, so for all practical purposes the
+ *   RX fifos have to be of the same size (unless one wants to experience
+ *   lost data).
+ * When a Can Frame is transmitted from the TX Queue or an individual
+ * TX FIFO then a small TEF Frame can get added to the TEF FIFO queue
+ * to log the Transmission of the frame - this includes ID, Flags
+ * (including a custom identifier/index) and the timestamp (see below).
+ *
+ * The controller provides an optional free running counter with a divider
+ * for timestamping of RX frames as well as for TEF entries.
+ */
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_base.h"
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_can_debugfs.h"
+#include "mcp25xxfd_can_fifo.h"
+#include "mcp25xxfd_can_int.h"
+#include "mcp25xxfd_can_priv.h"
+#include "mcp25xxfd_can_tx.h"
+#include "mcp25xxfd_clock.h"
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_int.h"
+#include "mcp25xxfd_priv.h"
+#include "mcp25xxfd_regs.h"
+
+#include <uapi/linux/can/netlink.h>
+
+/* module parameters */
+static unsigned int bw_sharing_log2bits;
+module_param(bw_sharing_log2bits, uint, 0664);
+MODULE_PARM_DESC(bw_sharing_log2bits,
+		 "Delay between 2 transmissions in number of arbitration bit times\n");
+static bool enable_edge_filter;
+module_param(enable_edge_filter, bool, 0664);
+MODULE_PARM_DESC(enable_edge_filter,
+		 "Enable ISO11898-1:2015 edge_filtering");
+static unsigned int tdc_mode = 2;
+module_param(tdc_mode, uint, 0664);
+MODULE_PARM_DESC(tdc_mode,
+		 "Transmitter Delay Mode - 0 = disabled, 1 = fixed, 2 = auto\n");
+static unsigned int tdc_value;
+module_param(tdc_value, uint, 0664);
+MODULE_PARM_DESC(tdc_value,
+		 "Transmission Delay Value - range: [0:63] SCLK");
+static int tdc_offset = 64; /* outside of range to use computed values */
+module_param(tdc_offset, int, 0664);
+MODULE_PARM_DESC(tdc_offset,
+		 "Transmission Delay offset - range: [-64:63] SCLK");
+
+/* everything related to bit timing */
+static
+const struct can_bittiming_const mcp25xxfd_can_nominal_bittiming_const = {
+	.name           = DEVICE_NAME,
+	.tseg1_min      = 2,
+	.tseg1_max      = BIT(MCP25XXFD_CAN_NBTCFG_TSEG1_BITS),
+	.tseg2_min      = 1,
+	.tseg2_max      = BIT(MCP25XXFD_CAN_NBTCFG_TSEG2_BITS),
+	.sjw_max        = BIT(MCP25XXFD_CAN_NBTCFG_SJW_BITS),
+	.brp_min        = 1,
+	.brp_max        = BIT(MCP25XXFD_CAN_NBTCFG_BRP_BITS),
+	.brp_inc        = 1,
+};
+
+static
+const struct can_bittiming_const mcp25xxfd_can_data_bittiming_const = {
+	.name           = DEVICE_NAME,
+	.tseg1_min      = 1,
+	.tseg1_max      = BIT(MCP25XXFD_CAN_DBTCFG_TSEG1_BITS),
+	.tseg2_min      = 1,
+	.tseg2_max      = BIT(MCP25XXFD_CAN_DBTCFG_TSEG2_BITS),
+	.sjw_max        = BIT(MCP25XXFD_CAN_DBTCFG_SJW_BITS),
+	.brp_min        = 1,
+	.brp_max        = BIT(MCP25XXFD_CAN_DBTCFG_BRP_BITS),
+	.brp_inc        = 1,
+};
+
+static int mcp25xxfd_can_do_set_nominal_bittiming(struct net_device *net)
+{
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+	struct can_bittiming *bt = &cpriv->can.bittiming;
+
+	int sjw = bt->sjw;
+	int pseg2 = bt->phase_seg2;
+	int pseg1 = bt->phase_seg1;
+	int propseg = bt->prop_seg;
+	int brp = bt->brp;
+
+	int tseg1 = propseg + pseg1;
+	int tseg2 = pseg2;
+
+	/* calculate nominal bit timing */
+	cpriv->regs.nbtcfg = ((sjw - 1) << MCP25XXFD_CAN_NBTCFG_SJW_SHIFT) |
+		((tseg2 - 1) << MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT) |
+		((tseg1 - 1) << MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT) |
+		((brp - 1) << MCP25XXFD_CAN_NBTCFG_BRP_SHIFT);
+
+	return mcp25xxfd_cmd_write(cpriv->priv->spi, MCP25XXFD_CAN_NBTCFG,
+				   cpriv->regs.nbtcfg);
+}
+
+static int mcp25xxfd_can_do_set_data_bittiming(struct net_device *net)
+{
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+	struct mcp25xxfd_priv *priv = cpriv->priv;
+	struct can_bittiming *bt = &cpriv->can.data_bittiming;
+	struct spi_device *spi = priv->spi;
+
+	int sjw = bt->sjw;
+	int pseg2 = bt->phase_seg2;
+	int pseg1 = bt->phase_seg1;
+	int propseg = bt->prop_seg;
+	int brp = bt->brp;
+
+	int tseg1 = propseg + pseg1;
+	int tseg2 = pseg2;
+
+	int tdco;
+	int ret;
+
+	/* set up Transmitter delay compensation */
+	cpriv->regs.tdc = 0;
+	/* configure TDC mode */
+	if (tdc_mode < 4)
+		cpriv->regs.tdc = tdc_mode << MCP25XXFD_CAN_TDC_TDCMOD_SHIFT;
+	else
+		cpriv->regs.tdc = MCP25XXFD_CAN_TDC_TDCMOD_AUTO <<
+			MCP25XXFD_CAN_TDC_TDCMOD_SHIFT;
+
+	/* configure TDC offsets */
+	if ((tdc_offset >= -64) && tdc_offset < 64)
+		tdco = tdc_offset;
+	else
+		tdco = clamp_t(int, bt->brp * tseg1, -64, 63);
+	cpriv->regs.tdc |= (tdco << MCP25XXFD_CAN_TDC_TDCO_SHIFT) &
+		MCP25XXFD_CAN_TDC_TDCO_MASK;
+
+	/* configure TDC value */
+	if (tdc_value < 64)
+		cpriv->regs.tdc |= tdc_value << MCP25XXFD_CAN_TDC_TDCV_SHIFT;
+
+	/* enable edge filtering */
+	if (enable_edge_filter)
+		cpriv->regs.tdc |= MCP25XXFD_CAN_TDC_EDGFLTEN;
+
+	/* set TDC */
+	ret = mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_TDC, cpriv->regs.tdc);
+	if (ret)
+		return ret;
+
+	/* calculate data bit timing */
+	cpriv->regs.dbtcfg = ((sjw - 1) << MCP25XXFD_CAN_DBTCFG_SJW_SHIFT) |
+		((tseg2 - 1) << MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT) |
+		((tseg1 - 1) << MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT) |
+		((brp - 1) << MCP25XXFD_CAN_DBTCFG_BRP_SHIFT);
+
+	return mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_DBTCFG,
+				   cpriv->regs.dbtcfg);
+}
+
+int mcp25xxfd_can_get_mode(struct mcp25xxfd_priv *priv, u32 *reg)
+{
+	int ret;
+
+	ret = mcp25xxfd_cmd_read(priv->spi, MCP25XXFD_CAN_CON, reg);
+	if (ret)
+		return ret;
+
+	return (*reg & MCP25XXFD_CAN_CON_OPMOD_MASK) >>
+		MCP25XXFD_CAN_CON_OPMOD_SHIFT;
+}
+
+int mcp25xxfd_can_switch_mode_no_wait(struct mcp25xxfd_priv *priv,
+				      u32 *reg, int mode)
+{
+	u32 dummy;
+	int ret;
+
+	/* get the current mode/register - if reg is NULL
+	 * when the can controller is not setup yet
+	 * typically by calling mcp25xxfd_can_sleep_mode
+	 * (this only happens during initialization phase)
+	 */
+	if (reg) {
+		if (!*reg) {
+			ret = mcp25xxfd_can_get_mode(priv, reg);
+			if (ret < 0)
+				return ret;
+		}
+	} else {
+		/* alternatively use dummy */
+		dummy = 0;
+		reg = &dummy;
+	}
+
+	/* compute the effective mode in osc*/
+	*reg &= ~(MCP25XXFD_CAN_CON_REQOP_MASK |
+		  MCP25XXFD_CAN_CON_OPMOD_MASK);
+	*reg |= (mode << MCP25XXFD_CAN_CON_REQOP_SHIFT) |
+		(mode << MCP25XXFD_CAN_CON_OPMOD_SHIFT);
+
+	/* if the opmode is sleep then the oscilator will be disabled
+	 * and also not ready, so fake this change
+	 */
+	if (mode == MCP25XXFD_CAN_CON_MODE_SLEEP)
+		mcp25xxfd_clock_fake_sleep(priv);
+
+	/* request the mode switch */
+	return mcp25xxfd_cmd_write(priv->spi, MCP25XXFD_CAN_CON, *reg);
+}
+
+int mcp25xxfd_can_switch_mode(struct mcp25xxfd_priv *priv, u32 *reg, int mode)
+{
+	int ret, i;
+
+	/* trigger the mode switch itself */
+	ret = mcp25xxfd_can_switch_mode_no_wait(priv, reg, mode);
+	if (ret)
+		return ret;
+
+	/* if we are in now sleep mode then return immediately
+	 * the controller does not respond back!
+	 */
+	if (mode == MCP25XXFD_CAN_CON_MODE_SLEEP)
+		return 0;
+
+	/* wait for it to stabilize/switch mode
+	 * we assume 256 rounds should be enough as this is > 12ms
+	 * at 1MHz Can Bus speed without any extra overhead
+	 *
+	 * The assumption here is that it depends on bus activity
+	 * how long it takes the controller to switch modes
+	 */
+	for (i = 0; i < 256; i++) {
+		/* get the mode */
+		ret = mcp25xxfd_can_get_mode(priv, reg);
+		if (ret < 0)
+			return ret;
+		/* check that we have reached our mode */
+		if (ret == mode)
+			return 0;
+	}
+
+	dev_err(&priv->spi->dev, "Failed to switch to mode %u in time\n",
+		mode);
+	return -ETIMEDOUT;
+}
+
+static int mcp25xxfd_can_probe_modeswitch(struct mcp25xxfd_priv *priv)
+{
+	u32 mode_data;
+	int ret;
+
+	/* so we should be in config mode now, so move to INT_LOOPBACK */
+	ret = mcp25xxfd_can_switch_mode(priv, &mode_data,
+					MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK);
+	if (ret) {
+		dev_err(&priv->spi->dev,
+			"Failed to switch into loopback mode\n");
+		return ret;
+	}
+
+	/* and back into config mode */
+	ret = mcp25xxfd_can_switch_mode(priv, &mode_data,
+					MCP25XXFD_CAN_CON_MODE_CONFIG);
+	if (ret) {
+		dev_err(&priv->spi->dev,
+			"Failed to switch back to config mode\n");
+		return ret;
+	}
+
+	/* so we have checked basic functionality successfully */
+	return 0;
+}
+
+int mcp25xxfd_can_sleep_mode(struct mcp25xxfd_priv *priv)
+{
+	return mcp25xxfd_can_switch_mode(priv, NULL,
+					 MCP25XXFD_CAN_CON_MODE_SLEEP);
+}
+
+int mcp25xxfd_can_probe(struct mcp25xxfd_priv *priv)
+{
+	struct spi_device *spi = priv->spi;
+	u32 mode_data;
+	int mode, ret;
+
+	/* read TXQCON - the TXEN bit should always read as 1 */
+	ret = mcp25xxfd_cmd_read(spi, MCP25XXFD_CAN_TXQCON, &mode_data);
+	if (ret)
+		return ret;
+	if ((mode_data & MCP25XXFD_CAN_TXQCON_TXEN) == 0) {
+		dev_err(&spi->dev,
+			"Register TXQCON does not have bit TXEN set - reads as %08x - this may be a problem with spi bus signal quality - try reducing spi-clock speed if this can get reproduced",
+			mode_data);
+		return -EINVAL;
+	}
+
+	/* try to get the current mode */
+	mode = mcp25xxfd_can_get_mode(priv, &mode_data);
+	if (mode < 0)
+		return mode;
+
+	/* we would expect to be in config mode, as a SPI-reset should
+	 * have moved us into config mode.
+	 * But then the documentation says that SPI-reset may only work
+	 * reliably when already in config mode
+	 */
+
+	/* so if we are in config mode then everything is fine
+	 * and we check that a mode switch works propperly
+	 */
+	if (mode == MCP25XXFD_CAN_CON_MODE_CONFIG)
+		return mcp25xxfd_can_probe_modeswitch(priv);
+
+	/* if the bitfield is 0 then there is something is wrong */
+	if (!mode_data) {
+		dev_err(&spi->dev,
+			"got controller config register reading as 0\n");
+		return -EINVAL;
+	}
+
+	/* any other mode is unexpected */
+	dev_err(&spi->dev,
+		"Found controller in unexpected mode %i - register reads as %08x\n",
+		mode, mode_data);
+
+	/* so try to move to config mode
+	 * if this fails, then everything is lost and the controller
+	 * is not identified
+	 * This action MAY be destructive if a different device is connected
+	 * but note that the first hurdle (oscillator) was already
+	 * successful - so we should be safe...
+	 */
+	ret = mcp25xxfd_can_switch_mode(priv, &mode_data,
+					MCP25XXFD_CAN_CON_MODE_CONFIG);
+	if (ret) {
+		dev_err(&priv->spi->dev,
+			"Mode did not switch to config as expected - could not identify controller - register reads as %08x\n",
+			mode_data);
+		return -EINVAL;
+	}
+	/* check that modeswitch is really working */
+	return mcp25xxfd_can_probe_modeswitch(priv);
+}
+
+static int mcp25xxfd_can_config(struct net_device *net)
+{
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+	struct mcp25xxfd_priv *priv = cpriv->priv;
+	struct spi_device *spi = priv->spi;
+	int ret;
+
+	/* setup value of con_register */
+	cpriv->regs.con = MCP25XXFD_CAN_CON_STEF; /* enable TEF, disable TXQ */
+
+	/* transmission bandwidth sharing bits */
+	if (bw_sharing_log2bits > 12)
+		bw_sharing_log2bits = 12;
+	cpriv->regs.con |= bw_sharing_log2bits <<
+		MCP25XXFD_CAN_CON_TXBWS_SHIFT;
+
+	/* non iso FD mode */
+	if (!(cpriv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
+		cpriv->regs.con |= MCP25XXFD_CAN_CON_ISOCRCEN;
+
+	/* one shot */
+	if (cpriv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		cpriv->regs.con |= MCP25XXFD_CAN_CON_RTXAT;
+
+	/* apply it now together with a mode switch */
+	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
+					MCP25XXFD_CAN_CON_MODE_CONFIG);
+	if (ret)
+		return 0;
+
+	/* time stamp control register - 1ns resolution */
+	cpriv->regs.tscon = 0;
+	ret = mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_TBC, 0);
+	if (ret)
+		return ret;
+
+	cpriv->regs.tscon = MCP25XXFD_CAN_TSCON_TBCEN |
+		((cpriv->can.clock.freq / 1000000)
+		 << MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT);
+	ret = mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_TSCON, cpriv->regs.tscon);
+	if (ret)
+		return ret;
+
+	/* setup fifos */
+	ret = mcp25xxfd_can_fifo_setup(cpriv);
+	if (ret)
+		return ret;
+
+	/* setup can bittiming now - the do_set_bittiming methods
+	 * are not used as they get callled before open
+	 */
+	ret = mcp25xxfd_can_do_set_nominal_bittiming(net);
+	if (ret)
+		return ret;
+	ret = mcp25xxfd_can_do_set_data_bittiming(net);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+/* mode setting */
+static int mcp25xxfd_can_do_set_mode(struct net_device *net,
+				     enum can_mode mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+/* binary error counters */
+static int mcp25xxfd_can_get_berr_counter(const struct net_device *net,
+					  struct can_berr_counter *bec)
+{
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+
+	bec->txerr = (cpriv->status.trec & MCP25XXFD_CAN_TREC_TEC_MASK) >>
+		MCP25XXFD_CAN_TREC_TEC_SHIFT;
+	bec->rxerr = (cpriv->status.trec & MCP25XXFD_CAN_TREC_REC_MASK) >>
+		MCP25XXFD_CAN_TREC_REC_SHIFT;
+
+	return 0;
+}
+
+static int mcp25xxfd_can_open(struct net_device *net)
+{
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+	struct spi_device *spi = cpriv->priv->spi;
+	int ret;
+
+	ret = open_candev(net);
+	if (ret) {
+		netdev_err(net, "unable to set initial baudrate!\n");
+		return ret;
+	}
+
+	/* clear those statistics */
+	memset(&cpriv->stats, 0, sizeof(cpriv->stats));
+
+	/* request an IRQ but keep disabled for now */
+	ret = request_threaded_irq(spi->irq, NULL,
+				   mcp25xxfd_can_int,
+				   IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+				   cpriv->priv->device_name, cpriv);
+	if (ret) {
+		dev_err(&spi->dev, "failed to acquire irq %d - %i\n",
+			spi->irq, ret);
+		goto out_candev;
+	}
+	disable_irq(spi->irq);
+	cpriv->irq.allocated = true;
+	cpriv->irq.enabled = false;
+
+	/* enable power to the transceiver */
+	ret = mcp25xxfd_base_power_enable(cpriv->transceiver, 1);
+	if (ret)
+		goto out_irq;
+
+	/* enable clock (so that spi works) */
+	ret = mcp25xxfd_clock_start(cpriv->priv, MCP25XXFD_CLK_USER_CAN);
+	if (ret)
+		goto out_transceiver;
+
+	/* configure controller for reception */
+	ret = mcp25xxfd_can_config(net);
+	if (ret)
+		goto out_canclock;
+
+	/* setting up state */
+	cpriv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	/* enable interrupts */
+	ret = mcp25xxfd_int_enable(cpriv->priv, true);
+	if (ret)
+		goto out_canconfig;
+
+	/* switch to active mode */
+	printk(KERN_ALERT "%s7: mtu=%u CAN_MTU=%lu\n",
+	       __func__, net->mtu, CAN_MTU);
+	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
+					(net->mtu == CAN_MTU) ?
+					MCP25XXFD_CAN_CON_MODE_CAN2_0 :
+					MCP25XXFD_CAN_CON_MODE_MIXED);
+	if (ret)
+		goto out_int;
+
+	/* start the tx_queue */
+	mcp25xxfd_can_tx_queue_manage(cpriv,
+				      MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED);
+
+	return 0;
+
+out_int:
+	mcp25xxfd_int_enable(cpriv->priv, false);
+out_canconfig:
+	mcp25xxfd_can_fifo_release(cpriv);
+out_canclock:
+	mcp25xxfd_clock_stop(cpriv->priv, MCP25XXFD_CLK_USER_CAN);
+out_transceiver:
+	mcp25xxfd_base_power_enable(cpriv->transceiver, 0);
+out_irq:
+	free_irq(spi->irq, cpriv);
+	cpriv->irq.allocated = false;
+	cpriv->irq.enabled = false;
+out_candev:
+	close_candev(net);
+	return ret;
+}
+
+static void mcp25xxfd_can_shutdown(struct mcp25xxfd_can_priv *cpriv)
+{
+	/* switch us to CONFIG mode - this disables the controller */
+	mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
+				  MCP25XXFD_CAN_CON_MODE_CONFIG);
+}
+
+static int mcp25xxfd_can_stop(struct net_device *net)
+{
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+	struct mcp25xxfd_priv *priv = cpriv->priv;
+	struct spi_device *spi = priv->spi;
+
+	/* disable inerrupts on controller */
+	mcp25xxfd_int_enable(cpriv->priv, false);
+
+	/* stop transmit queue */
+	mcp25xxfd_can_tx_queue_manage(cpriv,
+				      MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED);
+
+	/* release fifos and debugfs */
+	mcp25xxfd_can_fifo_release(cpriv);
+
+	/* shutdown the can controller */
+	mcp25xxfd_can_shutdown(cpriv);
+
+	/* stop the clock */
+	mcp25xxfd_clock_stop(cpriv->priv, MCP25XXFD_CLK_USER_CAN);
+
+	/* and disable the transceiver */
+	mcp25xxfd_base_power_enable(cpriv->transceiver, 0);
+
+	/* disable interrupt on host */
+	free_irq(spi->irq, cpriv);
+	cpriv->irq.allocated = false;
+	cpriv->irq.enabled = false;
+
+	/* close the can_decice */
+	close_candev(net);
+
+	return 0;
+}
+
+static const struct net_device_ops mcp25xxfd_netdev_ops = {
+	.ndo_open = mcp25xxfd_can_open,
+	.ndo_stop = mcp25xxfd_can_stop,
+	.ndo_start_xmit = mcp25xxfd_can_tx_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+/* probe and remove */
+int mcp25xxfd_can_setup(struct mcp25xxfd_priv *priv)
+{
+	struct spi_device *spi = priv->spi;
+	struct mcp25xxfd_can_priv *cpriv;
+	struct net_device *net;
+	struct regulator *transceiver;
+	int ret;
+
+	/* get transceiver power regulator*/
+	transceiver = devm_regulator_get_optional(&spi->dev,
+						  "xceiver");
+	if (PTR_ERR(transceiver) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	/* allocate can device */
+	net = alloc_candev(sizeof(*cpriv), TX_ECHO_SKB_MAX);
+	if (!net)
+		return -ENOMEM;
+
+	/* and do some cross-asignments */
+	cpriv = netdev_priv(net);
+	cpriv->priv = priv;
+	priv->cpriv = cpriv;
+
+	/* setup network */
+	SET_NETDEV_DEV(net, &spi->dev);
+	net->netdev_ops = &mcp25xxfd_netdev_ops;
+	net->flags |= IFF_ECHO;
+
+	/* assign transceiver */
+	cpriv->transceiver = transceiver;
+
+	/* setup can */
+	cpriv->can.clock.freq = priv->clock_freq;
+	cpriv->can.bittiming_const =
+		&mcp25xxfd_can_nominal_bittiming_const;
+	cpriv->can.data_bittiming_const =
+		&mcp25xxfd_can_data_bittiming_const;
+	/* we are not setting bit-timing methods here as they get
+	 * called by the framework before open so the controller is
+	 * still in sleep mode, which does not help
+	 * things are configured in open instead
+	 */
+	cpriv->can.do_set_mode =
+		mcp25xxfd_can_do_set_mode;
+	cpriv->can.do_get_berr_counter =
+		mcp25xxfd_can_get_berr_counter;
+	cpriv->can.ctrlmode_supported =
+		CAN_CTRLMODE_FD |
+		CAN_CTRLMODE_FD_NON_ISO |
+		CAN_CTRLMODE_LOOPBACK |
+		CAN_CTRLMODE_LISTENONLY |
+		CAN_CTRLMODE_BERR_REPORTING |
+		CAN_CTRLMODE_ONE_SHOT;
+
+	ret = register_candev(net);
+	if (ret) {
+		dev_err(&spi->dev, "Failed to register can device\n");
+		goto out;
+	}
+
+	mcp25xxfd_can_debugfs_setup(cpriv);
+
+	return 0;
+out:
+	free_candev(net);
+	priv->cpriv = NULL;
+
+	return ret;
+}
+
+void mcp25xxfd_can_remove(struct mcp25xxfd_priv *priv)
+{
+	if (priv->cpriv) {
+		unregister_candev(priv->cpriv->can.dev);
+		free_candev(priv->cpriv->can.dev);
+		priv->cpriv = NULL;
+	}
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h
new file mode 100644
index 000000000000..b480220d4ccd
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_H
+#define __MCP25XXFD_CAN_H
+
+#include "mcp25xxfd_can_debugfs.h"
+#include "mcp25xxfd_can_priv.h"
+#include "mcp25xxfd_priv.h"
+#include "mcp25xxfd_regs.h"
+
+/* get the optimal controller target mode */
+static inline
+int mcp25xxfd_can_targetmode(struct mcp25xxfd_can_priv *cpriv)
+{
+	return (cpriv->can.dev->mtu == CAN_MTU) ?
+		MCP25XXFD_CAN_CON_MODE_CAN2_0 : MCP25XXFD_CAN_CON_MODE_MIXED;
+}
+
+static inline
+void mcp25xxfd_can_queue_frame(struct mcp25xxfd_can_priv *cpriv,
+			       s32 fifo, u16 ts, bool is_rx)
+{
+	int idx = cpriv->fifos.submit_queue_count;
+
+	cpriv->fifos.submit_queue[idx].fifo = fifo;
+	cpriv->fifos.submit_queue[idx].ts = ts;
+	cpriv->fifos.submit_queue[idx].is_rx = is_rx;
+
+	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.submit_queue_count);
+}
+
+/* get the current controller mode */
+int mcp25xxfd_can_get_mode(struct mcp25xxfd_priv *priv, u32 *reg);
+
+/* to put us to sleep fully we need the CAN controller to enter sleep mode */
+int mcp25xxfd_can_sleep_mode(struct mcp25xxfd_priv *priv);
+
+/* switch controller mode */
+int mcp25xxfd_can_switch_mode_no_wait(struct mcp25xxfd_priv *priv,
+				      u32 *reg, int mode);
+int mcp25xxfd_can_switch_mode(struct mcp25xxfd_priv *priv,
+			      u32 *reg, int mode);
+
+/* probe the can controller */
+int mcp25xxfd_can_probe(struct mcp25xxfd_priv *priv);
+
+/* setup and the can controller net interface */
+int mcp25xxfd_can_setup(struct mcp25xxfd_priv *priv);
+void mcp25xxfd_can_remove(struct mcp25xxfd_priv *priv);
+
+#endif /* __MCP25XXFD_CAN_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c
new file mode 100644
index 000000000000..013a1a30963a
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c
@@ -0,0 +1,236 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/dcache.h>
+#include <linux/debugfs.h>
+#include "mcp25xxfd_can_debugfs.h"
+#include "mcp25xxfd_can_priv.h"
+#include "mcp25xxfd_can_tx.h"
+
+static void mcp25xxfd_can_debugfs_regs(struct mcp25xxfd_can_priv *cpriv,
+				       struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("regs", root);
+
+	debugfs_create_x32("con",    0444, dir, &cpriv->regs.con);
+	debugfs_create_x32("tdc",    0444, dir, &cpriv->regs.tdc);
+	debugfs_create_x32("tscon",  0444, dir, &cpriv->regs.tscon);
+	debugfs_create_x32("tefcon", 0444, dir, &cpriv->regs.tscon);
+	debugfs_create_x32("nbtcfg", 0444, dir, &cpriv->regs.nbtcfg);
+	debugfs_create_x32("dbtcfg", 0444, dir, &cpriv->regs.dbtcfg);
+}
+
+static void mcp25xxfd_can_debugfs_status(struct mcp25xxfd_can_priv *cpriv,
+					 struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("status", root);
+
+	debugfs_create_x32("intf",    0444, dir, &cpriv->status.intf);
+	debugfs_create_x32("rx_if",   0444, dir, &cpriv->status.rxif);
+	debugfs_create_x32("tx_if",   0444, dir, &cpriv->status.txif);
+	debugfs_create_x32("rx_ovif", 0444, dir, &cpriv->status.rxovif);
+	debugfs_create_x32("tx_atif", 0444, dir, &cpriv->status.txatif);
+	debugfs_create_x32("tx_req",  0444, dir, &cpriv->status.txreq);
+	debugfs_create_x32("trec",    0444, dir, &cpriv->status.trec);
+}
+
+static void mcp25xxfd_can_debugfs_stats(struct mcp25xxfd_can_priv *cpriv,
+					struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("stats", root);
+	char name[32];
+	u64 *data;
+	int i;
+
+# define DEBUGFS_CREATE(name, var) debugfs_create_u64(name, 0444, dir, \
+						      &cpriv->stats.var)
+	DEBUGFS_CREATE("irq_calls",		 irq_calls);
+	DEBUGFS_CREATE("irq_loops",		 irq_loops);
+	DEBUGFS_CREATE("irq_thread_rescheduled", irq_thread_rescheduled);
+
+	DEBUGFS_CREATE("int_system_error",	 int_serr_count);
+	DEBUGFS_CREATE("int_system_error_tx",	 int_serr_tx_count);
+	DEBUGFS_CREATE("int_system_error_rx",	 int_serr_rx_count);
+	DEBUGFS_CREATE("int_mode_switch",	 int_mod_count);
+	DEBUGFS_CREATE("int_rx",		 int_rx_count);
+	DEBUGFS_CREATE("int_tx_attempt",	 int_txat_count);
+	DEBUGFS_CREATE("int_tef",		 int_tef_count);
+	DEBUGFS_CREATE("int_rx_overflow",	 int_rxov_count);
+	DEBUGFS_CREATE("int_ecc_error",		 int_ecc_count);
+	DEBUGFS_CREATE("int_rx_invalid_message", int_ivm_count);
+	DEBUGFS_CREATE("int_crcerror",		 int_cerr_count);
+
+	DEBUGFS_CREATE("tef_reads",		 tef_reads);
+	DEBUGFS_CREATE("tef_conservative_reads", tef_conservative_reads);
+	DEBUGFS_CREATE("tef_optimized_reads",	 tef_optimized_reads);
+	DEBUGFS_CREATE("tef_read_splits",	 tef_read_splits);
+
+	for (i = 0; i < MCP25XXFD_CAN_TEF_READ_BINS - 1; i++) {
+		snprintf(name, sizeof(name),
+			 "tef_optimized_reads_%i", i + 1);
+		data = &cpriv->stats.tef_optimized_read_sizes[i];
+		debugfs_create_u64(name, 0444, dir, data);
+	}
+	snprintf(name, sizeof(name), "tef_optimized_reads_%i+", i + 1);
+	debugfs_create_u64(name, 0444, dir,
+			   &cpriv->stats.tef_optimized_read_sizes[i]);
+
+	DEBUGFS_CREATE("tx_frames_fd",		 tx_fd_count);
+	DEBUGFS_CREATE("tx_frames_brs",		 tx_brs_count);
+
+	DEBUGFS_CREATE("rx_reads",		 rx_reads);
+	DEBUGFS_CREATE("rx_reads_prefetched_too_few",
+		       rx_reads_prefetched_too_few);
+	DEBUGFS_CREATE("rx_reads_prefetched_too_few_bytes",
+		       rx_reads_prefetched_too_few_bytes);
+	DEBUGFS_CREATE("rx_reads_prefetched_too_many",
+		       rx_reads_prefetched_too_many);
+	DEBUGFS_CREATE("rx_reads_prefetched_too_many_bytes",
+		       rx_reads_prefetched_too_many_bytes);
+	DEBUGFS_CREATE("rx_single_reads",	 rx_single_reads);
+	DEBUGFS_CREATE("rx_bulk_reads",		 rx_bulk_reads);
+
+	for (i = 0; i < MCP25XXFD_CAN_RX_BULK_READ_BINS - 1; i++) {
+		snprintf(name, sizeof(name), "rx_bulk_reads_%i", i + 1);
+		data = &cpriv->stats.rx_bulk_read_sizes[i];
+		debugfs_create_u64(name, 0444, dir, data);
+	}
+	snprintf(name, sizeof(name), "rx_bulk_reads_%i+", i + 1);
+	debugfs_create_u64(name, 0444, dir,
+			   &cpriv->stats.rx_bulk_read_sizes[i]);
+
+	if (cpriv->can.dev->mtu == CANFD_MTU)
+		debugfs_create_u32("rx_reads_prefetch_predicted_len", 0444,
+				   dir, &cpriv->rx_history.predicted_len);
+#undef DEBUGFS_CREATE
+}
+
+static void mcp25xxfd_can_debugfs_tef(struct mcp25xxfd_can_priv *cpriv,
+				      struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("tef", root);
+
+	debugfs_create_u32("count", 0444, dir, &cpriv->fifos.tef.count);
+	debugfs_create_u32("size",  0444, dir, &cpriv->fifos.tef.size);
+}
+
+static void mcp25xxfd_can_debugfs_fifo_info(struct mcp25xxfd_fifo_info *info,
+					    int index, struct dentry *root)
+{
+	struct dentry *dir;
+	char name[4];
+
+	snprintf(name, sizeof(name), "%02i", index);
+	dir = debugfs_create_dir(name, root);
+
+	debugfs_create_u32("is_rx",     0444, dir, &info->is_rx);
+	debugfs_create_x32("offset",    0444, dir, &info->offset);
+	debugfs_create_u32("priority",  0444, dir, &info->priority);
+
+	debugfs_create_u64("use_count", 0444, dir, &info->use_count);
+}
+
+static void mcp25xxfd_can_debugfs_fifos(struct mcp25xxfd_can_priv *cpriv,
+					struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("fifos", root);
+	int i;
+
+	/* now present all fifos - there is no fifo 0 */
+	for (i = 1; i < 32; i++)
+		mcp25xxfd_can_debugfs_fifo_info(&cpriv->fifos.info[i], i, dir);
+}
+
+static void mcp25xxfd_can_debugfs_rxtx_fifos(struct mcp25xxfd_fifo *d,
+					     struct dentry *root)
+{
+	int i, f;
+	char name[4];
+	char link[32];
+
+	debugfs_create_u32("count", 0444, root, &d->count);
+	debugfs_create_u32("size",  0444, root, &d->size);
+	debugfs_create_u32("start", 0444, root, &d->start);
+
+	for (f = d->start, i = 0; i < d->count; f++, i++) {
+		snprintf(name, sizeof(name), "%02i", i);
+		snprintf(link, sizeof(link), "../fifos/%02i", f);
+
+		debugfs_create_symlink(name, root, link);
+	}
+}
+
+static void mcp25xxfd_can_debugfs_rx_fifos(struct mcp25xxfd_can_priv *cpriv,
+					   struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("rx_fifos", root);
+
+	mcp25xxfd_can_debugfs_rxtx_fifos(&cpriv->fifos.rx, dir);
+}
+
+static void mcp25xxfd_can_debugfs_tx_fifos(struct mcp25xxfd_can_priv *cpriv,
+					   struct dentry *root)
+{
+	struct dentry *dir = debugfs_create_dir("tx_fifos", root);
+
+	mcp25xxfd_can_debugfs_rxtx_fifos(&cpriv->fifos.rx, dir);
+}
+
+static void mcp25xxfd_can_debugfs_tx_queue(struct mcp25xxfd_can_priv *cpriv,
+					   struct dentry *root)
+{
+	struct mcp25xxfd_tx_spi_message_queue *queue = cpriv->fifos.tx_queue;
+	struct dentry *dir;
+
+	if (!queue)
+		return;
+
+	dir = debugfs_create_dir("tx_queue", root);
+
+	debugfs_create_u32("state", 0444, dir, &queue->state);
+	debugfs_create_x32("fifos_idle", 0444, dir, &queue->idle);
+	debugfs_create_x32("fifos_in_fill_fifo_transfer",
+			   0444, dir, &queue->in_fill_fifo_transfer);
+	debugfs_create_x32("fifos_in_trigger_fifo_transfer",
+			   0444, dir, &queue->in_trigger_fifo_transfer);
+	debugfs_create_x32("fifos_in_can_transfer",
+			   0444, dir, &queue->in_can_transfer);
+	debugfs_create_x32("fifos_transferred",
+			   0444, dir, &queue->transferred);
+}
+
+void mcp25xxfd_can_debugfs_remove(struct mcp25xxfd_can_priv *cpriv)
+{
+	debugfs_remove_recursive(cpriv->debugfs_dir);
+	cpriv->debugfs_dir = NULL;
+}
+
+void mcp25xxfd_can_debugfs_setup(struct mcp25xxfd_can_priv *cpriv)
+{
+	struct dentry *root;
+
+	/* remove first as we get called during probe and also
+	 * when the can_device is configured/removed
+	 */
+	mcp25xxfd_can_debugfs_remove(cpriv);
+
+	root = debugfs_create_dir("can", cpriv->priv->debugfs_dir);
+	cpriv->debugfs_dir = root;
+
+	mcp25xxfd_can_debugfs_regs(cpriv, root);
+	mcp25xxfd_can_debugfs_stats(cpriv, root);
+	mcp25xxfd_can_debugfs_status(cpriv, root);
+	mcp25xxfd_can_debugfs_tef(cpriv, root);
+	mcp25xxfd_can_debugfs_fifos(cpriv, root);
+	mcp25xxfd_can_debugfs_rx_fifos(cpriv, root);
+	mcp25xxfd_can_debugfs_tx_fifos(cpriv, root);
+	mcp25xxfd_can_debugfs_tx_queue(cpriv, root);
+}
+
+#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h
new file mode 100644
index 000000000000..7c6a255c9400
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_DEBUGFS_H
+#define __MCP25XXFD_CAN_DEBUGFS_H
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+#include "mcp25xxfd_can_priv.h"
+
+#define MCP25XXFD_DEBUGFS_INCR(counter) ((counter)++)
+#define MCP25XXFD_DEBUGFS_ADD(counter, val) ((counter) += (val))
+#define MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, counter)		\
+	(((cpriv)->stats.counter)++)
+#define MCP25XXFD_DEBUGFS_STATS_ADD(cpriv, counter, val)	\
+	(((cpriv)->stats.counter) += (val))
+
+void mcp25xxfd_can_debugfs_setup(struct mcp25xxfd_can_priv *cpriv);
+void mcp25xxfd_can_debugfs_remove(struct mcp25xxfd_can_priv *cpriv);
+
+#else /* CONFIG_DEBUG_FS */
+
+#define MCP25XXFD_DEBUGFS_INCR(counter)
+#define MCP25XXFD_DEBUGFS_ADD(counter, val)
+#define MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, counter)
+#define MCP25XXFD_DEBUGFS_STATS_ADD(cpriv, counter, val)
+
+static inline
+void mcp25xxfd_can_debugfs_setup(struct mcp25xxfd_can_priv *cpriv)
+{
+}
+
+static inline
+void mcp25xxfd_can_debugfs_remove(struct mcp25xxfd_can_priv *cpriv)
+{
+}
+
+#endif /* CONFIG_DEBUG_FS */
+#endif /* __MCP25XXFD_CAN_DEBUGFS_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c
new file mode 100644
index 000000000000..e17254af1d89
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c
@@ -0,0 +1,352 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+/* here we define and configure the fifo layout */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_can_fifo.h"
+#include "mcp25xxfd_can_priv.h"
+#include "mcp25xxfd_can_tx.h"
+#include "mcp25xxfd_cmd.h"
+
+/* some controller parameters are currently not configurable via netlink
+ * so we allow to control them via module parameters (that can changed
+ * in /sys if needed) - theses are only needed during setup if the can_device
+ */
+static unsigned int tx_fifos;
+module_param(tx_fifos, uint, 0664);
+MODULE_PARM_DESC(tx_fifos,
+		 "Number of tx-fifos to configure - recommended value is < 7\n");
+
+static bool three_shot;
+module_param(three_shot, bool, 0664);
+MODULE_PARM_DESC(three_shot, "Use 3 shots when one-shot is requested");
+
+static int mcp25xxfd_can_fifo_get_address(struct mcp25xxfd_can_priv *cpriv)
+{
+	int fifo, ret;
+
+	/* we need to move out of config mode to force address computation */
+	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
+					MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK);
+	if (ret)
+		return ret;
+
+	/* and get back into config mode */
+	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
+					MCP25XXFD_CAN_CON_MODE_CONFIG);
+	if (ret)
+		return ret;
+
+	/* read address and config back in */
+	for (fifo = 1; fifo < 32; fifo++) {
+		ret = mcp25xxfd_cmd_read(cpriv->priv->spi,
+					 MCP25XXFD_CAN_FIFOUA(fifo),
+					 &cpriv->fifos.info[fifo].offset);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_can_fifo_setup_config(struct mcp25xxfd_can_priv *cpriv,
+					   struct mcp25xxfd_fifo *desc,
+					   u32 flags, u32 flags_last)
+{
+	u32 val;
+	int i, p, f, c, ret;
+
+	/* now setup the fifos themselves */
+	for (i = 0, f = desc->start, c = desc->count, p = 31;
+	     c > 0; i++, f++, p--, c--) {
+		/* select the effective value */
+		val = (c > 1) ? flags : flags_last;
+
+		/* are we in tx mode */
+		if (flags & MCP25XXFD_CAN_FIFOCON_TXEN) {
+			cpriv->fifos.info[f].is_rx = false;
+			cpriv->fifos.info[f].priority = p;
+			val |= (p << MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT);
+		} else {
+			cpriv->fifos.info[f].is_rx = true;
+		}
+
+		/* write the config to the controller in one go */
+		ret = mcp25xxfd_cmd_write(cpriv->priv->spi,
+					  MCP25XXFD_CAN_FIFOCON(f), val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_can_fifo_setup_tx(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 tx_flags = MCP25XXFD_CAN_FIFOCON_FRESET |     /* reset FIFO */
+		MCP25XXFD_CAN_FIFOCON_TXEN |              /* a tx FIFO */
+		MCP25XXFD_CAN_FIFOCON_TXATIE |            /* state in txatif */
+		(cpriv->fifos.payload_mode <<
+		 MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT) |    /* paylod size */
+		(0 << MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT); /* 1 FIFO deep */
+
+	/* handle oneshot/three-shot */
+	if (cpriv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		if (three_shot)
+			tx_flags |= MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT <<
+				MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT;
+		else
+			tx_flags |= MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT <<
+				MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT;
+	else
+		tx_flags |= MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED <<
+			MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT;
+
+	return mcp25xxfd_can_fifo_setup_config(cpriv, &cpriv->fifos.tx,
+					       tx_flags, tx_flags);
+}
+
+static int mcp25xxfd_can_fifo_setup_rx(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 rx_flags = MCP25XXFD_CAN_FIFOCON_FRESET |     /* reset FIFO */
+		MCP25XXFD_CAN_FIFOCON_RXTSEN |            /* RX timestamps */
+		MCP25XXFD_CAN_FIFOCON_TFERFFIE |          /* FIFO Full */
+		MCP25XXFD_CAN_FIFOCON_TFHRFHIE |          /* FIFO Half Full*/
+		MCP25XXFD_CAN_FIFOCON_TFNRFNIE |          /* FIFO not empty */
+		(cpriv->fifos.payload_mode <<
+		 MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT) |
+		(0 << MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT); /* 1 FIFO deep */
+	/* enable overflow int on last fifo */
+	u32 rx_flags_last = rx_flags | MCP25XXFD_CAN_FIFOCON_RXOVIE;
+
+	return mcp25xxfd_can_fifo_setup_config(cpriv, &cpriv->fifos.rx,
+					       rx_flags, rx_flags_last);
+}
+
+static int mcp25xxfd_can_fifo_setup_rxfilter(struct mcp25xxfd_can_priv *cpriv)
+{
+	u8 filter_con[32];
+	int c, f;
+
+	/* clear the filters and filter mappings for all filters */
+	memset(filter_con, 0, sizeof(filter_con));
+
+	/* and now set up the rx filters */
+	for (c = 0, f = cpriv->fifos.rx.start; c < cpriv->fifos.rx.count;
+	     c++, f++) {
+		/* set up filter config - we can use the mask of filter 0 */
+		filter_con[c] = MCP25XXFD_CAN_FIFOCON_FLTEN(0) |
+			(f << MCP25XXFD_CAN_FILCON_SHIFT(0));
+	}
+
+	/* and set up filter control */
+	return mcp25xxfd_cmd_write_regs(cpriv->priv->spi,
+					MCP25XXFD_CAN_FLTCON(0),
+					(u32 *)filter_con, sizeof(filter_con));
+}
+
+static int mcp25xxfd_can_fifo_compute(struct mcp25xxfd_can_priv *cpriv)
+{
+	int tef_memory_used, tx_memory_used, rx_memory_available;
+
+	/* default settings as per MTU/CANFD */
+	switch (cpriv->can.dev->mtu) {
+	case CAN_MTU:
+		/* mtu is 8 */
+		cpriv->fifos.payload_size = 8;
+		cpriv->fifos.payload_mode = MCP25XXFD_CAN_TXQCON_PLSIZE_8;
+
+		/* 6 tx fifos */
+		cpriv->fifos.tx.count = 6;
+
+		break;
+	case CANFD_MTU:
+		/* wish there was a way to have hw filters
+		 * that can separate based on length ...
+		 */
+		/* MTU is 64 */
+		cpriv->fifos.payload_size = 64;
+		cpriv->fifos.payload_mode = MCP25XXFD_CAN_TXQCON_PLSIZE_64;
+
+		/* 6 tx fifos */
+		cpriv->fifos.tx.count = 6;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* compute effective sizes */
+	cpriv->fifos.tef.size = sizeof(struct mcp25xxfd_can_obj_tef);
+	cpriv->fifos.tx.size = sizeof(struct mcp25xxfd_can_obj_tx) +
+		cpriv->fifos.payload_size;
+	cpriv->fifos.rx.size = sizeof(struct mcp25xxfd_can_obj_rx) +
+		cpriv->fifos.payload_size;
+
+	/* if defined as a module parameter modify the number of tx_fifos */
+	if (tx_fifos) {
+		netdev_info(cpriv->can.dev,
+			    "Using %i tx-fifos as per module parameter\n",
+			    tx_fifos);
+		cpriv->fifos.tx.count = tx_fifos;
+		if (tx_fifos > 6)
+			netdev_info(cpriv->can.dev,
+				    "You may trigger a bug where during a spi transfer bit 7, 15, 23 or 31 of TXREQ may flip due to CAN bus activity or similar so the recommended value is < 7\n");
+	}
+
+	/* there can be at the most 30 tx fifos (TEF and at least 1 RX fifo */
+	if (cpriv->fifos.tx.count > 30) {
+		netdev_err(cpriv->can.dev,
+			   "There is an absolute maximum of 30 tx-fifos\n");
+		return -EINVAL;
+	}
+
+	/* set tef fifos to the number of tx fifos */
+	cpriv->fifos.tef.count = cpriv->fifos.tx.count;
+
+	/* compute size of the tx fifos and TEF */
+	tx_memory_used = cpriv->fifos.tx.count * cpriv->fifos.tx.size;
+	tef_memory_used = cpriv->fifos.tef.count * cpriv->fifos.tef.size;
+
+	/* calculate evailable memory for RX_fifos */
+	rx_memory_available = MCP25XXFD_SRAM_SIZE - tx_memory_used -
+		tef_memory_used;
+
+	/* we need at least one RX Frame */
+	if (rx_memory_available < cpriv->fifos.rx.size) {
+		netdev_err(cpriv->can.dev,
+			   "Configured %i tx-fifos exceeds available memory already\n",
+			   cpriv->fifos.tx.count);
+		return -EINVAL;
+	}
+
+	/* calculate possible amount of RX fifos */
+	cpriv->fifos.rx.count = rx_memory_available / cpriv->fifos.rx.size;
+
+	/* so now calculate effective number of rx-fifos
+	 * there are only 31 fifos available in total,
+	 * so we need to limit ourselves
+	 */
+	if (cpriv->fifos.rx.count + cpriv->fifos.tx.count > 31)
+		cpriv->fifos.rx.count = 31 - cpriv->fifos.tx.count;
+
+	/* define the layout now that we have gotten everything */
+	cpriv->fifos.tx.start = 1;
+	cpriv->fifos.rx.start = cpriv->fifos.tx.start + cpriv->fifos.tx.count;
+
+	return 0;
+}
+
+static int mcp25xxfd_can_fifo_clear_regs(struct mcp25xxfd_can_priv *cpriv,
+					 u32 start, u32 end)
+{
+	size_t len = end - start;
+	u8 *data = kzalloc(len, GFP_KERNEL);
+	int ret;
+
+	if (!data)
+		return -ENOMEM;
+
+	ret = mcp25xxfd_cmd_write_regs(cpriv->priv->spi,
+				       start, (u32 *)data, len);
+
+	kfree(data);
+
+	return ret;
+}
+
+static int mcp25xxfd_can_fifo_clear(struct mcp25xxfd_can_priv *cpriv)
+{
+	int ret;
+
+	memset(&cpriv->fifos.info, 0, sizeof(cpriv->fifos.info));
+	memset(&cpriv->fifos.tx, 0, sizeof(cpriv->fifos.tx));
+	memset(&cpriv->fifos.rx, 0, sizeof(cpriv->fifos.rx));
+
+	/* clear FIFO config */
+	ret = mcp25xxfd_can_fifo_clear_regs(cpriv, MCP25XXFD_CAN_FIFOCON(1),
+					    MCP25XXFD_CAN_FIFOCON(32));
+	if (ret)
+		return ret;
+
+	/* clear the filter mask - match any frame with every filter */
+	return mcp25xxfd_can_fifo_clear_regs(cpriv, MCP25XXFD_CAN_FLTCON(0),
+					     MCP25XXFD_CAN_FLTCON(32));
+}
+
+int mcp25xxfd_can_fifo_setup(struct mcp25xxfd_can_priv *cpriv)
+{
+	int ret;
+
+	/* clear fifo config */
+	ret = mcp25xxfd_can_fifo_clear(cpriv);
+	if (ret)
+		return ret;
+
+	/* compute fifos counts */
+	ret = mcp25xxfd_can_fifo_compute(cpriv);
+	if (ret)
+		return ret;
+
+	/* configure TEF */
+	if (cpriv->fifos.tef.count)
+		cpriv->regs.tefcon =
+			MCP25XXFD_CAN_TEFCON_FRESET |
+			MCP25XXFD_CAN_TEFCON_TEFNEIE |
+			MCP25XXFD_CAN_TEFCON_TEFTSEN |
+			((cpriv->fifos.tef.count - 1) <<
+			 MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT);
+	else
+		cpriv->regs.tefcon = 0;
+	ret = mcp25xxfd_cmd_write(cpriv->priv->spi, MCP25XXFD_CAN_TEFCON,
+				  cpriv->regs.tefcon);
+	if (ret)
+		return ret;
+
+	/* TXQueue disabled */
+	ret = mcp25xxfd_cmd_write(cpriv->priv->spi, MCP25XXFD_CAN_TXQCON, 0);
+	if (ret)
+		return ret;
+
+	/* configure FIFOS themselves */
+	ret = mcp25xxfd_can_fifo_setup_tx(cpriv);
+	if (ret)
+		return ret;
+	ret = mcp25xxfd_can_fifo_setup_rx(cpriv);
+	if (ret)
+		return ret;
+	ret = mcp25xxfd_can_fifo_setup_rxfilter(cpriv);
+	if (ret)
+		return ret;
+
+	/* get fifo addresses */
+	ret = mcp25xxfd_can_fifo_get_address(cpriv);
+	if (ret)
+		return ret;
+
+	/* setup tx_fifo_queue */
+	ret = mcp25xxfd_can_tx_queue_alloc(cpriv);
+	if (ret)
+		return ret;
+
+	/* add the can info to debugfs */
+	mcp25xxfd_can_debugfs_setup(cpriv);
+
+	return 0;
+}
+
+void mcp25xxfd_can_fifo_release(struct mcp25xxfd_can_priv *cpriv)
+{
+	mcp25xxfd_can_tx_queue_free(cpriv);
+	mcp25xxfd_can_fifo_clear(cpriv);
+	mcp25xxfd_can_debugfs_remove(cpriv);
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h
new file mode 100644
index 000000000000..ed2daa05220a
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_FIFO_H
+#define __MCP25XXFD_CAN_FIFO_H
+
+#include "mcp25xxfd_can_priv.h"
+
+int mcp25xxfd_can_fifo_setup(struct mcp25xxfd_can_priv *cpriv);
+void mcp25xxfd_can_fifo_release(struct mcp25xxfd_can_priv *cpriv);
+
+#endif /* __MCP25XXFD_CAN_FIFO_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h
new file mode 100644
index 000000000000..00a6c6639bd5
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_IF_H
+#define __MCP25XXFD_CAN_IF_H
+
+#include <uapi/linux/can.h>
+
+#include "mcp25xxfd_can_id.h"
+#include "mcp25xxfd_regs.h"
+
+/* ideally these would be defined in uapi/linux/can.h */
+#define MCP25XXFD_CAN_EFF_SID_SHIFT	(CAN_EFF_ID_BITS - CAN_SFF_ID_BITS)
+#define MCP25XXFD_CAN_EFF_SID_BITS	CAN_SFF_ID_BITS
+#define MCP25XXFD_CAN_EFF_SID_MASK					\
+	GENMASK(MCP25XXFD_CAN_EFF_SID_SHIFT + MCP25XXFD_CAN_EFF_SID_BITS - 1, \
+		MCP25XXFD_CAN_EFF_SID_SHIFT)
+#define MCP25XXFD_CAN_EFF_EID_SHIFT	0
+#define MCP25XXFD_CAN_EFF_EID_BITS	MCP25XXFD_CAN_EFF_SID_SHIFT
+#define MCP25XXFD_CAN_EFF_EID_MASK					\
+	GENMASK(MCP25XXFD_CAN_EFF_EID_SHIFT + MCP25XXFD_CAN_EFF_EID_BITS - 1, \
+		MCP25XXFD_CAN_EFF_EID_SHIFT)
+
+static inline
+void mcp25xxfd_can_id_from_mcp25xxfd(u32 mcp_id, u32 mcp_flags, u32 *can_id)
+{
+	u32 sid = (mcp_id & MCP25XXFD_CAN_OBJ_ID_SID_MASK) >>
+		MCP25XXFD_CAN_OBJ_ID_SID_SHIFT;
+	u32 eid = (mcp_id & MCP25XXFD_CAN_OBJ_ID_EID_MASK) >>
+		MCP25XXFD_CAN_OBJ_ID_EID_SHIFT;
+
+	/* select normal or extended ids */
+	if (mcp_flags & MCP25XXFD_CAN_OBJ_FLAGS_IDE) {
+		*can_id = (eid << MCP25XXFD_CAN_EFF_EID_SHIFT) |
+			(sid << MCP25XXFD_CAN_EFF_SID_SHIFT) |
+			CAN_EFF_FLAG;
+	} else {
+		*can_id = sid << MCP25XXFD_CAN_EFF_EID_SHIFT;
+	}
+	/* handle rtr */
+	*can_id |= (mcp_flags & MCP25XXFD_CAN_OBJ_FLAGS_RTR) ? CAN_RTR_FLAG : 0;
+}
+
+static inline
+void mcp25xxfd_can_id_to_mcp25xxfd(u32 can_id, u32 *id, u32 *flags)
+{
+	/* depending on can_id flag compute extended or standard ids */
+	if (can_id & CAN_EFF_FLAG) {
+		int sid = (can_id & MCP25XXFD_CAN_EFF_SID_MASK) >>
+			MCP25XXFD_CAN_EFF_SID_SHIFT;
+		int eid = (can_id & MCP25XXFD_CAN_EFF_EID_MASK) >>
+			MCP25XXFD_CAN_EFF_EID_SHIFT;
+		*id = (eid << MCP25XXFD_CAN_OBJ_ID_EID_SHIFT) |
+			(sid << MCP25XXFD_CAN_OBJ_ID_SID_SHIFT);
+		*flags = MCP25XXFD_CAN_OBJ_FLAGS_IDE;
+	} else {
+		*id = can_id & CAN_SFF_MASK;
+		*flags = 0;
+	}
+
+	/* Handle RTR */
+	*flags |= (can_id & CAN_RTR_FLAG) ? MCP25XXFD_CAN_OBJ_FLAGS_RTR : 0;
+}
+
+#endif /* __MCP25XXFD_CAN_IF_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c
new file mode 100644
index 000000000000..3625567ffa15
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c
@@ -0,0 +1,734 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+
+#include "mcp25xxfd_regs.h"
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_can_debugfs.h"
+#include "mcp25xxfd_can_int.h"
+#include "mcp25xxfd_can_priv.h"
+#include "mcp25xxfd_can_rx.h"
+#include "mcp25xxfd_can_tx.h"
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_ecc.h"
+#include "mcp25xxfd_int.h"
+
+static unsigned int reschedule_int_thread_after = 4;
+module_param(reschedule_int_thread_after, uint, 0664);
+MODULE_PARM_DESC(reschedule_int_thread_after,
+		 "Reschedule the interrupt thread after this many loops\n");
+
+static void mcp25xxfd_can_int_send_error_skb(struct mcp25xxfd_can_priv *cpriv)
+{
+	struct net_device *net = cpriv->can.dev;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	/* allocate error frame */
+	skb = alloc_can_err_skb(net, &frame);
+	if (!skb) {
+		netdev_err(net, "cannot allocate error skb\n");
+		return;
+	}
+
+	/* setup can error frame data */
+	frame->can_id |= cpriv->error_frame.id;
+	memcpy(frame->data, cpriv->error_frame.data, sizeof(frame->data));
+
+	/* and submit it */
+	netif_receive_skb(skb);
+}
+
+static int mcp25xxfd_can_int_compare_obj_ts(const void *a, const void *b)
+{
+	s32 ats = ((struct mcp25xxfd_obj_ts *)a)->ts;
+	s32 bts = ((struct mcp25xxfd_obj_ts *)b)->ts;
+
+	if (ats < bts)
+		return -1;
+	if (ats > bts)
+		return 1;
+	return 0;
+}
+
+static int mcp25xxfd_can_int_submit_frames(struct mcp25xxfd_can_priv *cpriv)
+{
+	struct mcp25xxfd_obj_ts *queue = cpriv->fifos.submit_queue;
+	int count = cpriv->fifos.submit_queue_count;
+	int i, fifo;
+	int ret;
+
+	/* skip processing if the queue count is 0 */
+	if (count == 0)
+		goto out;
+
+	/* sort the fifos (rx and tx - actually TEF) by receive timestamp */
+	sort(queue, count, sizeof(*queue),
+	     mcp25xxfd_can_int_compare_obj_ts, NULL);
+
+	/* now submit the fifos  */
+	for (i = 0; i < count; i++) {
+		fifo = queue[i].fifo;
+		ret = (queue[i].is_rx) ?
+			mcp25xxfd_can_rx_submit_frame(cpriv, fifo) :
+			mcp25xxfd_can_tx_submit_frame(cpriv, fifo);
+		if (ret)
+			return ret;
+	}
+
+	/* if we have received or transmitted something
+	 * and the IVMIE is disabled, then enable it
+	 * this is mostly to avoid unnecessary interrupts during a
+	 * disconnected CAN BUS
+	 */
+	if (!(cpriv->status.intf | MCP25XXFD_CAN_INT_IVMIE)) {
+		cpriv->status.intf |= MCP25XXFD_CAN_INT_IVMIE;
+		ret = mcp25xxfd_cmd_write_mask(cpriv->priv->spi,
+					       MCP25XXFD_CAN_INT,
+					       cpriv->status.intf,
+					       MCP25XXFD_CAN_INT_IVMIE);
+		if (ret)
+			return ret;
+	}
+
+out:
+	/* enable tx_queue if necessary */
+	mcp25xxfd_can_tx_queue_restart(cpriv);
+
+	return 0;
+}
+
+static int mcp25xxfd_can_int_clear_int_flags(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 clearable_irq_active = cpriv->status.intf &
+		MCP25XXFD_CAN_INT_IF_CLEAR_MASK;
+	u32 clear_irq = cpriv->status.intf & (~MCP25XXFD_CAN_INT_IF_CLEAR_MASK);
+
+	/* if no clearable flags are set then skip the whole transfer */
+	if (!clearable_irq_active)
+		return 0;
+
+	return mcp25xxfd_cmd_write_mask(cpriv->priv->spi, MCP25XXFD_CAN_INT,
+					clear_irq, clearable_irq_active);
+}
+
+static
+int mcp25xxfd_can_int_handle_serrif_txmab(struct mcp25xxfd_can_priv *cpriv)
+{
+	int mode = mcp25xxfd_can_targetmode(cpriv);
+
+	cpriv->can.dev->stats.tx_fifo_errors++;
+	cpriv->can.dev->stats.tx_errors++;
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_serr_tx_count);
+
+	/* data7 contains custom mcp25xxfd error flags */
+	cpriv->error_frame.data[7] |= MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_TX;
+
+	/* and switch back into the correct mode */
+	return mcp25xxfd_can_switch_mode_no_wait(cpriv->priv,
+						 &cpriv->regs.con, mode);
+}
+
+static
+int mcp25xxfd_can_int_handle_serrif_rxmab(struct mcp25xxfd_can_priv *cpriv)
+{
+	cpriv->can.dev->stats.rx_dropped++;
+	cpriv->can.dev->stats.rx_errors++;
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_serr_rx_count);
+
+	/* data7 contains custom mcp25xxfd error flags */
+	cpriv->error_frame.data[7] |= MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_RX;
+
+	return 0;
+}
+
+static int mcp25xxfd_can_int_handle_serrif(struct mcp25xxfd_can_priv *cpriv)
+{
+	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_SERRIF))
+		return 0;
+
+	/* increment statistics counter now */
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_serr_count);
+
+	/* interrupt flags have been cleared already */
+
+	/* Errors here are:
+	 * * Bus Bandwidth Error: when a RX Message Assembly Buffer
+	 *   is still full when the next message has already arrived
+	 *   the recived message shall be ignored
+	 * * TX MAB Underflow: when a TX Message is invalid
+	 *   due to ECC errors or TXMAB underflow
+	 *   in this situatioon the system will transition to
+	 *   Restricted or Listen Only mode
+	 */
+
+	cpriv->error_frame.id |= CAN_ERR_CRTL;
+	cpriv->error_frame.data[1] |= CAN_ERR_CRTL_UNSPEC;
+
+	/* a mode change + invalid message would indicate
+	 * TX MAB Underflow
+	 */
+	if ((cpriv->status.intf & MCP25XXFD_CAN_INT_MODIF) &&
+	    (cpriv->status.intf & MCP25XXFD_CAN_INT_IVMIF)) {
+		return mcp25xxfd_can_int_handle_serrif_txmab(cpriv);
+	}
+
+	/* for RX there is only the RXIF an indicator
+	 * - surprizingly RX-MAB does not change mode or anything
+	 */
+	if (cpriv->status.intf & MCP25XXFD_CAN_INT_RXIF)
+		return mcp25xxfd_can_int_handle_serrif_rxmab(cpriv);
+
+	/* the final case */
+	dev_warn_ratelimited(&cpriv->priv->spi->dev,
+			     "unidentified system interrupt - intf =  %08x\n",
+			     cpriv->status.intf);
+
+	return 0;
+}
+
+static int mcp25xxfd_can_int_handle_modif(struct mcp25xxfd_can_priv *cpriv)
+{
+	struct spi_device *spi = cpriv->priv->spi;
+	int mode;
+	int ret;
+
+	/* Note that this irq does not get triggered in all situations
+	 * for example SERRIF will move to RESTICTED or LISTENONLY
+	 * but MODIF will not be raised!
+	 */
+
+	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_MODIF))
+		return 0;
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_mod_count);
+
+	/* get the current mode */
+	ret = mcp25xxfd_can_get_mode(cpriv->priv, &mode);
+	if (ret < 0)
+		return ret;
+	mode = ret;
+
+	/* switches to the same mode as before are ignored
+	 * - this typically happens if the driver is shortly
+	 *   switching to a different mode and then returning to the
+	 *   original mode
+	 */
+	if (mode == cpriv->mode)
+		return 0;
+
+	/* if we are restricted, then return to "normal" mode */
+	if (mode == MCP25XXFD_CAN_CON_MODE_RESTRICTED) {
+		cpriv->mode = mode;
+		mode = mcp25xxfd_can_targetmode(cpriv);
+		return mcp25xxfd_can_switch_mode_no_wait(cpriv->priv,
+							 &cpriv->regs.con,
+							 mode);
+	}
+
+	/* the controller itself will transition to sleep, so we ignore it */
+	if (mode == MCP25XXFD_CAN_CON_MODE_SLEEP) {
+		cpriv->mode = mode;
+		return 0;
+	}
+
+	/* these we need to handle correctly, so warn and give context */
+	dev_warn(&spi->dev,
+		 "Controller unexpectedly switched from mode %u to %u\n",
+		 cpriv->mode, mode);
+
+	/* assign the mode as current */
+	cpriv->mode = mode;
+
+	return 0;
+}
+
+static int mcp25xxfd_can_int_handle_eccif(struct mcp25xxfd_can_priv *cpriv)
+{
+	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_ECCIF))
+		return 0;
+
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_ecc_count);
+
+	/* and prepare ERROR FRAME */
+	cpriv->error_frame.id |= CAN_ERR_CRTL;
+	cpriv->error_frame.data[1] |= CAN_ERR_CRTL_UNSPEC;
+	/* data7 contains custom mcp25xxfd error flags */
+	cpriv->error_frame.data[7] |= MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_ECC;
+
+	/* delegate to interrupt cleaning */
+	return mcp25xxfd_ecc_clear_int(cpriv->priv);
+}
+
+static void mcp25xxfd_can_int_handle_ivmif_tx(struct mcp25xxfd_can_priv *cpriv,
+					      u32 *mask)
+{
+	/* check if it is really a known tx error */
+	if ((cpriv->bus.bdiag[1] &
+	     (MCP25XXFD_CAN_BDIAG1_DBIT1ERR |
+	      MCP25XXFD_CAN_BDIAG1_DBIT0ERR |
+	      MCP25XXFD_CAN_BDIAG1_NACKERR |
+	      MCP25XXFD_CAN_BDIAG1_NBIT1ERR |
+	      MCP25XXFD_CAN_BDIAG1_NBIT0ERR
+		     )) == 0)
+		return;
+
+	/* mark it as a protocol error */
+	cpriv->error_frame.id |= CAN_ERR_PROT;
+
+	/* and update statistics */
+	cpriv->can.dev->stats.tx_errors++;
+
+	/* and handle all the known cases */
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NACKERR) {
+		/* TX-Frame not acknowledged - connected to CAN-bus? */
+		*mask |= MCP25XXFD_CAN_BDIAG1_NACKERR;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_TX;
+		cpriv->can.dev->stats.tx_aborted_errors++;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NBIT1ERR) {
+		/* TX-Frame CAN-BUS Level is unexpectedly dominant */
+		*mask |= MCP25XXFD_CAN_BDIAG1_NBIT1ERR;
+		cpriv->can.dev->stats.tx_carrier_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT1;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NBIT0ERR) {
+		/* TX-Frame CAN-BUS Level is unexpectedly recessive */
+		*mask |= MCP25XXFD_CAN_BDIAG1_NBIT0ERR;
+		cpriv->can.dev->stats.tx_carrier_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT0;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DBIT1ERR) {
+		/* TX-Frame CAN-BUS Level is unexpectedly dominant
+		 * during data phase
+		 */
+		*mask |= MCP25XXFD_CAN_BDIAG1_DBIT1ERR;
+		cpriv->can.dev->stats.tx_carrier_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT1;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DBIT0ERR) {
+		/* TX-Frame CAN-BUS Level is unexpectedly recessive
+		 * during data phase
+		 */
+		*mask |= MCP25XXFD_CAN_BDIAG1_DBIT0ERR;
+		cpriv->can.dev->stats.tx_carrier_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT0;
+	}
+}
+
+static void mcp25xxfd_can_int_handle_ivmif_rx(struct mcp25xxfd_can_priv *cpriv,
+					      u32 *mask)
+{
+	/* check if it is really a known tx error */
+	if ((cpriv->bus.bdiag[1] &
+	     (MCP25XXFD_CAN_BDIAG1_DCRCERR |
+	      MCP25XXFD_CAN_BDIAG1_DSTUFERR |
+	      MCP25XXFD_CAN_BDIAG1_DFORMERR |
+	      MCP25XXFD_CAN_BDIAG1_NCRCERR |
+	      MCP25XXFD_CAN_BDIAG1_NSTUFERR |
+	      MCP25XXFD_CAN_BDIAG1_NFORMERR
+		     )) == 0)
+		return;
+
+	/* mark it as a protocol error */
+	cpriv->error_frame.id |= CAN_ERR_PROT;
+
+	/* and update statistics */
+	cpriv->can.dev->stats.rx_errors++;
+
+	/* handle the cases */
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DCRCERR) {
+		/* RX-Frame with bad CRC during data phase */
+		*mask |= MCP25XXFD_CAN_BDIAG1_DCRCERR;
+		cpriv->can.dev->stats.rx_crc_errors++;
+		cpriv->error_frame.data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DSTUFERR) {
+		/* RX-Frame with bad stuffing during data phase */
+		*mask |= MCP25XXFD_CAN_BDIAG1_DSTUFERR;
+		cpriv->can.dev->stats.rx_frame_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_STUFF;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DFORMERR) {
+		/* RX-Frame with bad format during data phase */
+		*mask |= MCP25XXFD_CAN_BDIAG1_DFORMERR;
+		cpriv->can.dev->stats.rx_frame_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_FORM;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NCRCERR) {
+		/* RX-Frame with bad CRC during data phase */
+		*mask |= MCP25XXFD_CAN_BDIAG1_NCRCERR;
+		cpriv->can.dev->stats.rx_crc_errors++;
+		cpriv->error_frame.data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NSTUFERR) {
+		/* RX-Frame with bad stuffing during data phase */
+		*mask |= MCP25XXFD_CAN_BDIAG1_NSTUFERR;
+		cpriv->can.dev->stats.rx_frame_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_STUFF;
+	}
+	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NFORMERR) {
+		/* RX-Frame with bad format during data phase */
+		*mask |= MCP25XXFD_CAN_BDIAG1_NFORMERR;
+		cpriv->can.dev->stats.rx_frame_errors++;
+		cpriv->error_frame.data[2] |= CAN_ERR_PROT_FORM;
+	}
+}
+
+static int mcp25xxfd_can_int_handle_ivmif(struct mcp25xxfd_can_priv *cpriv)
+{
+	struct spi_device *spi = cpriv->priv->spi;
+	u32 mask, bdiag1;
+	int ret;
+
+	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_IVMIF))
+		return 0;
+
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_ivm_count);
+
+	/* if we have a systemerror as well,
+	 * then ignore it as they correlate
+	 */
+	if (cpriv->status.intf & MCP25XXFD_CAN_INT_SERRIF)
+		return 0;
+
+	/* read bus diagnostics */
+	ret = mcp25xxfd_cmd_read_regs(spi, MCP25XXFD_CAN_BDIAG0,
+				      cpriv->bus.bdiag,
+				      sizeof(cpriv->bus.bdiag));
+	if (ret)
+		return ret;
+
+	/* clear the masks of bits to clear */
+	mask = 0;
+
+	/* check rx and tx errors */
+	mcp25xxfd_can_int_handle_ivmif_tx(cpriv, &mask);
+	mcp25xxfd_can_int_handle_ivmif_rx(cpriv, &mask);
+
+	/* clear flags if we have bits masked */
+	if (!mask) {
+		/* the unsupported case, where we are not
+		 * clearing any registers
+		 */
+		dev_warn_once(&spi->dev,
+			      "found IVMIF situation not supported by driver - bdiag = [0x%08x, 0x%08x]",
+			      cpriv->bus.bdiag[0], cpriv->bus.bdiag[1]);
+		return -EINVAL;
+	}
+
+	/* clear the bits in bdiag1 */
+	bdiag1 = cpriv->bus.bdiag[1] & (~mask);
+	/* and write it */
+	ret = mcp25xxfd_cmd_write_mask(spi, MCP25XXFD_CAN_BDIAG1, bdiag1, mask);
+	if (ret)
+		return ret;
+
+	/* and clear the interrupt flag until we have received or transmited */
+	cpriv->status.intf &= ~(MCP25XXFD_CAN_INT_IVMIE);
+	return mcp25xxfd_cmd_write_mask(spi, MCP25XXFD_CAN_INT,
+					cpriv->status.intf,
+					MCP25XXFD_CAN_INT_IVMIE);
+}
+
+static int mcp25xxfd_can_int_handle_cerrif(struct mcp25xxfd_can_priv *cpriv)
+{
+	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_CERRIF))
+		return 0;
+
+	/* this interrupt exists primarilly to counter possible
+	 * bus off situations more detailed information
+	 * can be found and controlled in the TREC register
+	 */
+
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_cerr_count);
+
+	netdev_warn(cpriv->can.dev, "CAN Bus error experienced");
+
+	return 0;
+}
+
+static int mcp25xxfd_can_int_error_counters(struct mcp25xxfd_can_priv *cpriv)
+{
+	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_TXWARN) {
+		cpriv->bus.new_state = CAN_STATE_ERROR_WARNING;
+		cpriv->error_frame.id |= CAN_ERR_CRTL;
+		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_TX_WARNING;
+	}
+	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_RXWARN) {
+		cpriv->bus.new_state = CAN_STATE_ERROR_WARNING;
+		cpriv->error_frame.id |= CAN_ERR_CRTL;
+		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_RX_WARNING;
+	}
+	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_TXBP) {
+		cpriv->bus.new_state = CAN_STATE_ERROR_PASSIVE;
+		cpriv->error_frame.id |= CAN_ERR_CRTL;
+		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+	}
+	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_RXBP) {
+		cpriv->bus.new_state = CAN_STATE_ERROR_PASSIVE;
+		cpriv->error_frame.id |= CAN_ERR_CRTL;
+		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+	}
+	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_TXBO) {
+		cpriv->bus.new_state = CAN_STATE_BUS_OFF;
+		cpriv->error_frame.id |= CAN_ERR_BUSOFF;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_can_int_error_handling(struct mcp25xxfd_can_priv *cpriv)
+{
+	/* based on the last state state check the new state */
+	switch (cpriv->can.state) {
+	case CAN_STATE_ERROR_ACTIVE:
+		if (cpriv->bus.new_state >= CAN_STATE_ERROR_WARNING &&
+		    cpriv->bus.new_state <= CAN_STATE_BUS_OFF)
+			cpriv->can.can_stats.error_warning++;
+		/* fallthrough */
+	case CAN_STATE_ERROR_WARNING:
+		if (cpriv->bus.new_state >= CAN_STATE_ERROR_PASSIVE &&
+		    cpriv->bus.new_state <= CAN_STATE_BUS_OFF)
+			cpriv->can.can_stats.error_passive++;
+		break;
+	default:
+		break;
+	}
+	cpriv->can.state = cpriv->bus.new_state;
+
+	/* and send error packet */
+	if (cpriv->error_frame.id)
+		mcp25xxfd_can_int_send_error_skb(cpriv);
+
+	/* handle BUS OFF */
+	if (cpriv->can.state == CAN_STATE_BUS_OFF) {
+		if (cpriv->can.restart_ms == 0) {
+			cpriv->can.can_stats.bus_off++;
+			can_bus_off(cpriv->can.dev);
+		}
+	} else {
+		/* restart the tx queue if needed */
+		mcp25xxfd_can_tx_queue_restart(cpriv);
+	}
+
+	return 0;
+}
+
+
+static int mcp25xxfd_can_int_handle_status(struct mcp25xxfd_can_priv *cpriv)
+{
+	char *errfunc;
+	int ret;
+
+#define HANDLE_ERROR(name) if (ret) { errfunc = name; goto err; }
+
+	/* clear all the interrupts asap - we have them on file allready */
+	ret = mcp25xxfd_can_int_clear_int_flags(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_clear_int_flags");
+
+	/* set up new state and error frame for this loop */
+	cpriv->bus.new_state = cpriv->bus.state;
+	memset(&cpriv->error_frame, 0, sizeof(cpriv->error_frame));
+
+	/* setup the process queue by clearing the counter */
+	cpriv->fifos.submit_queue_count = 0;
+
+	/* handle interrupts */
+
+	/* system error interrupt needs to get handled first
+	 * to get us out of restricted mode
+	 */
+	ret = mcp25xxfd_can_int_handle_serrif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_handle_serrif");
+
+	/* mode change interrupt */
+	ret = mcp25xxfd_can_int_handle_modif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_handle_modif");
+
+	/* handle the rx */
+	ret = mcp25xxfd_can_rx_handle_int_rxif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_rx_handle_int_rxif");
+
+	/* handle aborted TX FIFOs */
+	ret = mcp25xxfd_can_tx_handle_int_txatif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_tx_handle_int_txatif");
+
+	/* handle the TEF */
+	ret = mcp25xxfd_can_tx_handle_int_tefif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_rx_handle_int_tefif");
+
+	/* handle error interrupt flags */
+	ret = mcp25xxfd_can_rx_handle_int_rxovif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_rx_handle_int_rxovif");
+
+	/* sram ECC error interrupt */
+	ret = mcp25xxfd_can_int_handle_eccif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_handle_eccif");
+
+	/* message format interrupt */
+	ret = mcp25xxfd_can_int_handle_ivmif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_handle_ivmif");
+
+	/* handle bus errors in more detail */
+	ret = mcp25xxfd_can_int_handle_cerrif(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_handle_cerrif");
+
+	/* error counter handling */
+	ret = mcp25xxfd_can_int_error_counters(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_error_counters");
+
+	/* error counter handling */
+	ret = mcp25xxfd_can_int_error_handling(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_error_handling");
+
+	/* and submit can frames to network stack */
+	ret = mcp25xxfd_can_int_submit_frames(cpriv);
+	HANDLE_ERROR("mcp25xxfd_can_int_submit_frames");
+
+	return 0;
+err:
+	netdev_err(cpriv->can.dev, "%s returned with error code %i\n",
+		   errfunc, ret);
+	return ret;
+}
+#undef HANDLE_ERROR
+
+irqreturn_t mcp25xxfd_can_int(int irq, void *dev_id)
+{
+	struct mcp25xxfd_can_priv *cpriv = dev_id;
+	int loops, ret;
+
+	/* count interrupt calls */
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, irq_calls);
+
+	/* loop forever unless we need to exit */
+	for (loops = 0; true; loops++) {
+		/* count irq loops */
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, irq_loops);
+
+		/* read interrupt status flags in bulk */
+		ret = mcp25xxfd_cmd_read_regs(cpriv->priv->spi,
+					      MCP25XXFD_CAN_INT,
+					      &cpriv->status.intf,
+					      sizeof(cpriv->status));
+		switch (ret) {
+		case 0: /* no errors, so process */
+			break;
+		case -EILSEQ: /* a crc error, so run the loop again */
+			continue;
+		default: /* all other error cases */
+			netdev_err(cpriv->can.dev,
+				   "reading can registers returned with error code %i\n",
+				   ret);
+			goto fail;
+		}
+
+		/* only act if the IE mask configured has active IF bits
+		 * otherwise the Interrupt line should be deasserted already
+		 * so we can exit the loop
+		 */
+		if (((cpriv->status.intf >> MCP25XXFD_CAN_INT_IE_SHIFT) &
+		       cpriv->status.intf) == 0)
+			break;
+
+		/* handle the interrupts for real */
+		ret = mcp25xxfd_can_int_handle_status(cpriv);
+		switch (ret) {
+		case 0: /* no errors, so process */
+		case -EILSEQ: /* a crc error, so run the loop again */
+			break;
+		default: /* all other error cases */
+			goto fail;
+		}
+
+		/* allow voluntarily rescheduling every so often to avoid
+		 * long CS lows at the end of a transfer on low power CPUs
+		 * avoiding SERR happening
+		 */
+		if (loops % reschedule_int_thread_after == 0) {
+			MCP25XXFD_DEBUGFS_STATS_INCR(cpriv,
+						     irq_thread_rescheduled);
+			cond_resched();
+		}
+	}
+
+	return IRQ_HANDLED;
+
+fail:
+ 	netdev_err(cpriv->can.dev,
+		   "experienced unexpected error %i in interrupt handler - disabling interrupts\n",
+ 		   ret);
+	/* note that if we experienced an spi error,
+	 * then this would produce another error
+	 */
+	mcp25xxfd_int_enable(cpriv->priv, false);
+
+	/* we could also put the driver in bus-off mode */
+
+	return IRQ_HANDLED;
+}
+
+int mcp25xxfd_can_int_clear(struct mcp25xxfd_priv *priv)
+{
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CAN_INT, 0,
+					MCP25XXFD_CAN_INT_IF_MASK);
+}
+
+int mcp25xxfd_can_int_enable(struct mcp25xxfd_priv *priv, bool enable)
+{
+	struct mcp25xxfd_can_priv *cpriv = priv->cpriv;
+	const u32 mask = MCP25XXFD_CAN_INT_TEFIE |
+		MCP25XXFD_CAN_INT_RXIE |
+		MCP25XXFD_CAN_INT_MODIE |
+		MCP25XXFD_CAN_INT_SERRIE |
+		MCP25XXFD_CAN_INT_IVMIE |
+		MCP25XXFD_CAN_INT_CERRIE |
+		MCP25XXFD_CAN_INT_RXOVIE |
+		MCP25XXFD_CAN_INT_ECCIE;
+	u32 value = cpriv ? cpriv->status.intf : 0;
+	int ret;
+
+	/* apply mask and */
+	value &= ~(MCP25XXFD_CAN_INT_IE_MASK);
+	if (enable)
+		value |= mask;
+
+	/* and write to int register */
+	ret = mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CAN_INT,
+				       value, mask);
+	if (ret)
+		return ret;
+	if (!cpriv)
+		return 0;
+
+	cpriv->status.intf = value;
+
+	/* enable/disable interrupt handler */
+	if (cpriv->irq.allocated) {
+		if (enable && !cpriv->irq.enabled)
+			enable_irq(cpriv->priv->spi->irq);
+		if (!enable && cpriv->irq.enabled)
+			disable_irq(cpriv->priv->spi->irq);
+		cpriv->irq.enabled = enable;
+	} else {
+		cpriv->irq.enabled = false;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h
new file mode 100644
index 000000000000..cc2ad992c307
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_CAN_INT_H
+#define __MCP25XXFD_CAN_INT_H
+
+#include "mcp25xxfd_priv.h"
+
+int mcp25xxfd_can_int_clear(struct mcp25xxfd_priv *priv);
+int mcp25xxfd_can_int_enable(struct mcp25xxfd_priv *priv, bool enable);
+
+irqreturn_t mcp25xxfd_can_int(int irq, void *dev_id);
+
+#endif /* __MCP25XXFD_CAN_INT_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h
new file mode 100644
index 000000000000..eeb9c88c7e97
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h
@@ -0,0 +1,203 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_PRIV_H
+#define __MCP25XXFD_CAN_PRIV_H
+
+#include <linux/can/dev.h>
+#include <linux/dcache.h>
+
+#include "mcp25xxfd_priv.h"
+
+#define TX_ECHO_SKB_MAX	32
+
+/* information on each fifo type */
+struct mcp25xxfd_fifo {
+	u32 count;
+	u32 start;
+	u32 size;
+#ifdef CONFIG_DEBUG_FS
+	u64 dlc_usage[16];
+	u64 fd_count;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+/* used for sorting incoming messages */
+struct mcp25xxfd_obj_ts {
+	s32 ts; /* using signed to handle rollover correctly when sorting */
+	u16 fifo;
+	s16 is_rx;
+};
+
+/* general info on each fifo */
+struct mcp25xxfd_fifo_info {
+	u32 is_rx;
+	u32 offset;
+	u32 priority;
+#ifdef CONFIG_DEBUG_FS
+	u64 use_count;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+struct mcp25xxfd_can_priv {
+	/* can_priv has to be the first one to be usable with alloc_candev
+	 * which expects struct can_priv to be right at the start of the
+	 * priv structure
+	 */
+	struct can_priv can;
+	struct mcp25xxfd_priv *priv;
+	struct regulator *transceiver;
+
+	/* the can mode currently active */
+	int mode;
+
+	/* interrupt state */
+	struct {
+		int enabled;
+		int allocated;
+	} irq;
+
+	/* can config registers */
+	struct {
+		u32 con;
+		u32 tdc;
+		u32 tscon;
+		u32 tefcon;
+		u32 nbtcfg;
+		u32 dbtcfg;
+	} regs;
+
+	/* can status registers (mostly) - read in one go
+	 * bdiag0 and bdiag1 are optional, but when
+	 * berr counters are requested on a regular basis
+	 * during high CAN-bus load this would trigger the fact
+	 * that spi_sync would get queued for execution in the
+	 * spi thread and the spi handler would not get
+	 * called inline in the interrupt thread without any
+	 * context switches or wakeups...
+	 */
+	struct {
+		u32 intf;
+		/* ASSERT(CAN_INT + 4 == CAN_RXIF) */
+		u32 rxif;
+		/* ASSERT(CAN_RXIF + 4 == CAN_TXIF) */
+		u32 txif;
+		/* ASSERT(CAN_TXIF + 4 == CAN_RXOVIF) */
+		u32 rxovif;
+		/* ASSERT(CAN_RXOVIF + 4 == CAN_TXATIF) */
+		u32 txatif;
+		/* ASSERT(CAN_TXATIF + 4 == CAN_TXREQ) */
+		u32 txreq;
+		/* ASSERT(CAN_TXREQ + 4 == CAN_TREC) */
+		u32 trec;
+	} status;
+
+	/* information of fifo setup */
+	struct {
+		/* define payload size and mode */
+		u32 payload_size;
+		u32 payload_mode;
+
+		/* infos on fifo layout */
+
+		/* TEF */
+		struct {
+			u32 count;
+			u32 size;
+			u32 index;
+		} tef;
+
+		/* info on each fifo */
+		struct mcp25xxfd_fifo_info info[32];
+
+		/* extra info on rx/tx fifo groups */
+		struct mcp25xxfd_fifo tx;
+		struct mcp25xxfd_fifo rx;
+
+		/* queue of can frames that need to get submitted
+		 * to the network stack during an interrupt loop in one go
+		 * (this gets sorted by timestamp before submission
+		 * and contains both rx frames as well tx frames that have
+		 * gone over the CAN bus successfully
+		 */
+		struct mcp25xxfd_obj_ts submit_queue[32];
+		int  submit_queue_count;
+
+		/* the tx queue of spi messages */
+		struct mcp25xxfd_tx_spi_message_queue *tx_queue;
+	} fifos;
+
+	/* statistics exposed via debugfs */
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_dir;
+
+	struct {
+		u64 irq_calls;
+		u64 irq_loops;
+		u64 irq_thread_rescheduled;
+
+		u64 int_serr_count;
+		u64 int_serr_rx_count;
+		u64 int_serr_tx_count;
+		u64 int_mod_count;
+		u64 int_rx_count;
+		u64 int_txat_count;
+		u64 int_tef_count;
+		u64 int_rxov_count;
+		u64 int_ecc_count;
+		u64 int_ivm_count;
+		u64 int_cerr_count;
+
+		u64 tx_fd_count;
+		u64 tx_brs_count;
+
+		u64 tef_reads;
+		u64 tef_read_splits;
+		u64 tef_conservative_reads;
+		u64 tef_optimized_reads;
+#define MCP25XXFD_CAN_TEF_READ_BINS 8
+		u64 tef_optimized_read_sizes[MCP25XXFD_CAN_TEF_READ_BINS];
+
+		u64 rx_reads;
+		u64 rx_reads_prefetched_too_few;
+		u64 rx_reads_prefetched_too_few_bytes;
+		u64 rx_reads_prefetched_too_many;
+		u64 rx_reads_prefetched_too_many_bytes;
+		u64 rx_single_reads;
+		u64 rx_bulk_reads;
+#define MCP25XXFD_CAN_RX_BULK_READ_BINS 8
+		u64 rx_bulk_read_sizes[MCP25XXFD_CAN_RX_BULK_READ_BINS];
+	} stats;
+#endif /* CONFIG_DEBUG_FS */
+
+	/* history of rx-dlc */
+	struct {
+#define MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE 32
+		u8 dlc[MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE];
+		u8 brs[MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE];
+		u8 index;
+		u32 predicted_len;
+	} rx_history;
+
+	/* bus state */
+	struct {
+		u32 state;
+		u32 new_state;
+		u32 bdiag[2];
+	} bus;
+
+	/* can error messages */
+	struct {
+		u32 id;
+		u8  data[8];
+	} error_frame;
+
+	/* a copy of mcp25xxfd-sram in ram */
+	u8 sram[MCP25XXFD_SRAM_SIZE];
+};
+
+#endif /* __MCP25XXFD_CAN_PRIV_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c
new file mode 100644
index 000000000000..0e3334f83f57
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c
@@ -0,0 +1,521 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ *
+ * Based on Microchip MCP251x CAN controller driver written by
+ * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
+ */
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_can_debugfs.h"
+#include "mcp25xxfd_can_id.h"
+#include "mcp25xxfd_can_priv.h"
+#include "mcp25xxfd_can_rx.h"
+
+/* module parameters */
+static unsigned int rx_prefetch_bytes = -1;
+module_param(rx_prefetch_bytes, uint, 0664);
+MODULE_PARM_DESC(rx_prefetch_bytes,
+		 "number of bytes to blindly prefetch when reading a rx-fifo");
+
+static struct sk_buff *
+mcp25xxfd_can_rx_submit_normal_frame(struct mcp25xxfd_can_priv *cpriv,
+				     u32 id, u32 dlc, u8 **data)
+{
+	struct can_frame *frame;
+	struct sk_buff *skb;
+
+	/* allocate frame */
+	skb = alloc_can_skb(cpriv->can.dev, &frame);
+	if (!skb)
+		return NULL;
+
+	/* set id, dlc and flags */
+	frame->can_id = id;
+	frame->can_dlc = dlc;
+
+	/* and set the pointer to data */
+	*data = frame->data;
+
+	return skb;
+}
+
+/* it is almost identical except for the type of the frame... */
+static struct sk_buff *
+mcp25xxfd_can_rx_submit_fd_frame(struct mcp25xxfd_can_priv *cpriv,
+				 u32 id, u32 flags, u32 len, u8 **data)
+{
+	struct canfd_frame *frame;
+	struct sk_buff *skb;
+
+	/* allocate frame */
+	skb = alloc_canfd_skb(cpriv->can.dev, &frame);
+	if (!skb)
+		return NULL;
+
+	/* set id, dlc and flags */
+	frame->can_id = id;
+	frame->len = len;
+	frame->flags |= flags;
+
+	/* and set the pointer to data */
+	*data = frame->data;
+
+	return skb;
+}
+
+int mcp25xxfd_can_rx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo)
+{
+	struct net_device *net = cpriv->can.dev;
+	int addr = cpriv->fifos.info[fifo].offset;
+	struct mcp25xxfd_can_obj_rx *rx =
+		(struct mcp25xxfd_can_obj_rx *)(cpriv->sram + addr);
+	u8 *data = NULL;
+	struct sk_buff *skb;
+	u32 id, dlc, len, flags;
+
+	/* compute the can_id */
+	mcp25xxfd_can_id_from_mcp25xxfd(rx->id, rx->flags, &id);
+
+	/* and dlc */
+	dlc = (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK) >>
+		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
+	len = can_dlc2len(dlc);
+
+	/* update stats */
+	net->stats.rx_packets++;
+	net->stats.rx_bytes += len;
+	cpriv->fifos.rx.dlc_usage[dlc]++;
+	if (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_FDF)
+		MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.rx.fd_count);
+
+	/* add to rx_history */
+	cpriv->rx_history.dlc[cpriv->rx_history.index] = dlc;
+	cpriv->rx_history.brs[cpriv->rx_history.index] =
+		(rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_BRS) ? CANFD_BRS : 0;
+	cpriv->rx_history.index++;
+	if (cpriv->rx_history.index >= MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE)
+		cpriv->rx_history.index = 0;
+
+	/* allocate the skb buffer */
+	if (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_FDF) {
+		flags = 0;
+		flags |= (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_BRS) ?
+			CANFD_BRS : 0;
+		flags |= (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_ESI) ?
+			CANFD_ESI : 0;
+		skb = mcp25xxfd_can_rx_submit_fd_frame(cpriv, id, flags,
+						       len, &data);
+	} else {
+		skb = mcp25xxfd_can_rx_submit_normal_frame(cpriv, id,
+							   len, &data);
+	}
+	if (!skb) {
+		netdev_err(net, "cannot allocate RX skb\n");
+		net->stats.rx_dropped++;
+		return -ENOMEM;
+	}
+
+	/* copy the payload data */
+	memcpy(data, rx->data, len);
+
+	/* and submit the frame */
+	netif_rx_ni(skb);
+
+	return 0;
+}
+
+static int mcp25xxfd_can_rx_read_frame(struct mcp25xxfd_can_priv *cpriv,
+				       int fifo, int prefetch_bytes, bool read)
+{
+	struct spi_device *spi = cpriv->priv->spi;
+	struct net_device *net = cpriv->can.dev;
+	int addr = cpriv->fifos.info[fifo].offset;
+	struct mcp25xxfd_can_obj_rx *rx =
+		(struct mcp25xxfd_can_obj_rx *)(cpriv->sram + addr);
+	int dlc;
+	int len, ret;
+
+	/* we read the header plus prefetch_bytes */
+	if (read) {
+		cpriv->stats.rx_single_reads++;
+		ret = mcp25xxfd_cmd_readn(spi, MCP25XXFD_SRAM_ADDR(addr),
+					  rx, sizeof(*rx) + prefetch_bytes);
+		if (ret)
+			return ret;
+	}
+
+	/* transpose the headers to CPU format */
+	rx->id = le32_to_cpu(*(__le32 *)&rx->id);
+	rx->flags = le32_to_cpu(*(__le32 *)&rx->flags);
+	rx->ts = le32_to_cpu(*(__le32 *)&rx->ts);
+
+	/* compute len */
+	dlc = (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK) >>
+		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
+	len = can_dlc2len(min_t(int, dlc, (net->mtu == CANFD_MTU) ? 15 : 8));
+
+	/* read the remaining data for canfd frames */
+	if (read && len > prefetch_bytes) {
+		/* update stats */
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv,
+					     rx_reads_prefetched_too_few);
+		MCP25XXFD_DEBUGFS_STATS_ADD(cpriv,
+					    rx_reads_prefetched_too_few_bytes,
+					    len - prefetch_bytes);
+		/* here the extra portion reading data after prefetch */
+		ret = mcp25xxfd_cmd_readn(spi,
+					  MCP25XXFD_SRAM_ADDR(addr) +
+					  sizeof(*rx) + prefetch_bytes,
+					  &rx->data[prefetch_bytes],
+					  len - prefetch_bytes);
+		if (ret)
+			return ret;
+	}
+
+	/* update stats */
+	cpriv->stats.rx_reads++;
+	if (len < prefetch_bytes) {
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv,
+					     rx_reads_prefetched_too_many);
+		MCP25XXFD_DEBUGFS_STATS_ADD(cpriv,
+					    rx_reads_prefetched_too_many,
+					    prefetch_bytes - len);
+	}
+
+	/* clear the rest of the buffer - just to be safe */
+	memset(rx->data + len, 0, ((net->mtu == CANFD_MTU) ? 64 : 8) - len);
+
+	/* increment the statistics counter */
+	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.info[fifo].use_count);
+
+	/* add the fifo to the process queues */
+	mcp25xxfd_can_queue_frame(cpriv, fifo, rx->ts, true);
+
+	/* and clear the interrupt flag for that fifo */
+	return mcp25xxfd_cmd_write_mask(spi, MCP25XXFD_CAN_FIFOCON(fifo),
+					MCP25XXFD_CAN_FIFOCON_FRESET,
+					MCP25XXFD_CAN_FIFOCON_FRESET);
+}
+
+static int mcp25xxfd_can_read_rx_frame_bulk(struct mcp25xxfd_can_priv *cpriv,
+					    int fstart,
+					    int fend)
+{
+	struct net_device *net = cpriv->can.dev;
+	int count = abs(fend - fstart) + 1;
+	int flowest = min_t(int, fstart, fend);
+	int addr = cpriv->fifos.info[flowest].offset;
+	struct mcp25xxfd_can_obj_rx *rx =
+		(struct mcp25xxfd_can_obj_rx *)(cpriv->sram + addr);
+	int len = (sizeof(*rx) + ((net->mtu == CANFD_MTU) ? 64 : 8)) * count;
+	int fifo, i, ret;
+
+	/* update stats */
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, rx_bulk_reads);
+	i = min_t(int, MCP25XXFD_CAN_RX_BULK_READ_BINS - 1, count - 1);
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, rx_bulk_read_sizes[i]);
+
+	/* we read the header plus read_min data bytes */
+	ret = mcp25xxfd_cmd_readn(cpriv->priv->spi, MCP25XXFD_SRAM_ADDR(addr),
+				  rx, len);
+	if (ret)
+		return ret;
+
+	/* now process all of them - no need to read... */
+	for (fifo = fstart; count > 0; fifo ++, count--) {
+		ret = mcp25xxfd_can_rx_read_frame(cpriv, fifo, 8, false);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* predict dlc size based on historic behaviour */
+static int mcp25xxfd_can_rx_predict_prefetch(struct mcp25xxfd_can_priv *cpriv)
+{
+	int dlc, i, top;
+	u8 histo[16];
+
+	/* if we have a prfecth set then use that one */
+	if (rx_prefetch_bytes != -1)
+		return min_t(int, rx_prefetch_bytes,
+			     (cpriv->can.dev->mtu == CANFD_MTU) ? 64 : 8);
+
+	/* memset */
+	memset(histo, 0, sizeof(histo));
+
+	/* for all others compute the histogram */
+	for (i = 0; i < MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE; i++)
+		histo[cpriv->rx_history.dlc[i]]++;
+
+	/* and now find the highest fit */
+	for (i = (cpriv->can.dev->mtu == CANFD_MTU) ? 15 : 8, dlc = 8, top = 0;
+	      i >= 0; i--) {
+		if (top < histo[i]) {
+			top = histo[i];
+			dlc = i;
+		}
+	}
+
+	/* compute length from dlc */
+	cpriv->rx_history.predicted_len = can_dlc2len(dlc);
+
+	/* return the predicted length */
+	return cpriv->rx_history.predicted_len;
+}
+
+/* at least in can2.0 mode we can read multiple RX-fifos in one go
+ * in case they are ajactent to each other and thus we can reduce
+ * the number of spi messages produced and this improves spi-bus
+ * usage efficiency.
+ * In canFD mode this may also be possible, but would need some
+ * statistics to decide if it is worth reading a full 64 bytes
+ * in one go.
+ * But those statistics can get used to predict how many bytes
+ * to read together with the can header (which is fixed to 8 at
+ * this very moment.
+ *
+ * notes on the rational here:
+ * * Reading just the CAN header info takes:
+ *   * bytes read
+ *     *  2 bytes command+address
+ *     * 12 bytes data (id, flags, timestamp)
+ *   * so that is at the very least 112 SCK (= 14 byte * 8 SCK/1 byte)
+ *     - on a Raspberry pi 3 for such short requests actually
+ *       126 SCK (=14 byte * 9 SCK/1 byte)
+ *   * some SPI framework overhead which is observed to be 5-10 us
+ *     on a raspberry pi 3 (time between SCK and stop SCK start)
+ *   * with an effective 17.85 MHz SPI clock on a RPI it takes in total:
+ *     it takes 12us = 6us + 6us
+ * * now reading 8 bytes of CAN data (can2.0) takes:
+ *   * bytes read
+ *     *  2 bytes command+address
+ *     *  8 bytes data
+ *   * so that is at the very least 80 SCK (= 10 byte * 8 SCK/1 byte)
+ *     - on a Raspberry pi 3 for such short requests actually
+ *       90 SCK (= 10 byte * 9 SCK/1 byte)
+ *   * some SPI framework overhead which is observed to be 5-10 us
+ *     on a raspberry pi 3 (time between SCK and stop SCK start)
+ *   * with an effective 17.85 MHz SPI clock on a RPI it takes in total:
+ *     it takes 11us = 5.0us + 6us
+ * * now reading CAN header plus 8 bytes of CAN data (can2.0) takes:
+ *   * bytes read
+ *     *  2 bytes command+address
+ *     * 20 bytes data
+ *   * so that is at the very least 176 SCK (= 22 byte * 8 SCK/1 byte)
+ *     - on a Raspberry pi 3 for such short requests actually
+ *       198 SCK (= 22 byte * 9 SCK/1 byte)
+ *   * some SPI framework overhead which is observed to be 5-10 us
+ *     on a raspberry pi 3 (time between SCK and stop SCK start)
+ *   * with an effective 17.85 MHz SPI clock on a RPI it takes in total:
+ *     it takes 17.1us = 11.1us + 6us
+ *   * this is faster than the 2 individual SPI transfers for header
+ *     and data which is in total 23us
+ *     * this is even true for the case where we only have a single
+ *       data byte (DLC=1) - the time here is 19.5us on a RPI3
+ *     * the only time where we are less efficient is for the DLC=0 case.
+ *       but the assumption here is that this is a rare case
+ * To put it into perspective here the full table for a RPI3:
+ * LE 2m  pr0 pr1 pr2 pr3 pr4 pr5  pr6  pr7  pr8 pr12 pr16 pr20 pr24 pr32 pr48
+ *                                                                         pr64
+ *  0  7.1 7.1
+ *  1 14.6    7.6 8.1 8.6 9.1 9.6 10.1 10.6 11.1 13.1
+ *  2 15.1        8.1 8.6 9.1 9.6 10.1 10.6 11.1 13.1
+ *  3 15.6            8.6 9.1 9.6 10.1 10.6 11.1 13.1 15.1
+ *  4 16.1                9.1 9.6 10.1 10.6 11.1 13.1 15.1
+ *  5 16.6                    9.6 10.1 10.6 11.1 13.1 15.1
+ *  6 17.1                        10.1 10.6 11.1 13.1 15.1
+ *  7 17.6                             10.6 11.1 13.1 15.1 17.1
+ *  8 18.1                                  11.1 13.1 15.1 17.1
+ * 12 20.1                                       13.1 15.1 17.1 19.2
+ * 16 22.1                                            15.1 17.1 19.2
+ * 20 24.1                                                 17.1 19.2 23.2
+ * 24 26.2                                                      19.2 23.2
+ * 32 30.2                                                           23.2
+ * 48 38.3                                                                31.3
+ * 64 46.3                                                                 39.3
+ * (Parameters: SPI Clock=17.8MHz, SCK/byte=9, overhead=6us)
+ * Legend:
+ *   LE = length,
+ *   2m    = 2 SPI messages (header+data - except for LEN=0, only header)
+ *  prX/pX = prefecth length times (only shown when < 2m and Len >= Prefetch)
+ *
+ * The diagonal schows the "optimal" time when the size of the Can frame would
+ * be known ahead of time - i.e if it would be possible to define RX reception
+ * filters based on can DLC values
+ *
+ * So for any Can frame except for LEN=0 the prefetch data solution is
+ * better for prefetch of data=12 for CanFD.
+ *
+ * Here another table showing the optimal prefetch limits for SPI speeds
+ * vs overhead_us at 8 or 9 SCLK/byte
+ *
+ * MHZ  2us@8   2us@9   4us@8   4us@9   6us@8   6us@9   8us@8   8us@9
+ * 10.0 8b***   8b***   8b      8b*     12b**   8b*     12b     12b*
+ * 12.5 8b**    8b***   12b***  8b      12b     12b*    16b*    16b**
+ * 15.0 8b**    8b**    12b**   12b***  16b**   12b     20b**   16b
+ * 17.5 8b*     8b*     12b*    12b**   16b     16b**   20b     20b**
+ * 20.0 8b      8b*     16b***  12b*    20b**   16b     24b*    20b
+ * (a * signifies not a full match, but for any length > count(*))
+ *
+ * So 8 bytes prefetch seems to be a very good tradeoff for can frame
+ * except for DLC/LEN=0 frames.
+ * The question here is mainly: how many frames do we have with DLC=0
+ * vs all others.
+ *
+ * With some statistics of recent CAN frames this may be set dynamically
+ * in the future.
+ *
+ * For this to work efficiently we would also need an estimate on
+ * the SPI framework overhead, which is a function of the spi-bus-driver
+ * implementation details, CPU type and speed as well as system load.
+ * Also the effective SPI-clock speed is needed as well as the
+ * number of spi clock cycles it takes for a single byte to get transferred
+ * The bcm283x SOC for example pauses the SPI clock one cycle after
+ * every byte it sends unless the data is fed to the controller by DMA.
+ * (but for short transfers DMA mapping is very expensive and not worth
+ * the effort. PIO and - in some situations - polling is used instead to
+ * reduce the number of interrupts and the need for thread scheduling as
+ * much as possible)
+ *
+ * This also means that for can2.0 only configured interfaces
+ * reading multiple rx fifos is a realistic option of optimization
+ */
+
+static int mcp25xxfd_can_rx_read_single_frames(struct mcp25xxfd_can_priv *cpriv,
+					       int prefetch)
+{
+	int i, f, ret;
+
+	/* loop all frames */
+	for (i = 0, f = cpriv->fifos.rx.start; i < cpriv->fifos.rx.count;
+	     i++, f++) {
+		if (cpriv->status.rxif & BIT(f)) {
+			/* read the frame */
+			ret = mcp25xxfd_can_rx_read_frame(cpriv, f,
+							  prefetch, true);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_can_rx_read_bulk_frames(struct mcp25xxfd_can_priv *cpriv)
+{
+	int i, start, end;
+	int ret;
+
+	/* iterate over fifos trying to find fifos next to each other */
+	for (i = 0, start = cpriv->fifos.rx.start, end = start;
+	     i < cpriv->fifos.rx.count; i++, end++, start = end) {
+		/* if bit is not set then continue */
+		if (!(cpriv->status.rxif & BIT(start)))
+			continue;
+		/* find the last fifo with a bit set in sequence */
+		for (end = start; cpriv->status.rxif & BIT(end + 1); end++)
+			;
+		/* and now read those fifos in bulk */
+		ret = mcp25xxfd_can_read_rx_frame_bulk(cpriv, start, end);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_can_rx_read_fd_frames(struct mcp25xxfd_can_priv *cpriv)
+{
+	int i, count_dlc15, count_brs, prefetch;
+
+	/* get a prediction on prefetch */
+	prefetch = mcp25xxfd_can_rx_predict_prefetch(cpriv);
+
+	/* if the prefetch is < 64 then just read single */
+	if (prefetch < 64)
+		return mcp25xxfd_can_rx_read_single_frames(cpriv, prefetch);
+
+	/* check if we have mostly brs frames of those DLC=15 frames */
+	for (i = 0, count_brs = 0, count_dlc15 = 0;
+	     i < MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE; i++)
+		if (cpriv->rx_history.dlc[i] == 15) {
+			count_dlc15++;
+			if (cpriv->rx_history.brs[i])
+				count_brs++;
+		}
+
+	/* if we have at least 33% brs frames then run bulk */
+	if (count_brs * 3 >= count_dlc15)
+		return mcp25xxfd_can_rx_read_bulk_frames(cpriv);
+	else
+		return mcp25xxfd_can_rx_read_single_frames(cpriv, prefetch);
+}
+
+static int mcp25xxfd_can_rx_read_frames(struct mcp25xxfd_can_priv *cpriv)
+{
+	if (cpriv->can.dev->mtu == CANFD_MTU)
+		return mcp25xxfd_can_rx_read_fd_frames(cpriv);
+	else
+		return mcp25xxfd_can_rx_read_bulk_frames(cpriv);
+}
+
+int mcp25xxfd_can_rx_handle_int_rxif(struct mcp25xxfd_can_priv *cpriv)
+{
+	if (!cpriv->status.rxif)
+		return 0;
+
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_rx_count);
+
+	/* read all the fifos */
+	return mcp25xxfd_can_rx_read_frames(cpriv);
+}
+
+int mcp25xxfd_can_rx_handle_int_rxovif(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 mask = MCP25XXFD_CAN_FIFOSTA_RXOVIF;
+	int ret, i, reg;
+
+	if (!cpriv->status.rxovif)
+		return 0;
+
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_rxov_count);
+
+	/* clear all fifos that have an overflow bit set */
+	for (i = 0; i < 32; i++) {
+		if (cpriv->status.rxovif & BIT(i)) {
+			/* clear fifo status */
+			reg = MCP25XXFD_CAN_FIFOSTA(i);
+			ret = mcp25xxfd_cmd_write_mask(cpriv->priv->spi,
+						       reg, 0, mask);
+			if (ret)
+				return ret;
+
+			/* update statistics */
+			cpriv->can.dev->stats.rx_over_errors++;
+			cpriv->can.dev->stats.rx_errors++;
+
+			/* and prepare ERROR FRAME */
+			cpriv->error_frame.id |= CAN_ERR_CRTL;
+			cpriv->error_frame.data[1] |=
+				CAN_ERR_CRTL_RX_OVERFLOW;
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h
new file mode 100644
index 000000000000..71953e2f3615
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_RX_H
+#define __MCP25XXFD_CAN_RX_H
+
+#include "mcp25xxfd_priv.h"
+
+int mcp25xxfd_can_rx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo);
+
+int mcp25xxfd_can_rx_handle_int_rxif(struct mcp25xxfd_can_priv *cpriv);
+int mcp25xxfd_can_rx_handle_int_rxovif(struct mcp25xxfd_can_priv *cpriv);
+
+#endif /* __MCP25XXFD_CAN_RX_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c
new file mode 100644
index 000000000000..50252d530725
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c
@@ -0,0 +1,795 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ *
+ * Based on Microchip MCP251x CAN controller driver written by
+ * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
+ */
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_can_id.h"
+#include "mcp25xxfd_can_tx.h"
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_regs.h"
+
+/* mostly bit manipulations to move between stages */
+static struct mcp25xxfd_tx_spi_message *
+mcp25xxfd_can_tx_queue_first_spi_message(struct mcp25xxfd_tx_spi_message_queue *
+					 queue, u32 *bitmap)
+{
+	u32 first = ffs(*bitmap);
+
+	if (!first)
+		return NULL;
+
+	return queue->fifo2message[first - 1];
+}
+
+static void mcp25xxfd_can_tx_queue_remove_spi_message(u32 *bitmap, int fifo)
+{
+	*bitmap &= ~BIT(fifo);
+}
+
+static void mcp25xxfd_can_tx_queue_add_spi_message(u32 *bitmap, int fifo)
+{
+	*bitmap |= BIT(fifo);
+}
+
+static void mcp25xxfd_can_tx_queue_move_spi_message(u32 *src, u32 *dest,
+						    int fifo)
+{
+	mcp25xxfd_can_tx_queue_remove_spi_message(src, fifo);
+	mcp25xxfd_can_tx_queue_add_spi_message(dest, fifo);
+}
+
+static void mcp25xxfd_can_tx_spi_message_fill_fifo_complete(void *context)
+{
+	struct mcp25xxfd_tx_spi_message *msg = context;
+	struct mcp25xxfd_can_priv *cpriv = msg->cpriv;
+	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
+	unsigned long flags;
+
+	/* reset transfer length to without data (DLC = 0) */
+	msg->fill_fifo.xfer.len = sizeof(msg->fill_fifo.data.cmd) +
+		sizeof(msg->fill_fifo.data.header);
+
+	/* we need to hold this lock to protect us from
+	 * concurrent access by start_xmit
+	 */
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* move to in_trigger_fifo_transfer */
+	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_fill_fifo_transfer,
+						&q->in_trigger_fifo_transfer,
+						msg->fifo);
+
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+}
+
+static void mcp25xxfd_can_tx_spi_message_trigger_fifo_complete(void *context)
+{
+	struct mcp25xxfd_tx_spi_message *msg = context;
+	struct mcp25xxfd_can_priv *cpriv = msg->cpriv;
+	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
+	unsigned long flags;
+
+	/* we need to hold this lock to protect us from
+	 * concurrent access by the interrupt thread
+	 */
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* move to can_transfer */
+	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_trigger_fifo_transfer,
+						&q->in_can_transfer,
+						msg->fifo);
+
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+}
+
+static
+void mcp25xxfd_can_tx_message_init(struct mcp25xxfd_can_priv *cpriv,
+				   struct mcp25xxfd_tx_spi_message *msg,
+				   int fifo)
+{
+	const u32 trigger = MCP25XXFD_CAN_FIFOCON_TXREQ |
+		MCP25XXFD_CAN_FIFOCON_UINC;
+	const int first_byte = mcp25xxfd_cmd_first_byte(trigger);
+	u32 addr;
+
+	/* and initialize the structure */
+	msg->cpriv = cpriv;
+	msg->fifo = fifo;
+
+	/* init fill_fifo */
+	spi_message_init(&msg->fill_fifo.msg);
+	msg->fill_fifo.msg.complete =
+		mcp25xxfd_can_tx_spi_message_fill_fifo_complete;
+	msg->fill_fifo.msg.context = msg;
+
+	msg->fill_fifo.xfer.speed_hz = cpriv->priv->spi_use_speed_hz;
+	msg->fill_fifo.xfer.tx_buf = msg->fill_fifo.data.cmd;
+	msg->fill_fifo.xfer.len = sizeof(msg->fill_fifo.data.cmd) +
+		sizeof(msg->fill_fifo.data.header);
+	spi_message_add_tail(&msg->fill_fifo.xfer, &msg->fill_fifo.msg);
+
+	addr = MCP25XXFD_SRAM_ADDR(cpriv->fifos.info[fifo].offset);
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE, addr,
+			   msg->fill_fifo.data.cmd);
+
+	/* init trigger_fifo */
+	spi_message_init(&msg->trigger_fifo.msg);
+	msg->trigger_fifo.msg.complete =
+		mcp25xxfd_can_tx_spi_message_trigger_fifo_complete;
+	msg->trigger_fifo.msg.context = msg;
+
+	msg->trigger_fifo.xfer.speed_hz = cpriv->priv->spi_use_speed_hz;
+	msg->trigger_fifo.xfer.tx_buf = msg->trigger_fifo.data.cmd;
+	msg->trigger_fifo.xfer.len = sizeof(msg->trigger_fifo.data.cmd) +
+		sizeof(msg->trigger_fifo.data.data);
+	spi_message_add_tail(&msg->trigger_fifo.xfer, &msg->trigger_fifo.msg);
+
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE,
+			   MCP25XXFD_CAN_FIFOCON(fifo) + first_byte,
+			   msg->trigger_fifo.data.cmd);
+	msg->trigger_fifo.data.data = trigger >> (8 * first_byte);
+
+	/* and add to idle tx transfers */
+	mcp25xxfd_can_tx_queue_add_spi_message(&cpriv->fifos.tx_queue->idle,
+					       fifo);
+}
+
+static
+void mcp25xxfd_can_tx_queue_manage_nolock(struct mcp25xxfd_can_priv *cpriv,
+					  int state)
+{
+	struct net_device *net = cpriv->can.dev;
+
+	/* skip early */
+	if (state == cpriv->fifos.tx_queue->state)
+		return;
+
+	/* start/stop netif_queue if necessary */
+	switch (cpriv->fifos.tx_queue->state) {
+	case MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE:
+		switch (state) {
+		case MCP25XXFD_CAN_TX_QUEUE_STATE_RESTART:
+		case MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED:
+			netif_wake_queue(net);
+			cpriv->fifos.tx_queue->state =
+				MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED;
+			break;
+		}
+		break;
+	case MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED:
+		switch (state) {
+		case MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED:
+			netif_wake_queue(net);
+			cpriv->fifos.tx_queue->state = state;
+			break;
+		}
+		break;
+	case MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED:
+		switch (state) {
+		case MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE:
+		case MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED:
+			netif_stop_queue(net);
+			cpriv->fifos.tx_queue->state = state;
+			break;
+		}
+		break;
+	default:
+		WARN(true, "Unsupported tx_queue state: %i\n",
+		     cpriv->fifos.tx_queue->state);
+		break;
+	}
+}
+
+void mcp25xxfd_can_tx_queue_manage(struct mcp25xxfd_can_priv *cpriv, int state)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+
+	mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
+
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+}
+
+void mcp25xxfd_can_tx_queue_restart(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 state = MCP25XXFD_CAN_TX_QUEUE_STATE_RESTART;
+	unsigned long flags;
+	u32 mask;
+
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* only move if there is nothing pending or idle */
+	mask = cpriv->fifos.tx_queue->idle |
+		cpriv->fifos.tx_queue->in_fill_fifo_transfer |
+		cpriv->fifos.tx_queue->in_trigger_fifo_transfer |
+		cpriv->fifos.tx_queue->in_can_transfer;
+	if (mask)
+		goto out;
+
+	/* move all items from transferred to idle */
+	cpriv->fifos.tx_queue->idle |= cpriv->fifos.tx_queue->transferred;
+	cpriv->fifos.tx_queue->transferred = 0;
+
+	/* and enable queue */
+	mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
+out:
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+}
+
+static
+int mcp25xxfd_can_tx_tef_read(struct mcp25xxfd_can_priv *cpriv,
+			      int start, int count)
+{
+	u32 tef_offset = start * cpriv->fifos.tef.size;
+	struct mcp25xxfd_can_obj_tef *tef =
+		(struct mcp25xxfd_can_obj_tef *)(cpriv->sram + tef_offset);
+	int last, read, ret;
+
+	/* compute how many we can read in one go */
+	last = start + count;
+	read = (last > cpriv->fifos.tef.count) ?
+		(cpriv->fifos.tef.count - start) :
+		count;
+
+	/* and read it */
+	ret = mcp25xxfd_cmd_read_regs(cpriv->priv->spi,
+				      MCP25XXFD_SRAM_ADDR(tef_offset),
+				      &tef->id, sizeof(*tef) * read);
+	if (ret)
+		return ret;
+
+	/* and read a second part on wrap */
+	if (read != count) {
+		/* update stats */
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_read_splits);
+		/* compute the addresses  */
+		read = count - read;
+		tef = (struct mcp25xxfd_can_obj_tef *)(cpriv->sram);
+		/* and read again */
+		ret = mcp25xxfd_cmd_read_regs(cpriv->priv->spi,
+					      MCP25XXFD_SRAM_ADDR(0),
+					      &tef->id,
+					      sizeof(*tef) * read);
+	}
+
+	return ret;
+}
+
+static
+int mcp25xxfd_can_tx_handle_int_tefif_fifo(struct mcp25xxfd_can_priv *cpriv,
+					   bool read_data)
+{
+	u32 tef_offset = cpriv->fifos.tef.index * cpriv->fifos.tef.size;
+	struct mcp25xxfd_can_obj_tef *tef =
+		(struct mcp25xxfd_can_obj_tef *)(cpriv->sram + tef_offset);
+	int fifo, ret;
+	unsigned long flags;
+
+	/* read the next TEF entry to get the transmit timestamp and fifo */
+	if (read_data) {
+		ret = mcp25xxfd_can_tx_tef_read(cpriv,
+						cpriv->fifos.tef.index, 1);
+		if (ret)
+			return ret;
+	}
+
+	/* get the fifo from tef */
+	fifo = (tef->flags & MCP25XXFD_CAN_OBJ_FLAGS_SEQ_MASK) >>
+		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT;
+
+	/* check that the fifo is valid */
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+	if ((cpriv->fifos.tx_queue->in_can_transfer & BIT(fifo)) == 0)
+		netdev_err(cpriv->can.dev,
+			   "tefif: fifo %i not pending - tef data: id: %08x flags: %08x, ts: %08x - this may be a problem with spi signal quality- try reducing spi-clock speed if this can get reproduced",
+			   fifo, tef->id, tef->flags, tef->ts);
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* update stats */
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_reads);
+
+	/* now we can schedule the fifo for echo submission */
+	mcp25xxfd_can_queue_frame(cpriv, fifo, tef->ts, false);
+
+	/* increment the tef index with wraparround */
+	cpriv->fifos.tef.index++;
+	if (cpriv->fifos.tef.index >= cpriv->fifos.tef.count)
+		cpriv->fifos.tef.index = 0;
+
+	/* finally just increment the TEF pointer */
+	return mcp25xxfd_cmd_write_mask(cpriv->priv->spi, MCP25XXFD_CAN_TEFCON,
+					MCP25XXFD_CAN_TEFCON_UINC,
+					MCP25XXFD_CAN_TEFCON_UINC);
+}
+
+/* reading TEF entries can be made even more efficient by reading
+ * multiple TEF entries in one go.
+ * Under the assumption that we have count(TEF) >= count(TX_FIFO)
+ * we can even release TEFs early (before we read them)
+ * (and potentially restarting the transmit-queue early aswell)
+ */
+
+static int
+mcp25xxfd_can_tx_handle_int_tefif_conservative(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 tefsta;
+	int ret;
+
+	/* read the TEF status */
+	ret = mcp25xxfd_cmd_read_mask(cpriv->priv->spi, MCP25XXFD_CAN_TEFSTA,
+				      &tefsta, MCP25XXFD_CAN_TEFSTA_TEFNEIF);
+	if (ret)
+		return ret;
+
+	/* read the tef in an inefficient loop */
+	while (tefsta & MCP25XXFD_CAN_TEFSTA_TEFNEIF) {
+		/* read one tef */
+		ret = mcp25xxfd_can_tx_handle_int_tefif_fifo(cpriv, true);
+		if (ret)
+			return ret;
+
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_conservative_reads);
+
+		/* read the TEF status */
+		ret = mcp25xxfd_cmd_read_mask(cpriv->priv->spi,
+					      MCP25XXFD_CAN_TEFSTA, &tefsta,
+					      MCP25XXFD_CAN_TEFSTA_TEFNEIF);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int
+mcp25xxfd_can_tx_handle_int_tefif_optimized(struct mcp25xxfd_can_priv *cpriv,
+					    u32 finished)
+{
+	int i, fifo, count, ret;
+
+	/* count the number of fifos that have terminated */
+	for (i = 0, fifo = cpriv->fifos.tx.start, count = 0;
+	     i < cpriv->fifos.tx.count; i++, fifo++)
+		if (finished & BIT(fifo))
+			count++;
+
+	/* read them in one go if possible
+	 * we also assume that we have count(TEF) >= count(TX-FIFOS)
+	 * this may require 2 reads when we wrap arround
+	 * (that is unless count(TEF) == count(TX-FIFOS))
+	 */
+	ret = mcp25xxfd_can_tx_tef_read(cpriv, cpriv->fifos.tef.index, count);
+	if (ret)
+		return ret;
+
+	/* update stats */
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_optimized_reads);
+	i = min_t(int, MCP25XXFD_CAN_TEF_READ_BINS - 1, count - 1);
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_optimized_read_sizes[i]);
+
+	/* now iterate those */
+	for (i = 0, fifo = cpriv->fifos.tx.start; i < cpriv->fifos.tx.count;
+	     i++, fifo++) {
+		if (finished & BIT(fifo)) {
+			ret = mcp25xxfd_can_tx_handle_int_tefif_fifo(cpriv,
+								     false);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mcp25xxfd_can_tx_handle_int_tefif(struct mcp25xxfd_can_priv *cpriv)
+{
+	unsigned long flags;
+	u32 finished;
+
+	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_TEFIF))
+		return 0;
+
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_tef_count);
+
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* compute finished fifos and clear them immediately */
+	finished = (cpriv->fifos.tx_queue->in_can_transfer ^
+		    cpriv->status.txreq) &
+		cpriv->fifos.tx_queue->in_can_transfer;
+
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* run in optimized mode if possible */
+	if (finished)
+		return mcp25xxfd_can_tx_handle_int_tefif_optimized(cpriv,
+								   finished);
+	/* otherwise play it safe */
+	netdev_warn(cpriv->can.dev,
+		    "Something is wrong - we got a TEF interrupt but we were not able to detect a finished fifo\n");
+	return mcp25xxfd_can_tx_handle_int_tefif_conservative(cpriv);
+}
+
+static
+void mcp25xxfd_can_tx_fill_fifo_common(struct mcp25xxfd_can_priv *cpriv,
+				       struct mcp25xxfd_tx_spi_message *smsg,
+				       struct mcp25xxfd_can_obj_tx *tx,
+				       int dlc, u8 *data)
+{
+	int len = can_dlc2len(dlc);
+
+	/* update statistics */
+	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.tx.dlc_usage[dlc]);
+	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.info[smsg->fifo].use_count);
+
+	/* add fifo number as seq */
+	tx->flags |= smsg->fifo << MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT;
+
+	/* copy data to tx->data for future reference */
+	memcpy(tx->data, data, len);
+
+	/* transform header to controller format */
+	mcp25xxfd_cmd_convert_from_cpu(&tx->id, sizeof(*tx) / sizeof(u32));
+
+	/* copy header + data to final location - we are not aligned */
+	memcpy(smsg->fill_fifo.data.header, &tx->id, sizeof(*tx) + len);
+
+	/* transfers to sram should be a multiple of 4 and be zero padded */
+	for (; len & 3; len++)
+		*(smsg->fill_fifo.data.header + sizeof(*tx) + len) = 0;
+
+	/* convert it back to CPU format */
+	mcp25xxfd_cmd_convert_to_cpu(&tx->id, sizeof(*tx) / sizeof(u32));
+
+	/* set up size of transfer */
+	smsg->fill_fifo.xfer.len = sizeof(smsg->fill_fifo.data.cmd) +
+		sizeof(smsg->fill_fifo.data.header) + len;
+}
+
+static
+void mcp25xxfd_can_tx_fill_fifo_fd(struct mcp25xxfd_can_priv *cpriv,
+				   struct canfd_frame *frame,
+				   struct mcp25xxfd_tx_spi_message *smsg,
+				   struct mcp25xxfd_can_obj_tx *tx)
+{
+	int dlc = can_len2dlc(frame->len);
+
+	/* update some statistics */
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_fd_count);
+
+	/* compute can id */
+	mcp25xxfd_can_id_to_mcp25xxfd(frame->can_id, &tx->id, &tx->flags);
+
+	/* setup flags */
+	tx->flags |= dlc << MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
+	tx->flags |= (frame->can_id & CAN_EFF_FLAG) ?
+		MCP25XXFD_CAN_OBJ_FLAGS_IDE : 0;
+	tx->flags |= (frame->can_id & CAN_RTR_FLAG) ?
+		MCP25XXFD_CAN_OBJ_FLAGS_RTR : 0;
+	if (frame->flags & CANFD_BRS) {
+		tx->flags |= MCP25XXFD_CAN_OBJ_FLAGS_BRS;
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_brs_count);
+	}
+	tx->flags |= (frame->flags & CANFD_ESI) ?
+		MCP25XXFD_CAN_OBJ_FLAGS_ESI : 0;
+	tx->flags |= MCP25XXFD_CAN_OBJ_FLAGS_FDF;
+
+	/* and do common processing */
+	mcp25xxfd_can_tx_fill_fifo_common(cpriv, smsg, tx, dlc, frame->data);
+}
+
+static
+void mcp25xxfd_can_tx_fill_fifo(struct mcp25xxfd_can_priv *cpriv,
+				struct can_frame *frame,
+				struct mcp25xxfd_tx_spi_message *smsg,
+				struct mcp25xxfd_can_obj_tx *tx)
+{
+	/* set frame to valid dlc */
+	if (frame->can_dlc > 8)
+		frame->can_dlc = 8;
+
+	/* compute can id */
+	mcp25xxfd_can_id_to_mcp25xxfd(frame->can_id, &tx->id, &tx->flags);
+
+	/* setup flags */
+	tx->flags |= frame->can_dlc << MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
+	tx->flags |= (frame->can_id & CAN_EFF_FLAG) ?
+		MCP25XXFD_CAN_OBJ_FLAGS_IDE : 0;
+	tx->flags |= (frame->can_id & CAN_RTR_FLAG) ?
+		MCP25XXFD_CAN_OBJ_FLAGS_RTR : 0;
+
+	/* and do common processing */
+	mcp25xxfd_can_tx_fill_fifo_common(cpriv, smsg, tx, frame->can_dlc,
+					  frame->data);
+}
+
+static struct mcp25xxfd_tx_spi_message *
+mcp25xxfd_can_tx_queue_get_next_fifo(struct mcp25xxfd_can_priv *cpriv)
+{
+	u32 state = MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE;
+	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
+	struct mcp25xxfd_tx_spi_message *smsg;
+	unsigned long flags;
+
+	/* we need to hold this lock to protect us against
+	 * concurrent modifications of cpriv->fifos.tx_queue->idle
+	 * in the interrupt thread
+	 */
+	spin_lock_irqsave(&q->lock, flags);
+
+	/* get the first entry from idle */
+	smsg = mcp25xxfd_can_tx_queue_first_spi_message(q, &q->idle);
+	if (!smsg)
+		goto out_busy;
+
+	/* and move the fifo to next stage */
+	mcp25xxfd_can_tx_queue_move_spi_message(&q->idle,
+						&q->in_fill_fifo_transfer,
+						smsg->fifo);
+
+	/* if queue is empty then stop the network queue immediately */
+	if (!q->idle)
+		mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
+out_busy:
+	spin_unlock_irqrestore(&q->lock, flags);
+
+	return smsg;
+}
+
+/* submit the can message to the can-bus */
+netdev_tx_t mcp25xxfd_can_tx_start_xmit(struct sk_buff *skb,
+					struct net_device *net)
+{
+	u32 state = MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED;
+	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
+	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
+	struct mcp25xxfd_priv *priv = cpriv->priv;
+	struct spi_device *spi = priv->spi;
+	struct mcp25xxfd_tx_spi_message *smsg;
+	struct mcp25xxfd_can_obj_tx *tx;
+	unsigned long flags;
+	int ret;
+
+	/* invalid skb we can ignore */
+	if (can_dropped_invalid_skb(net, skb))
+		return NETDEV_TX_OK;
+
+	/* acquire lock on spi so that we are are not risking
+	 * some reordering of spi messages when we are running
+	 * start_xmit in multiple threads (on multiple cores)
+	 */
+	spin_lock_irqsave(&q->spi_lock, flags);
+
+	/* get the fifo message structure to process now */
+	smsg = mcp25xxfd_can_tx_queue_get_next_fifo(cpriv);
+	if (!smsg)
+		goto out_busy;
+
+	/* compute the fifo in sram */
+	tx = (struct mcp25xxfd_can_obj_tx *)
+		(cpriv->sram + cpriv->fifos.info[smsg->fifo].offset);
+
+	/* fill in message from skb->data depending on can2.0 or canfd */
+	if (can_is_canfd_skb(skb))
+		mcp25xxfd_can_tx_fill_fifo_fd(cpriv,
+					      (struct canfd_frame *)skb->data,
+					      smsg, tx);
+	else
+		mcp25xxfd_can_tx_fill_fifo(cpriv,
+					   (struct can_frame *)skb->data,
+					   smsg, tx);
+
+	/* submit the two messages asyncronously
+	 * the reason why we separate transfers into two spi_messages is:
+	 *  * because the spi framework (currently) does add a 10us delay
+	 *    between 2 spi_transfers in a single spi_message when
+	 *    change_cs is set - 2 consecutive spi messages show a shorter
+	 *    cs disable phase increasing bus utilization
+	 *    (code reduction with a fix in spi core would be aprox.50 lines)
+	 *  * this allows the interrupt handler to start spi messages earlier
+	 *    so reducing latencies a bit and to allow for better concurrency
+	 *  * this separation - in the future - may get used to fill fifos
+	 *    early and reduce the delay on "rollover"
+	 */
+	ret = spi_async(spi, &smsg->fill_fifo.msg);
+	if (ret)
+		goto out_async_failed;
+	ret = spi_async(spi, &smsg->trigger_fifo.msg);
+	if (ret)
+		goto out_async_failed;
+
+	/* unlock the spi bus */
+	spin_unlock_irqrestore(&q->spi_lock, flags);
+
+	/* keep it for reference until the message really got transmitted */
+	can_put_echo_skb(skb, net, smsg->fifo);
+
+	return NETDEV_TX_OK;
+out_async_failed:
+	netdev_err(net, "spi_async submission of fifo %i failed - %i\n",
+		   smsg->fifo, ret);
+
+out_busy:
+	/* stop the queue */
+	mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
+
+	spin_unlock_irqrestore(&q->spi_lock, flags);
+
+	return NETDEV_TX_BUSY;
+}
+
+/* submit the fifo back to the network stack */
+int mcp25xxfd_can_tx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo)
+{
+	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
+	struct mcp25xxfd_can_obj_tx *tx = (struct mcp25xxfd_can_obj_tx *)
+		(cpriv->sram + cpriv->fifos.info[fifo].offset);
+	int dlc = (tx->flags & MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK) >>
+		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
+	unsigned long flags;
+
+	/* update counters */
+	cpriv->can.dev->stats.tx_packets++;
+	cpriv->can.dev->stats.tx_bytes += can_dlc2len(dlc);
+	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.tx.dlc_usage[dlc]);
+	if (tx->flags & MCP25XXFD_CAN_OBJ_FLAGS_FDF)
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_fd_count);
+	if (tx->flags & MCP25XXFD_CAN_OBJ_FLAGS_BRS)
+		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_brs_count);
+
+	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
+
+	/* release the echo buffer */
+	can_get_echo_skb(cpriv->can.dev, fifo);
+
+	/* move from in_can_transfer to transferred */
+	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_can_transfer,
+						&q->transferred, fifo);
+
+	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
+
+	return 0;
+}
+
+/* interrupt handler */
+static
+int mcp25xxfd_can_tx_handle_int_txatif_fifo(struct mcp25xxfd_can_priv *cpriv,
+					    int fifo)
+{
+	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
+	u32 val;
+	unsigned long flags;
+	int ret;
+
+	/* read fifo status */
+	ret = mcp25xxfd_cmd_read(cpriv->priv->spi,
+				 MCP25XXFD_CAN_FIFOSTA(fifo), &val);
+	if (ret)
+		return ret;
+
+	/* clear the relevant interrupt flags */
+	ret = mcp25xxfd_cmd_write_mask(cpriv->priv->spi,
+				       MCP25XXFD_CAN_FIFOSTA(fifo), 0,
+				       MCP25XXFD_CAN_FIFOSTA_TXABT |
+				       MCP25XXFD_CAN_FIFOSTA_TXLARB |
+				       MCP25XXFD_CAN_FIFOSTA_TXERR |
+				       MCP25XXFD_CAN_FIFOSTA_TXATIF);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&q->lock, flags);
+	/* for specific cases we probably could trigger a retransmit
+	 * instead of an abort.
+	 */
+
+	/* and we release it from the echo_skb buffer
+	 * NOTE: this is one place where packet delivery will not
+	 * be ordered, as we do not have any timing information
+	 * when this occurred
+	 */
+	can_get_echo_skb(cpriv->can.dev, fifo);
+
+	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_can_transfer,
+						&q->transferred, fifo);
+
+	spin_unlock_irqrestore(&q->lock, flags);
+
+	/* but we need to run a bit of cleanup */
+	cpriv->status.txif &= ~BIT(fifo);
+	cpriv->can.dev->stats.tx_aborted_errors++;
+
+	/* handle all the known cases accordingly - ignoring FIFO full */
+	val &= MCP25XXFD_CAN_FIFOSTA_TXABT |
+		MCP25XXFD_CAN_FIFOSTA_TXLARB |
+		MCP25XXFD_CAN_FIFOSTA_TXERR;
+	switch (val) {
+	case MCP25XXFD_CAN_FIFOSTA_TXERR:
+		/* this indicates a possible bus error */
+		break;
+	default:
+		dev_warn_ratelimited(&cpriv->priv->spi->dev,
+				     "Unknown TX-Fifo abort condition: %08x - stopping tx-queue\n",
+				     val);
+		break;
+	}
+
+	return 0;
+}
+
+int mcp25xxfd_can_tx_handle_int_txatif(struct mcp25xxfd_can_priv *cpriv)
+{
+	int i, f, ret;
+
+	/* if txatif is unset, then there are no
+	 * can frames that have been transmitted
+	 * and need to get reingested into the network stack
+	 */
+	if (!cpriv->status.txatif)
+		return 0;
+	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_txat_count);
+
+	/* process all the fifos with that flag set */
+	for (i = 0, f = cpriv->fifos.tx.start; i < cpriv->fifos.tx.count;
+	     i++, f++) {
+		if (cpriv->status.txatif & BIT(f)) {
+			ret = mcp25xxfd_can_tx_handle_int_txatif_fifo(cpriv, f);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mcp25xxfd_can_tx_queue_alloc(struct mcp25xxfd_can_priv *cpriv)
+{
+	struct mcp25xxfd_tx_spi_message *msg;
+	size_t size = sizeof(struct mcp25xxfd_tx_spi_message_queue) +
+		cpriv->fifos.tx.count * sizeof(*msg);
+	int i, f;
+
+	/* allocate the fifos as an array */
+	cpriv->fifos.tx_queue = kzalloc(size, GFP_KERNEL);
+	if (!cpriv->fifos.tx_queue)
+		return -ENOMEM;
+
+	/* initialize the tx_queue structure */
+	spin_lock_init(&cpriv->fifos.tx_queue->lock);
+	spin_lock_init(&cpriv->fifos.tx_queue->spi_lock);
+
+	/* initialize the individual spi_message structures */
+	for (i = 0, f = cpriv->fifos.tx.start; i < cpriv->fifos.tx.count;
+	     i++, f++) {
+		msg = &cpriv->fifos.tx_queue->message[i];
+		cpriv->fifos.tx_queue->fifo2message[f] = msg;
+		mcp25xxfd_can_tx_message_init(cpriv, msg, f);
+	}
+
+	return 0;
+}
+
+void mcp25xxfd_can_tx_queue_free(struct mcp25xxfd_can_priv *cpriv)
+{
+	/* eventually we may need to wait here
+	 * for all transfers to have finished
+	 */
+
+	kfree(cpriv->fifos.tx_queue);
+	cpriv->fifos.tx_queue = NULL;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h
new file mode 100644
index 000000000000..1947b3420d58
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CAN_TX_H
+#define __MCP25XXFD_CAN_TX_H
+
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_can_priv.h"
+
+/* structure of a spi message that is prepared and can get submitted quickly */
+struct mcp25xxfd_tx_spi_message {
+	/* the network device this is related to */
+	struct mcp25xxfd_can_priv *cpriv;
+	/* the fifo this fills */
+	u32 fifo;
+	/* the xfer to fill in the fifo data */
+	struct {
+		struct spi_message msg;
+		struct spi_transfer xfer;
+		struct {
+			u8 cmd[2];
+			u8 header[sizeof(struct mcp25xxfd_can_obj_tx)];
+			u8 data[64];
+		} data;
+	} fill_fifo;
+	/* the xfer to enable transmission on the can bus */
+	struct {
+		struct spi_message msg;
+		struct spi_transfer xfer;
+		struct {
+			u8 cmd[2];
+			u8 data;
+		} data;
+	} trigger_fifo;
+};
+
+struct mcp25xxfd_tx_spi_message_queue {
+	/* spinlock protecting the bitmaps
+	 * as well as state and the skb_echo_* functions
+	 */
+	spinlock_t lock;
+	/* bitmap of which fifo is in which stage */
+	u32 idle;
+	u32 in_fill_fifo_transfer;
+	u32 in_trigger_fifo_transfer;
+	u32 in_can_transfer;
+	u32 transferred;
+
+	/* the queue state as seen per controller */
+	int state;
+#define MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED 0
+#define MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED 1
+#define MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE 2
+#define MCP25XXFD_CAN_TX_QUEUE_STATE_RESTART 3
+
+	/* spinlock protecting spi submission order */
+	spinlock_t spi_lock;
+
+	/* map each fifo to a mcp25xxfd_tx_spi_message */
+	struct mcp25xxfd_tx_spi_message *fifo2message[32];
+
+	/* the individual messages */
+	struct mcp25xxfd_tx_spi_message message[];
+};
+
+int mcp25xxfd_can_tx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo);
+void mcp25xxfd_can_tx_queue_restart(struct mcp25xxfd_can_priv *cpriv);
+
+int mcp25xxfd_can_tx_handle_int_txatif(struct mcp25xxfd_can_priv *cpriv);
+int mcp25xxfd_can_tx_handle_int_tefif(struct mcp25xxfd_can_priv *cpriv);
+
+netdev_tx_t mcp25xxfd_can_tx_start_xmit(struct sk_buff *skb,
+					struct net_device *net);
+
+void mcp25xxfd_can_tx_queue_manage(struct mcp25xxfd_can_priv *cpriv, int state);
+
+int mcp25xxfd_can_tx_queue_alloc(struct mcp25xxfd_can_priv *cpriv);
+void mcp25xxfd_can_tx_queue_free(struct mcp25xxfd_can_priv *cpriv);
+
+#endif /* __MCP25XXFD_CAN_TX_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c
new file mode 100644
index 000000000000..03ba25276aa4
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c
@@ -0,0 +1,491 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+/* Known hardware issues and workarounds in this driver:
+ *
+ * * There is one situation where the controller will require a full POR
+ *   (total power off) to recover from a bad Clock configuration.
+ *   This happens when the wrong clock is configured in the device tree
+ *   (say 4MHz are configured, while 40MHz is the actual clock frequency
+ *   of the HW).
+ *   In such a situation the driver tries to enable the PLL, which will
+ *   never synchronize and the controller becomes unresponsive to further
+ *   spi requests until a full POR.
+ *
+ *   Mitigation:
+ *     none as of now
+ *
+ *   Possible implementation of a mitigation/sanity check:
+ *     during initialization:
+ *       * try to identify the HW at 1MHz:
+ *         on success:
+ *           * controller is identified
+ *         on failure:
+ *           * controller is absent - fail
+ *       * force controller clock to run with disabled PLL
+ *       * try to identify the HW at 2MHz:
+ *         on success:
+ *           * controller clock is >= 4 MHz
+ *           * this may be 4MHz
+ *         on failure:
+ *           * controller clock is < 4 MHz
+ *       * try to identify the HW at 2.5MHz:
+ *         on success:
+ *           * controller clock is >= 5 MHz
+ *           * this may not be 4MHz
+ *         on failure:
+ *           * controller clock is 4 MHz
+ *           * enable PLL
+ *           * exit successfully (or run last test for verification purposes)
+ *       * try to identify the HW at <dt-clock/2> MHz:
+ *         on success:
+ *           * controller clock is >= <dt-clock/2> MHz
+ *              (it could be higher though)
+ *         on failure:
+ *           * the controller is not running at the
+ *             clock rate configured in the DT
+ *           * if PLL is enabled warn about requirements of POR
+ *           * fail
+ *
+ *   Side-effects:
+ *     * longer initialization time
+ *
+ *   Possible issues with mitigation:
+ *     * possibly miss-identification because the SPI block may work
+ *       "somewhat" at frequencies > < clock / 2 + delta f>
+ *       this may be especially true for the situation where we test if
+ *       2.5MHz SPI-Clock works.
+ *     * also SPI HW-clock dividers may do a round down to fixed frequencies
+ *       which is not properly reported and may result in false positives
+ *       because a frequency lower than expected is used.
+ *
+ *   This is the reason why only simple testing is enabled at the risk of
+ *   the need for a POR.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_can.h"
+#include "mcp25xxfd_clock.h"
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_priv.h"
+
+/* the PLL may take some time to synchronize - use 1 second as timeout */
+#define MCP25XXFD_OSC_POLLING_JIFFIES	(HZ)
+
+static u32 _mcp25xxfd_clkout_mask(struct mcp25xxfd_priv *priv)
+{
+	u32 val = 0;
+
+	if (priv->config.clock_div2)
+		val |= MCP25XXFD_OSC_SCLKDIV;
+
+	switch (priv->config.clock_odiv) {
+	case 0:
+		break;
+	case 1:
+		val |= MCP25XXFD_OSC_CLKODIV_1 << MCP25XXFD_OSC_CLKODIV_SHIFT;
+		break;
+	case 2:
+		val |= MCP25XXFD_OSC_CLKODIV_2 << MCP25XXFD_OSC_CLKODIV_SHIFT;
+		break;
+	case 4:
+		val |= MCP25XXFD_OSC_CLKODIV_4 << MCP25XXFD_OSC_CLKODIV_SHIFT;
+		break;
+	case 10:
+		val |= MCP25XXFD_OSC_CLKODIV_10 << MCP25XXFD_OSC_CLKODIV_SHIFT;
+		break;
+	default:
+		/* this should never happen but is error-handled
+		 * by the dt-parsing
+		 */
+		break;
+	}
+
+	return val;
+}
+
+static int _mcp25xxfd_waitfor_osc(struct mcp25xxfd_priv *priv,
+				  u32 waitfor, u32 mask)
+{
+	unsigned long timeout;
+	int ret;
+
+	/* wait for synced pll/osc/sclk */
+	timeout = jiffies + MCP25XXFD_OSC_POLLING_JIFFIES;
+	while (time_before_eq(jiffies, timeout)) {
+		ret = mcp25xxfd_cmd_read(priv->spi, MCP25XXFD_OSC,
+					 &priv->regs.osc);
+		if (ret)
+			return ret;
+		/* check for expected bits to be set/unset */
+		if ((priv->regs.osc & mask) == waitfor)
+			return 0;
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int _mcp25xxfd_clock_configure_osc(struct mcp25xxfd_priv *priv,
+					  u32 value, u32 waitfor, u32 mask)
+{
+	int ret;
+
+	/* write the osc value to the controller - waking it if necessary */
+	ret = mcp25xxfd_cmd_write(priv->spi, MCP25XXFD_OSC, value);
+	if (ret)
+		return ret;
+
+	/* wait for the clock to stabelize */
+	ret = _mcp25xxfd_waitfor_osc(priv, waitfor, mask);
+
+	/* on timeout try again setting the register */
+	if (ret == -ETIMEDOUT) {
+		/* write the clock to the controller */
+		ret = mcp25xxfd_cmd_write(priv->spi, MCP25XXFD_OSC, value);
+		if (ret)
+			return ret;
+
+		/* wait for the clock to stabelize */
+		ret = _mcp25xxfd_waitfor_osc(priv, waitfor, mask);
+	}
+
+	/* handle timeout special - report the fact */
+	if (ret == -ETIMEDOUT)
+		dev_err(&priv->spi->dev,
+			"Clock did not switch within the timeout period\n");
+
+	return ret;
+}
+
+static int _mcp25xxfd_clock_start(struct mcp25xxfd_priv *priv)
+{
+	u32 value = _mcp25xxfd_clkout_mask(priv);
+	u32 waitfor = MCP25XXFD_OSC_OSCRDY;
+	u32 mask = waitfor | MCP25XXFD_OSC_OSCDIS | MCP25XXFD_OSC_PLLRDY |
+		MCP25XXFD_OSC_PLLEN;
+
+	/* enable PLL as well - set expectations */
+	if (priv->config.clock_pll) {
+		value   |= MCP25XXFD_OSC_PLLEN;
+		waitfor |= MCP25XXFD_OSC_PLLRDY | MCP25XXFD_OSC_PLLEN;
+	}
+
+	/* set the oscilator now */
+	return _mcp25xxfd_clock_configure_osc(priv, value, waitfor, mask);
+}
+
+static int _mcp25xxfd_clock_stop(struct mcp25xxfd_priv *priv)
+{
+	u32 value = _mcp25xxfd_clkout_mask(priv);
+	u32 waitfor = 0;
+	u32 mask = MCP25XXFD_OSC_OSCDIS | MCP25XXFD_OSC_PLLRDY |
+		MCP25XXFD_OSC_PLLEN;
+	int ret;
+
+	ret = _mcp25xxfd_clock_configure_osc(priv, value, waitfor, mask);
+	if (ret)
+		return ret;
+
+	/* finally switch the controller mode to sleep
+	 * by this time the controller should be in config mode already
+	 * this way we wake to config mode again
+	 */
+	return mcp25xxfd_can_sleep_mode(priv);
+}
+
+int mcp25xxfd_clock_start(struct mcp25xxfd_priv *priv, int requestor_mask)
+{
+	int ret = 0;
+
+	/* without a clock there is nothing we can do... */
+	if (IS_ERR(priv->clk))
+		return PTR_ERR(priv->clk);
+
+	mutex_lock(&priv->clk_user_lock);
+
+	/* if clock is already started, then skip */
+	if (priv->clk_user_mask & requestor_mask)
+		goto out;
+
+	/* enable the clock on the host side*/
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		goto out;
+
+	/* enable the clock on the controller side */
+	ret = _mcp25xxfd_clock_start(priv);
+	if (ret)
+		goto out;
+
+	/* mark the clock for the specific component as started */
+	priv->clk_user_mask |= requestor_mask;
+
+	/* and now we use the normal spi speed */
+	priv->spi_use_speed_hz = priv->spi_normal_speed_hz;
+
+out:
+	mutex_unlock(&priv->clk_user_lock);
+
+	return ret;
+}
+
+int mcp25xxfd_clock_stop(struct mcp25xxfd_priv *priv, int requestor_mask)
+{
+	int ret;
+
+	/* without a clock there is nothing we can do... */
+	if (IS_ERR(priv->clk))
+		return PTR_ERR(priv->clk);
+
+	mutex_lock(&priv->clk_user_lock);
+
+	/* if the mask is empty then skip, as the clock is stopped */
+	if (!priv->clk_user_mask)
+		goto out;
+
+	/* clear the clock mask */
+	priv->clk_user_mask &= ~requestor_mask;
+
+	/* if the mask is not empty then skip, as the clock is needed */
+	if (priv->clk_user_mask)
+		goto out;
+
+	/* and now we use the setup spi speed */
+	priv->spi_use_speed_hz = priv->spi_setup_speed_hz;
+
+	/* stop the clock on the controller */
+	ret = _mcp25xxfd_clock_stop(priv);
+
+	/* and we stop the clock on the host*/
+	if (!IS_ERR(priv->clk))
+		clk_disable_unprepare(priv->clk);
+out:
+	mutex_unlock(&priv->clk_user_lock);
+
+	return 0;
+}
+
+static int _mcp25xxfd_clock_probe(struct mcp25xxfd_priv *priv)
+{
+	int ret;
+
+	/* Wait for oscillator startup timer after power up */
+	mdelay(MCP25XXFD_OST_DELAY_MS);
+
+	/* send a "blind" reset, hoping we are in Config mode */
+	mcp25xxfd_cmd_reset(priv->spi);
+
+	/* Wait for oscillator startup again */
+	mdelay(MCP25XXFD_OST_DELAY_MS);
+
+	/* check clock register that the clock is ready or disabled */
+	ret = mcp25xxfd_cmd_read_regs(priv->spi, MCP25XXFD_OSC |
+				      MCP25XXFD_ADDRESS_WITH_CRC,
+				      &priv->regs.osc,4);
+	if (ret == -EILSEQ)
+		dev_err(&priv->spi->dev,
+			"CRC read of clock register resulted in a bad CRC mismatch - hw not found\n");
+
+	if (ret)
+		return ret;
+
+	/* there can only be one... */
+	switch (priv->regs.osc &
+		(MCP25XXFD_OSC_OSCRDY | MCP25XXFD_OSC_OSCDIS)) {
+	case MCP25XXFD_OSC_OSCRDY: /* either the clock is ready */
+		break;
+	case MCP25XXFD_OSC_OSCDIS: /* or the clock is disabled */
+		break;
+	default:
+		/* otherwise there is no valid device (or in strange state)
+		 *
+		 * if PLL is enabled but not ready, then there may be
+		 * something "fishy"
+		 * this happened during driver development
+		 * (enabling pll, when when on wrong clock), so best warn
+		 * about such a possibility
+		 */
+		if ((priv->regs.osc &
+		     (MCP25XXFD_OSC_PLLEN | MCP25XXFD_OSC_PLLRDY))
+		    == MCP25XXFD_OSC_PLLEN)
+			dev_err(&priv->spi->dev,
+				"mcp25xxfd may be in a strange state - a power disconnect may be required\n");
+
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+int mcp25xxfd_clock_probe(struct mcp25xxfd_priv *priv)
+{
+	int ret;
+
+	/* this will also enable the MCP25XXFD_CLK_USER_CAN clock */
+	ret = _mcp25xxfd_clock_probe(priv);
+
+	/* on error retry a second time */
+	if (ret == -ENODEV) {
+		ret = _mcp25xxfd_clock_probe(priv);
+		if (!ret)
+			dev_info(&priv->spi->dev,
+				 "found device only during retry\n");
+	}
+	if (ret) {
+		if (ret == -ENODEV)
+			dev_err(&priv->spi->dev,
+				"Cannot initialize MCP%x. Wrong wiring? (oscilator register reads as %08x)\n",
+				priv->model, priv->regs.osc);
+	}
+
+	return ret;
+}
+
+void mcp25xxfd_clock_release(struct mcp25xxfd_priv *priv)
+{
+	if (!IS_ERR_OR_NULL(priv->clk))
+		clk_disable_unprepare(priv->clk);
+}
+
+#ifdef CONFIG_OF_DYNAMIC
+static int mcp25xxfd_clock_of_parse(struct mcp25xxfd_priv *priv)
+{
+	struct spi_device *spi = priv->spi;
+	const struct device_node *np = spi->dev.of_node;
+	u32 val;
+	int ret;
+
+	priv->config.clock_div2 = false;
+	priv->config.clock_div2 =
+		of_property_read_bool(np, "microchip,clock-div2");
+
+	priv->config.clock_odiv = 10;
+	ret = of_property_read_u32_index(np, "microchip,clock-out-div",
+					 0, &val);
+	if (!ret) {
+		switch (val) {
+		case 0:
+		case 1:
+		case 2:
+		case 4:
+		case 10:
+			priv->config.clock_odiv = val;
+			break;
+		default:
+			dev_err(&spi->dev,
+				"Invalid value in device tree for microchip,clock_out_div: %u - valid values: 0, 1, 2, 4, 10\n",
+				val);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+#else
+static int mcp25xxfd_clock_of_parse(struct mcp25xxfd_priv *priv)
+{
+	return 0;
+}
+#endif
+
+int mcp25xxfd_clock_init(struct mcp25xxfd_priv *priv)
+{
+	struct spi_device *spi = priv->spi;
+	struct clk *clk;
+	int ret, freq;
+
+	mutex_init(&priv->clk_user_lock);
+
+	priv->config.clock_div2 = false;
+	priv->config.clock_odiv = 10;
+
+	ret = mcp25xxfd_clock_of_parse(priv);
+	if (ret)
+		return ret;
+
+	/* get clock */
+	clk = devm_clk_get(&spi->dev, NULL);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	freq = clk_get_rate(clk);
+	if (freq < MCP25XXFD_MIN_CLOCK_FREQUENCY ||
+	    freq > MCP25XXFD_MAX_CLOCK_FREQUENCY) {
+		dev_err(&spi->dev,
+			"Clock frequency %i is not in range [%i:%i]\n",
+			freq,
+			MCP25XXFD_MIN_CLOCK_FREQUENCY,
+			MCP25XXFD_MAX_CLOCK_FREQUENCY);
+		return -ERANGE;
+	}
+
+	/* enable the clock and mark as enabled */
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
+	priv->clk = clk;
+
+	/* if we have a clock that is <= 4MHz, enable the pll */
+	priv->config.clock_pll =
+		(freq <= MCP25XXFD_AUTO_PLL_MAX_CLOCK_FREQUENCY);
+
+	/* decide on the effective clock rate */
+	priv->clock_freq = freq;
+	if (priv->config.clock_pll)
+		priv->clock_freq *= MCP25XXFD_PLL_MULTIPLIER;
+	if (priv->config.clock_div2)
+		priv->clock_freq /= MCP25XXFD_SCLK_DIVIDER;
+
+	/* calculate the clock frequencies to use
+	 *
+	 * setup clock speed is at most 1/4 the input clock speed
+	 * the reason for the factor of 4 is that there is
+	 * a clock divider in the controller that MAY be enabled in some
+	 * circumstances so we may find a controller with that enabled
+	 * during probe phase
+	 */
+	priv->spi_setup_speed_hz = freq / 4;
+
+	/* normal operation clock speeds */
+	priv->spi_normal_speed_hz = priv->clock_freq / 2;
+	if (priv->config.clock_div2) {
+		priv->spi_setup_speed_hz /= MCP25XXFD_SCLK_DIVIDER;
+		priv->spi_normal_speed_hz /= MCP25XXFD_SCLK_DIVIDER;
+	}
+
+	/* set limit on speed */
+	if (spi->max_speed_hz) {
+		priv->spi_setup_speed_hz = min_t(int,
+						 priv->spi_setup_speed_hz,
+						 spi->max_speed_hz);
+		priv->spi_normal_speed_hz = min_t(int,
+						  priv->spi_normal_speed_hz,
+						  spi->max_speed_hz);
+	}
+
+	/* use setup speed by default
+	 * - this is switched when clock is enabled/disabled
+	 */
+	priv->spi_use_speed_hz = priv->spi_setup_speed_hz;
+
+	return 0;
+}
+
+void mcp25xxfd_clock_fake_sleep(struct mcp25xxfd_priv *priv)
+{
+	priv->regs.osc &= ~(MCP25XXFD_OSC_OSCRDY |
+			    MCP25XXFD_OSC_PLLRDY |
+			    MCP25XXFD_OSC_SCLKRDY);
+	priv->regs.osc |= MCP25XXFD_OSC_OSCDIS;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h
new file mode 100644
index 000000000000..049e95cfa9ad
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CLOCK_H
+#define __MCP25XXFD_CLOCK_H
+
+#include "mcp25xxfd_priv.h"
+
+#define MCP25XXFD_CLK_USER_CAN BIT(0)
+#define MCP25XXFD_CLK_USER_GPIO0 BIT(1)
+#define MCP25XXFD_CLK_USER_GPIO1 BIT(2)
+#define MCP25XXFD_CLK_USER_CLKOUT BIT(3)
+
+/* shared (internal) clock control */
+int mcp25xxfd_clock_init(struct mcp25xxfd_priv *priv);
+int mcp25xxfd_clock_probe(struct mcp25xxfd_priv *priv);
+void mcp25xxfd_clock_release(struct mcp25xxfd_priv *priv);
+
+int mcp25xxfd_clock_stop(struct mcp25xxfd_priv *priv, int requestor_mask);
+int mcp25xxfd_clock_start(struct mcp25xxfd_priv *priv, int requestor_mask);
+
+void mcp25xxfd_clock_fake_sleep(struct mcp25xxfd_priv *priv);
+
+#endif /* __MCP25XXFD_CLOCK_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c
new file mode 100644
index 000000000000..6d895613111e
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c
@@ -0,0 +1,401 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_crc.h"
+#include "mcp25xxfd_priv.h"
+
+/* module parameter */
+static bool use_spi_crc;
+module_param(use_spi_crc, bool, 0664);
+MODULE_PARM_DESC(use_spi_crc, "Use SPI CRC instruction\n");
+
+/* SPI helper */
+
+/* wrapper arround spi_sync, that sets speed_hz */
+static int mcp25xxfd_cmd_sync_transfer(struct spi_device *spi,
+				       struct spi_transfer *xfer,
+				       unsigned int xfers)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	int i;
+
+	for (i = 0; i < xfers; i++)
+		xfer[i].speed_hz = priv->spi_use_speed_hz;
+
+	return spi_sync_transfer(spi, xfer, xfers);
+}
+
+/* simple spi_write wrapper with speed_hz
+ * WARINING: tx_buf needs to be on heap!
+ */
+static int mcp25xxfd_cmd_sync_write(struct spi_device *spi,
+				    const void *tx_buf,
+				    unsigned int tx_len)
+{
+	struct spi_transfer xfer;
+
+	memset(&xfer, 0, sizeof(xfer));
+	xfer.tx_buf = tx_buf;
+	xfer.len = tx_len;
+
+	return mcp25xxfd_cmd_sync_transfer(spi, &xfer, 1);
+}
+
+/* alloc buffer */
+static int mcp25xxfd_cmd_alloc_buf(struct spi_device *spi,
+				   size_t len,
+				   u8 **tx, u8 **rx)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+
+	/* allocate from heap in case the size is to big
+	 * or the preallocated buffer is already used (i.e locked)
+	 */
+	if (len > sizeof(priv->spi_tx) ||
+	    !mutex_trylock(&priv->spi_rxtx_lock)) {
+		/* allocate tx+rx in one allocation if rx is requested */
+		*tx = kzalloc(rx ? 2 * len : len, GFP_KERNEL);
+		if (!*tx)
+			return -ENOMEM;
+		if (rx)
+			*rx = *tx + len;
+	} else {
+		/* use the preallocated buffers instead */
+		*tx = priv->spi_tx;
+		memset(priv->spi_tx, 0, sizeof(priv->spi_tx));
+		if (rx) {
+			*rx = priv->spi_rx;
+			memset(priv->spi_rx, 0, sizeof(priv->spi_rx));
+		}
+	}
+
+	return 0;
+}
+
+static void mcp25xxfd_cmd_release_buf(struct spi_device *spi, u8 *tx, u8 *rx)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+
+	if (tx == priv->spi_tx)
+		mutex_unlock(&priv->spi_rxtx_lock);
+	else
+		kfree(tx);
+}
+
+/* an optimization of spi_write_then_read that merges the transfers
+ * this also makes sure that the data is ALWAYS on heap
+ */
+static int mcp25xxfd_cmd_write_then_read(struct spi_device *spi,
+					 const void *tx_buf,
+					 unsigned int tx_len,
+					 void *rx_buf,
+					 unsigned int rx_len,
+					 void *crc_buf)
+{
+	int crc_len = crc_buf ? 2 : 0;
+	struct spi_transfer xfer[2];
+	u8 *spi_tx, *spi_rx;
+	int xfers;
+	int ret;
+
+	/* get pointer to buffers */
+	ret = mcp25xxfd_cmd_alloc_buf(spi, tx_len + rx_len + crc_len,
+				      &spi_tx, &spi_rx);
+	if (ret)
+		return ret;
+
+	/* clear the xfers */
+	memset(xfer, 0, sizeof(xfer));
+
+	/* special handling for half-duplex */
+	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX) {
+		xfers = 2;
+		xfer[0].tx_buf = spi_tx;
+		xfer[0].len = tx_len;
+		/* the offset for rx_buf needs to get aligned */
+		xfer[1].rx_buf = spi_rx + tx_len;
+		xfer[1].len = rx_len + crc_len;
+	} else {
+		xfers = 1;
+		xfer[0].len = tx_len + rx_len + crc_len;
+		xfer[0].tx_buf = spi_tx;
+		xfer[0].rx_buf = spi_rx;
+	}
+
+	/* copy data - especially to avoid buffers from stack */
+	memcpy(spi_tx, tx_buf, tx_len);
+
+	/* do the transfer */
+	ret = mcp25xxfd_cmd_sync_transfer(spi, xfer, xfers);
+	if (ret)
+		goto out;
+
+	/* copy result back */
+	memcpy(rx_buf, xfer[0].rx_buf + tx_len, rx_len);
+	if (crc_buf)
+		memcpy(crc_buf, xfer[0].rx_buf + tx_len + rx_len, crc_len);
+
+out:
+	mcp25xxfd_cmd_release_buf(spi, spi_tx, spi_rx);
+
+	return ret;
+}
+
+static int mcp25xxfd_cmd_write_then_write(struct spi_device *spi,
+					  const void *tx_buf,
+					  unsigned int tx_len,
+					  const void *tx2_buf,
+					  unsigned int tx2_len)
+{
+	struct spi_transfer xfer;
+	u8 *spi_tx;
+	int ret;
+
+	/* get pointer to buffers */
+	ret = mcp25xxfd_cmd_alloc_buf(spi, tx_len + tx2_len, &spi_tx, NULL);
+	if (ret)
+		return ret;
+
+	/* setup xfer */
+	memset(&xfer, 0, sizeof(xfer));
+	xfer.len = tx_len + tx2_len;
+	xfer.tx_buf = spi_tx;
+
+	/* copy data to correct location in buffer */
+	memcpy(spi_tx, tx_buf, tx_len);
+	memcpy(spi_tx + tx_len, tx2_buf, tx2_len);
+
+	/* run the transfer */
+	ret = mcp25xxfd_cmd_sync_transfer(spi, &xfer, 1);
+
+	mcp25xxfd_cmd_release_buf(spi, spi_tx, NULL);
+
+	return ret;
+}
+
+/* mcp25xxfd spi command/protocol helper */
+
+/* read multiple bytes, transform some registers */
+int mcp25xxfd_cmd_readn(struct spi_device *spi, u32 reg,
+			void *data, int n)
+{
+	u8 cmd[2];
+	int ret;
+
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_READ, reg, cmd);
+
+	ret = mcp25xxfd_cmd_write_then_read(spi, &cmd, 2, data, n, NULL);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static u16 _mcp25xxfd_cmd_compute_crc(u8 *cmd, u8 *data, int n)
+{
+	u16 crc = 0xffff;
+
+	crc = mcp25xxfd_crc(crc, cmd, 3);
+	crc = mcp25xxfd_crc(crc, data, n);
+
+	return crc;
+}
+
+static int _mcp25xxfd_cmd_readn_crc(struct spi_device *spi, u32 reg,
+				    void *data, int n)
+{
+	u8 cmd[3], crcd[2];
+	u16 crcc, crcr;
+	int ret;
+
+	/* prepare command */
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_READ_CRC, reg, cmd);
+	/* count depends on word (=RAM) or byte access (Registers) */
+	if (reg < MCP25XXFD_SRAM_ADDR(0) ||
+	    reg >= MCP25XXFD_SRAM_ADDR(MCP25XXFD_SRAM_SIZE))
+		cmd[2] = n;
+	else
+		cmd[2] = n / 4;
+
+	/* now read for real */
+	ret = mcp25xxfd_cmd_write_then_read(spi, &cmd, 3, data, n, crcd);
+	if (ret)
+		return ret;
+
+	/* the received crc */
+	crcr = (crcd[0] << 8) + crcd[1];
+
+	/* compute the crc */
+	crcc = _mcp25xxfd_cmd_compute_crc(cmd, data, n);
+
+	/* if it matches, then return */
+	if (crcc == crcr)
+		return 0;
+
+	/* here possibly handle crc variants with a single bit7 flips */
+
+	/* return with error and rate limited */
+	dev_err_ratelimited(&spi->dev,
+			    "CRC read error: computed: %04x received: %04x - data: %*ph %*ph%s\n",
+			    crcc, crcr, 3, cmd, min_t(int, 64, n), data,
+			    (n > 64) ? "..." : "");
+	return -EILSEQ;
+}
+
+static int mcp25xxfd_cmd_readn_crc(struct spi_device *spi, u32 reg,
+				   void *data, int n)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	int ret;
+
+	for (; n > 0; n -= 254, reg += 254, data += 254) {
+#if defined(CONFIG_DEBUG_FS)
+		priv->stats.spi_crc_read++;
+		if (n > 254)
+			priv->stats.spi_crc_read_split++;
+#endif
+		ret = _mcp25xxfd_cmd_readn_crc(spi, reg, data, n);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* read a register, but we are only interrested in a few bytes */
+int mcp25xxfd_cmd_read_mask(struct spi_device *spi, u32 reg,
+			    u32 *data, u32 mask)
+{
+	int first_byte, last_byte, len_byte;
+	int ret;
+
+	/* check that at least one bit is set */
+	if (!mask)
+		return -EINVAL;
+
+	/* calculate first and last byte used */
+	first_byte = mcp25xxfd_cmd_first_byte(mask);
+	last_byte = mcp25xxfd_cmd_last_byte(mask);
+	len_byte = last_byte - first_byte + 1;
+
+	mcp25xxfd_cmd_convert_from_cpu(data, 1);
+
+	/* do a partial read */
+	ret = mcp25xxfd_cmd_readn(spi, reg + first_byte,
+				  ((void *)data + first_byte), len_byte);
+	if (ret)
+		return ret;
+
+	mcp25xxfd_cmd_convert_to_cpu(data, 1);
+
+	return 0;
+}
+
+int mcp25xxfd_cmd_writen(struct spi_device *spi, u32 reg,
+			 void *data, int n)
+{
+	u8 cmd[2];
+	int ret;
+
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE, reg, cmd);
+
+	ret = mcp25xxfd_cmd_write_then_write(spi, &cmd, 2, data, n);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/* read a register, but we are only interrested in a few bytes */
+int mcp25xxfd_cmd_write_mask(struct spi_device *spi, u32 reg,
+			     u32 data, u32 mask)
+{
+	int first_byte, last_byte, len_byte;
+	u8 cmd[2];
+
+	/* check that at least one bit is set */
+	if (!mask)
+		return -EINVAL;
+
+	/* calculate first and last byte used */
+	first_byte = mcp25xxfd_cmd_first_byte(mask);
+	last_byte = mcp25xxfd_cmd_last_byte(mask);
+	len_byte = last_byte - first_byte + 1;
+
+	/* prepare buffer */
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE,
+			   reg + first_byte, cmd);
+
+	mcp25xxfd_cmd_convert_from_cpu(&data, 1);
+
+	return mcp25xxfd_cmd_write_then_write(spi,
+					      cmd, sizeof(cmd),
+					      ((void *)&data + first_byte),
+					      len_byte);
+}
+
+int mcp25xxfd_cmd_write_regs(struct spi_device *spi, u32 reg,
+			     u32 *data, u32 bytes)
+{
+	int ret;
+
+	/* first transpose to controller format */
+	mcp25xxfd_cmd_convert_from_cpu(data, bytes / sizeof(bytes));
+
+	/* now write it */
+	ret = mcp25xxfd_cmd_writen(spi, reg, data, bytes);
+
+	/* and convert it back to cpu format even if it fails */
+	mcp25xxfd_cmd_convert_to_cpu(data, bytes / sizeof(bytes));
+
+	return ret;
+}
+
+int mcp25xxfd_cmd_read_regs(struct spi_device *spi, u32 reg,
+			    u32 *data, u32 bytes)
+{
+	int ret;
+
+	/* read it using crc */
+	if ((use_spi_crc) || (reg & MCP25XXFD_ADDRESS_WITH_CRC))
+		ret = mcp25xxfd_cmd_readn_crc(spi,
+					      reg & MCP25XXFD_ADDRESS_MASK,
+					      data, bytes);
+	else
+		ret = mcp25xxfd_cmd_readn(spi, reg, data, bytes);
+
+	/* and convert it to cpu format */
+	mcp25xxfd_cmd_convert_to_cpu((u32 *)data, bytes / sizeof(bytes));
+
+	return ret;
+}
+
+int mcp25xxfd_cmd_reset(struct spi_device *spi)
+{
+	u8 *cmd;
+	int ret;
+
+	/* allocate 2 bytes on heap, as we use sync_write */
+	cmd = kzalloc(2, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_RESET, 0, cmd);
+
+	/* write the reset command */
+	ret = mcp25xxfd_cmd_sync_write(spi, cmd, 2);
+
+	kfree(cmd);
+
+	return ret;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h
new file mode 100644
index 000000000000..595b85294452
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_CMD_H
+#define __MCP25XXFD_CMD_H
+
+#include <linux/byteorder/generic.h>
+#include <linux/spi/spi.h>
+
+/* SPI commands */
+#define MCP25XXFD_INSTRUCTION_RESET		0x0000
+#define MCP25XXFD_INSTRUCTION_READ		0x3000
+#define MCP25XXFD_INSTRUCTION_WRITE		0x2000
+#define MCP25XXFD_INSTRUCTION_READ_CRC		0xB000
+#define MCP25XXFD_INSTRUCTION_WRITE_CRC		0xA000
+#define MCP25XXFD_INSTRUCTION_WRITE_SAVE	0xC000
+
+#define MCP25XXFD_ADDRESS_MASK			0x0fff
+/* a bit to use CRC commands if possible */
+#define MCP25XXFD_ADDRESS_WITH_CRC		BIT(31)
+
+static inline void mcp25xxfd_cmd_convert_to_cpu(u32 *data, int n)
+{
+	le32_to_cpu_array(data, n);
+}
+
+static inline void mcp25xxfd_cmd_convert_from_cpu(u32 *data, int n)
+{
+	cpu_to_le32_array(data, n);
+}
+
+static inline void mcp25xxfd_cmd_calc(u16 cmd, u16 addr, u8 *data)
+{
+	cmd = cmd | (addr & MCP25XXFD_ADDRESS_MASK);
+
+	data[0] = (cmd >> 8) & 0xff;
+	data[1] = (cmd >> 0) & 0xff;
+}
+
+static inline int mcp25xxfd_cmd_first_byte(u32 mask)
+{
+	return (mask & 0x0000ffff) ?
+		((mask & 0x000000ff) ? 0 : 1) :
+		((mask & 0x00ff0000) ? 2 : 3);
+}
+
+static inline int mcp25xxfd_cmd_last_byte(u32 mask)
+{
+	return (mask & 0xffff0000) ?
+		((mask & 0xff000000) ? 3 : 2) :
+		((mask & 0x0000ff00) ? 1 : 0);
+}
+
+int mcp25xxfd_cmd_readn(struct spi_device *spi, u32 reg,
+			void *data, int n);
+int mcp25xxfd_cmd_read_mask(struct spi_device *spi, u32 reg,
+			    u32 *data, u32 mask);
+static inline int mcp25xxfd_cmd_read(struct spi_device *spi, u32 reg,
+				     u32 *data)
+{
+	return mcp25xxfd_cmd_read_mask(spi, reg, data, -1);
+}
+
+int mcp25xxfd_cmd_read_regs(struct spi_device *spi, u32 reg,
+			    u32 *data, u32 bytes);
+
+int mcp25xxfd_cmd_writen(struct spi_device *spi, u32 reg,
+			 void *data, int n);
+int mcp25xxfd_cmd_write_mask(struct spi_device *spi, u32 reg,
+			     u32 data, u32 mask);
+static inline int mcp25xxfd_cmd_write(struct spi_device *spi, u32 reg,
+				      u32 data)
+{
+	return mcp25xxfd_cmd_write_mask(spi, reg, data, -1);
+}
+
+int mcp25xxfd_cmd_write_regs(struct spi_device *spi, u32 reg,
+			     u32 *data, u32 bytes);
+
+int mcp25xxfd_cmd_reset(struct spi_device *spi);
+
+#endif /* __MCP25XXFD_CMD_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.c
similarity index 63%
rename from drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
rename to drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.c
index bd591bfb4ccc..466f989845dd 100644
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.c
@@ -1,26 +1,26 @@
 // SPDX-License-Identifier: GPL-2.0
-//
-// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
-//
-// Copyright (c) 2020 Pengutronix,
-//                    Marc Kleine-Budde <kernel@pengutronix.de>
-//
-// Based on:
-//
-// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
-//
-// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
-//
 
-#include "mcp25xxfd.h"
-
-/* The standard crc16 in linux/crc16.h is unfortunately not computing
- * the correct results (left shift vs. right shift). So here an
- * implementation with a table generated with the help of:
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
  *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_crc.h"
+#include "mcp25xxfd_regs.h"
+#include "mcp25xxfd_priv.h"
+
+/* the standard crc16 in linux/crc16.h is unfortunately not
+ * computing the correct results (left shift vs. right shift)
+ * so here an implementation with a table generated by:
  * http://lkml.iu.edu/hypermail/linux/kernel/0508.1/1085.html
+ *
+ * if someone has a better idea how to make crc16 produce the expected
+ * result, then please come forward...
  */
-static const u16 mcp25xxfd_crc16_table[] = {
+static const u16 _mcp25xxfd_crc_table[256] = {
 	0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011,
 	0x8033, 0x0036, 0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022,
 	0x8063, 0x0066, 0x006c, 0x8069, 0x0078, 0x807d, 0x8077, 0x0072,
@@ -55,28 +55,34 @@ static const u16 mcp25xxfd_crc16_table[] = {
 	0x8213, 0x0216, 0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202
 };
 
-static inline u16 mcp25xxfd_crc16_byte(u16 crc, const u8 data)
+static inline u16 mcp25xxfd_crc_byte(u16 crc, const u8 data)
 {
 	u8 index = (crc >> 8) ^ data;
 
-	return (crc << 8) ^ mcp25xxfd_crc16_table[index];
+	return (crc << 8) ^ _mcp25xxfd_crc_table[index];
 }
 
-static u16 mcp25xxfd_crc16(u16 crc, u8 const *buffer, size_t len)
+u16 mcp25xxfd_crc(u16 crc, u8 const *buffer, size_t len)
 {
 	while (len--)
-		crc = mcp25xxfd_crc16_byte(crc, *buffer++);
-
+		crc = mcp25xxfd_crc_byte(crc, *buffer++);
 	return crc;
 }
 
-u16 mcp25xxfd_crc16_compute(const void *cmd, size_t cmd_size,
-			    const void *data, size_t data_size)
+int mcp25xxfd_crc_enable_int(struct mcp25xxfd_priv *priv, bool enable)
 {
-	u16 crc = 0xffff;
+	u32 mask = MCP25XXFD_CRC_CRCERRIE | MCP25XXFD_CRC_FERRIE;
 
-	crc = mcp25xxfd_crc16(crc, cmd, cmd_size);
-	crc = mcp25xxfd_crc16(crc, data, data_size);
+	priv->regs.crc &= ~mask;
+	priv->regs.crc |= enable ? mask : 0;
 
-	return crc;
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CRC,
+					priv->regs.crc, mask);
+}
+
+int mcp25xxfd_crc_clear_int(struct mcp25xxfd_priv *priv)
+{
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CRC, 0,
+					MCP25XXFD_CRC_CRCERRIF |
+					MCP25XXFD_CRC_FERRIF);
 }
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h
new file mode 100644
index 000000000000..25db96b0b9c9
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_CRC_H
+#define __MCP25XXFD_CRC_H
+
+#include "mcp25xxfd_priv.h"
+
+int mcp25xxfd_crc_enable_int(struct mcp25xxfd_priv *priv, bool enable);
+int mcp25xxfd_crc_clear_int(struct mcp25xxfd_priv *priv);
+
+u16 mcp25xxfd_crc(u16 crc, u8 const *buffer, size_t len);
+
+#endif /* __MCP25XXFD_CRC_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c
new file mode 100644
index 000000000000..303bcba27919
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_debugfs.h"
+#include "mcp25xxfd_priv.h"
+
+static int mcp25xxfd_debugfs_dump_regs_range(struct seq_file *file,
+					     u32 start, u32 end)
+{
+	struct spi_device *spi = file->private;
+	u32 data[32];
+	int bytes = end - start + sizeof(*data);
+	int i, l, count, ret;
+
+	for (count =  bytes / sizeof(*data); count > 0; count -= 32) {
+		/* read up to 32 registers in one go */
+		l = min(count, 32);
+		ret = mcp25xxfd_cmd_read_regs(spi, start,
+					      data, l * sizeof(*data));
+		if (ret)
+			return ret;
+		/* dump those read registers */
+		for (i = 0; i < l; i++, start += sizeof(*data))
+			seq_printf(file, "Reg 0x%03x = 0x%08x\n",
+				   start, data[i]);
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_debugfs_dump_regs(struct seq_file *file, void *offset)
+{
+	return mcp25xxfd_debugfs_dump_regs_range(file, MCP25XXFD_OSC,
+						 MCP25XXFD_DEVID);
+}
+
+static int mcp25xxfd_debugfs_dump_can_regs(struct seq_file *file,
+					   void *offset)
+{
+	return mcp25xxfd_debugfs_dump_regs_range(file, MCP25XXFD_CAN_CON,
+						 MCP25XXFD_CAN_TXQUA);
+}
+
+static int mcp25xxfd_debugfs_dump_can_all_regs(struct seq_file *file,
+					       void *offset)
+{
+	return mcp25xxfd_debugfs_dump_regs_range(file, MCP25XXFD_CAN_CON,
+						 MCP25XXFD_CAN_FLTMASK(31));
+}
+
+static void mcp25xxfd_debugfs_mod_setup(struct mcp25xxfd_priv *priv)
+{
+	struct dentry *root, *regs;
+
+	/* the base directory */
+	priv->debugfs_dir = debugfs_create_dir(priv->device_name, NULL);
+	root = priv->debugfs_dir;
+
+	/* expose some parameters related to clocks */
+	debugfs_create_u32("spi_setup_speed_hz", 0644, root,
+			   &priv->spi_setup_speed_hz);
+	debugfs_create_u32("spi_normal_speed_hz", 0644, root,
+			   &priv->spi_normal_speed_hz);
+	debugfs_create_u32("spi_use_speed_hz", 0644, root,
+			   &priv->spi_use_speed_hz);
+	debugfs_create_u32("clk_user_mask", 0444, root, &priv->clk_user_mask);
+
+	/* some statistics */
+	debugfs_create_u64("spi_crc_read", 0444, root,
+			   &priv->stats.spi_crc_read);
+	debugfs_create_u64("spi_crc_read_split", 0444, root,
+			   &priv->stats.spi_crc_read_split);
+
+	/* expose the system registers */
+	priv->debugfs_regs_dir = debugfs_create_dir("regs", root);
+	regs = priv->debugfs_regs_dir;
+	debugfs_create_x32("osc", 0444, regs, &priv->regs.osc);
+	debugfs_create_x32("iocon", 0444, regs, &priv->regs.iocon);
+	debugfs_create_x32("crc", 0444, regs, &priv->regs.crc);
+	debugfs_create_x32("ecccon", 0444, regs, &priv->regs.ecccon);
+
+	/* dump the controller registers themselves */
+	debugfs_create_devm_seqfile(&priv->spi->dev, "regs_live_dump",
+				    root, mcp25xxfd_debugfs_dump_regs);
+	/* and the essential can registers */
+	debugfs_create_devm_seqfile(&priv->spi->dev, "can_regs_live_dump",
+				    root, mcp25xxfd_debugfs_dump_can_regs);
+	/* and the complete can registers */
+	debugfs_create_devm_seqfile(&priv->spi->dev,
+				    "can_regs_all_live_dump", root,
+				    mcp25xxfd_debugfs_dump_can_all_regs);
+}
+
+void mcp25xxfd_debugfs_setup(struct mcp25xxfd_priv *priv)
+{
+	mcp25xxfd_debugfs_mod_setup(priv);
+}
+
+void mcp25xxfd_debugfs_remove(struct mcp25xxfd_priv *priv)
+{
+	debugfs_remove_recursive(priv->debugfs_dir);
+	priv->debugfs_dir = NULL;
+}
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h
new file mode 100644
index 000000000000..800672442ffb
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_DEBUGFS_H
+#define __MCP25XXFD_DEBUGFS_H
+
+#include "mcp25xxfd_priv.h"
+
+#ifdef CONFIG_DEBUG_FS
+
+void mcp25xxfd_debugfs_setup(struct mcp25xxfd_priv *priv);
+void mcp25xxfd_debugfs_remove(struct mcp25xxfd_priv *priv);
+
+#else
+
+static inline void mcp25xxfd_debugfs_setup(struct mcp25xxfd_priv *priv)
+{
+	return 0;
+}
+
+static inline void mcp25xxfd_debugfs_remove(struct mcp25xxfd_priv *priv)
+{
+}
+
+#endif /* CONFIG_DEBUG_FS */
+#endif /* __MCP25XXFD_DEBUGFS_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c
new file mode 100644
index 000000000000..526f345d0a17
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_ecc.h"
+#include "mcp25xxfd_priv.h"
+#include "mcp25xxfd_regs.h"
+
+int mcp25xxfd_ecc_clear_int(struct mcp25xxfd_priv *priv)
+{
+	u32 val, addr;
+	int ret;
+
+	/* first report the error address */
+	ret = mcp25xxfd_cmd_read(priv->spi, MCP25XXFD_ECCSTAT, &val);
+	if (ret)
+		return ret;
+
+	/* if no flags are set then nothing to do */
+	if (!(val & (MCP25XXFD_ECCSTAT_SECIF | MCP25XXFD_ECCSTAT_DEDIF)))
+		return 0;
+
+	addr = (val & MCP25XXFD_ECCSTAT_ERRADDR_MASK) >>
+		MCP25XXFD_ECCSTAT_ERRADDR_SHIFT;
+
+	dev_err_ratelimited(&priv->spi->dev, "ECC %s bit error at %03x\n",
+			    (val & MCP25XXFD_ECCSTAT_DEDIF) ?
+			    "double" : "single",
+			    addr);
+
+	/* and clear the error */
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_ECCSTAT, 0,
+					MCP25XXFD_ECCSTAT_SECIF |
+					MCP25XXFD_ECCSTAT_DEDIF);
+}
+
+int mcp25xxfd_ecc_enable_int(struct mcp25xxfd_priv *priv, bool enable)
+{
+	u32 mask = MCP25XXFD_ECCCON_SECIE | MCP25XXFD_ECCCON_DEDIE;
+
+	priv->regs.ecccon &= ~mask;
+	priv->regs.ecccon |= MCP25XXFD_ECCCON_ECCEN | (enable ? mask : 0);
+
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_ECCCON,
+					priv->regs.ecccon,
+					MCP25XXFD_ECCCON_ECCEN | mask);
+}
+
+int mcp25xxfd_ecc_enable(struct mcp25xxfd_priv *priv)
+{
+	u8 buffer[256];
+	int i, ret;
+
+	/* set up RAM ECC - enable interrupts sets it as well */
+	ret = mcp25xxfd_ecc_enable_int(priv, false);
+	if (ret)
+		return ret;
+
+	/* and clear SRAM so that no reads fails from now on */
+	memset(buffer, 0, sizeof(buffer));
+	for (i = 0; i < MCP25XXFD_SRAM_SIZE; i += sizeof(buffer)) {
+		ret = mcp25xxfd_cmd_writen(priv->spi, MCP25XXFD_SRAM_ADDR(i),
+					   buffer, sizeof(buffer));
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h
new file mode 100644
index 000000000000..117f58c65a46
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_ECC_H
+#define __MCP25XXFD_ECC_H
+
+#include "mcp25xxfd_priv.h"
+
+int mcp25xxfd_ecc_clear_int(struct mcp25xxfd_priv *priv);
+int mcp25xxfd_ecc_enable_int(struct mcp25xxfd_priv *priv, bool enable);
+int mcp25xxfd_ecc_enable(struct mcp25xxfd_priv *priv);
+
+#endif /* __MCP25XXFD_ECC_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c
new file mode 100644
index 000000000000..60dc9f98d892
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ *
+ * Based on Microchip MCP251x CAN controller driver written by
+ * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
+ */
+
+#include <linux/gpio/driver.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "mcp25xxfd_clock.h"
+#include "mcp25xxfd_cmd.h"
+#include "mcp25xxfd_gpio.h"
+#include "mcp25xxfd_priv.h"
+
+/* GPIO component */
+#ifdef CONFIG_GPIOLIB
+
+enum mcp25xxfd_gpio_pins {
+	MCP25XXFD_GPIO_GPIO0 = 0,
+	MCP25XXFD_GPIO_GPIO1 = 1,
+};
+
+static int mcp25xxfd_gpio_request(struct gpio_chip *chip,
+				  unsigned int offset)
+{
+	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
+	int clock_requestor = offset ?
+		MCP25XXFD_CLK_USER_GPIO1 : MCP25XXFD_CLK_USER_GPIO0;
+
+	/* only handle gpio 0/1 */
+	if (offset > 1)
+		return -EINVAL;
+
+	/* if we have XSTANDBY enabled then gpio0 is not available either */
+	if (priv->config.gpio0_xstandby && offset == 0)
+		return -EINVAL;
+
+	mcp25xxfd_clock_start(priv, clock_requestor);
+
+	return 0;
+}
+
+static void mcp25xxfd_gpio_free(struct gpio_chip *chip,
+				unsigned int offset)
+{
+	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
+	int clock_requestor = offset ?
+		MCP25XXFD_CLK_USER_GPIO1 : MCP25XXFD_CLK_USER_GPIO0;
+
+	/* only handle gpio 0/1 */
+	if (offset > 1)
+		return;
+
+	mcp25xxfd_clock_stop(priv, clock_requestor);
+}
+
+static int mcp25xxfd_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
+	u32 mask = (offset) ? MCP25XXFD_IOCON_GPIO1 : MCP25XXFD_IOCON_GPIO0;
+	int ret;
+
+	/* only handle gpio 0/1 */
+	if (offset > 1)
+		return -EINVAL;
+
+	/* read the relevant gpio Latch */
+	ret = mcp25xxfd_cmd_read_mask(priv->spi, MCP25XXFD_IOCON,
+				      &priv->regs.iocon, mask);
+	if (ret)
+		return ret;
+
+	/* return the match */
+	return priv->regs.iocon & mask;
+}
+
+static void mcp25xxfd_gpio_set(struct gpio_chip *chip, unsigned int offset,
+			       int value)
+{
+	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
+	u32 mask = (offset) ? MCP25XXFD_IOCON_LAT1 : MCP25XXFD_IOCON_LAT0;
+
+	/* only handle gpio 0/1 */
+	if (offset > 1)
+		return;
+
+	/* update in memory representation with the corresponding value */
+	if (value)
+		priv->regs.iocon |= mask;
+	else
+		priv->regs.iocon &= ~mask;
+
+	mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_IOCON,
+				 priv->regs.iocon, mask);
+}
+
+static int mcp25xxfd_gpio_direction_input(struct gpio_chip *chip,
+					  unsigned int offset)
+{
+	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
+	u32 mask_tri = (offset) ?
+		MCP25XXFD_IOCON_TRIS1 : MCP25XXFD_IOCON_TRIS0;
+	u32 mask_stby = (offset) ?
+		0 : MCP25XXFD_IOCON_XSTBYEN;
+	u32 mask_pm = (offset) ?
+		MCP25XXFD_IOCON_PM1 : MCP25XXFD_IOCON_PM0;
+
+	/* only handle gpio 0/1 */
+	if (offset > 1)
+		return -EINVAL;
+
+	/* set the mask */
+	priv->regs.iocon |= mask_tri | mask_pm;
+
+	/* clear stby */
+	priv->regs.iocon &= ~mask_stby;
+
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_IOCON,
+					priv->regs.iocon,
+					mask_tri | mask_stby | mask_pm);
+}
+
+static int mcp25xxfd_gpio_direction_output(struct gpio_chip *chip,
+					   unsigned int offset, int value)
+{
+	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
+	u32 mask_tri = (offset) ?
+		MCP25XXFD_IOCON_TRIS1 : MCP25XXFD_IOCON_TRIS0;
+	u32 mask_lat = (offset) ?
+		MCP25XXFD_IOCON_LAT1 : MCP25XXFD_IOCON_LAT0;
+	u32 mask_pm = (offset) ?
+		MCP25XXFD_IOCON_PM1 : MCP25XXFD_IOCON_PM0;
+	u32 mask_stby = (offset) ?
+		0 : MCP25XXFD_IOCON_XSTBYEN;
+
+	/* only handle gpio 0/1 */
+	if (offset > 1)
+		return -EINVAL;
+
+	/* clear the tristate bit and also clear stby */
+	priv->regs.iocon &= ~(mask_tri | mask_stby);
+
+	/* set GPIO mode */
+	priv->regs.iocon |= mask_pm;
+
+	/* set the value */
+	if (value)
+		priv->regs.iocon |= mask_lat;
+	else
+		priv->regs.iocon &= ~mask_lat;
+
+	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_IOCON,
+					priv->regs.iocon,
+					mask_tri | mask_lat |
+					mask_pm | mask_stby);
+}
+
+#ifdef CONFIG_OF_DYNAMIC
+static void mcp25xxfd_gpio_read_of(struct mcp25xxfd_priv *priv)
+{
+	const struct device_node *np = priv->spi->dev.of_node;
+
+	priv->config.gpio_open_drain =
+		of_property_read_bool(np, "microchip,gpio-open-drain");
+	priv->config.gpio0_xstandby =
+		of_property_read_bool(np, "microchip,gpio0-xstandby");
+}
+#else
+static void mcp25xxfd_gpio_read_of(struct mcp25xxfd_priv *priv)
+{
+	priv->config.gpio_open_drain = false;
+	priv->config.gpio0_xstandby = false;
+}
+#endif
+
+static int mcp25xxfd_gpio_setup_regs(struct mcp25xxfd_priv *priv)
+{
+	/* handle open-drain */
+	if (priv->config.gpio_open_drain) {
+		priv->regs.iocon |= MCP25XXFD_IOCON_INTOD;
+	} else {
+		priv->regs.iocon &= ~MCP25XXFD_IOCON_INTOD;
+	}
+
+	/* handle xstandby */
+	if (priv->config.gpio0_xstandby) {
+		priv->regs.iocon &= ~(MCP25XXFD_IOCON_TRIS0 |
+				      MCP25XXFD_IOCON_GPIO0);
+		priv->regs.iocon |= MCP25XXFD_IOCON_XSTBYEN;
+	} else {
+		priv->regs.iocon &= ~(MCP25XXFD_IOCON_XSTBYEN);
+	}
+
+	/* update the iocon register */
+	return mcp25xxfd_cmd_write_regs(priv->spi, MCP25XXFD_IOCON,
+					&priv->regs.iocon, sizeof(u32));
+}
+
+static int mcp25xxfd_gpio_setup_gpiochip(struct mcp25xxfd_priv *priv)
+{
+	struct gpio_chip *gpio = &priv->gpio;
+
+	/* gpiochip only handles GPIO0 and GPIO1 */
+	gpio->owner                = THIS_MODULE;
+	gpio->parent               = &priv->spi->dev;
+	gpio->label                = dev_name(&priv->spi->dev);
+	gpio->direction_input      = mcp25xxfd_gpio_direction_input;
+	gpio->get                  = mcp25xxfd_gpio_get;
+	gpio->direction_output     = mcp25xxfd_gpio_direction_output;
+	gpio->set                  = mcp25xxfd_gpio_set;
+	gpio->request              = mcp25xxfd_gpio_request;
+	gpio->free                 = mcp25xxfd_gpio_free;
+	gpio->base                 = -1;
+	gpio->ngpio                = 2;
+	gpio->can_sleep            = 1;
+
+	return gpiochip_add_data(gpio, priv);
+}
+
+int mcp25xxfd_gpio_setup(struct mcp25xxfd_priv *priv)
+{
+	int ret;
+
+	/* setting up defaults */
+	priv->config.gpio0_xstandby = false;
+
+	mcp25xxfd_gpio_read_of(priv);
+	ret = mcp25xxfd_gpio_setup_regs(priv);
+	if (ret)
+		return ret;
+
+	return mcp25xxfd_gpio_setup_gpiochip(priv);
+}
+
+void mcp25xxfd_gpio_remove(struct mcp25xxfd_priv *priv)
+{
+	gpiochip_remove(&priv->gpio);
+}
+
+#else
+int mcp25xxfd_gpio_setup(struct mcp25xxfd_priv *priv)
+{
+	return 0;
+}
+
+void mcp25xxfd_gpio_remove(struct mcp25xxfd_priv *priv)
+{
+}
+#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h
new file mode 100644
index 000000000000..46740e8abc45
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_GPIO_H
+#define __MCP25XXFD_GPIO_H
+
+#include "mcp25xxfd_priv.h"
+
+/* gpiolib support */
+int mcp25xxfd_gpio_setup(struct mcp25xxfd_priv *priv);
+void mcp25xxfd_gpio_remove(struct mcp25xxfd_priv *priv);
+
+#endif /* __MCP25XXFD_GPIO_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c
new file mode 100644
index 000000000000..cca9c996b542
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_can_int.h"
+#include "mcp25xxfd_crc.h"
+#include "mcp25xxfd_ecc.h"
+#include "mcp25xxfd_int.h"
+#include "mcp25xxfd_priv.h"
+
+int mcp25xxfd_int_clear(struct mcp25xxfd_priv *priv)
+{
+	int ret;
+
+	ret = mcp25xxfd_ecc_clear_int(priv);
+	if (ret)
+		return ret;
+	ret = mcp25xxfd_crc_clear_int(priv);
+	if (ret)
+		return ret;
+	ret = mcp25xxfd_can_int_clear(priv);
+
+	return ret;
+}
+
+int mcp25xxfd_int_enable(struct mcp25xxfd_priv *priv, bool enable)
+{
+	/* error handling only on enable for this function */
+	int ret = 0;
+
+	/* if we enable clear interrupt flags first */
+	if (enable) {
+		ret = mcp25xxfd_int_clear(priv);
+		if (ret)
+			goto out;
+	}
+
+	ret = mcp25xxfd_crc_enable_int(priv, enable);
+	if (ret)
+		goto out;
+
+	ret = mcp25xxfd_ecc_enable(priv);
+	if (ret)
+		goto out_crc;
+
+	ret = mcp25xxfd_ecc_enable_int(priv, enable);
+	if (ret)
+		goto out_crc;
+
+	ret = mcp25xxfd_can_int_enable(priv, enable);
+	if (ret)
+		goto out_ecc;
+
+	/* if we disable interrupts clear interrupt flags last */
+	if (!enable)
+		mcp25xxfd_int_clear(priv);
+
+	return 0;
+
+out_ecc:
+	mcp25xxfd_ecc_enable_int(priv, false);
+
+out_crc:
+	mcp25xxfd_crc_enable_int(priv, false);
+out:
+	return ret;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h
new file mode 100644
index 000000000000..4daf0182d1af
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_INT_H
+#define __MCP25XXFD_INT_H
+
+#include "mcp25xxfd_priv.h"
+
+int mcp25xxfd_int_clear(struct mcp25xxfd_priv *priv);
+int mcp25xxfd_int_enable(struct mcp25xxfd_priv *priv, bool enable);
+
+#endif /* __MCP25XXFD_INT_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h
new file mode 100644
index 000000000000..89bd39779b28
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+#ifndef __MCP25XXFD_PRIV_H
+#define __MCP25XXFD_PRIV_H
+
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/gpio/driver.h>
+#include <linux/mutex.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd_regs.h"
+
+/* some defines for the driver */
+#define DEVICE_NAME "mcp25xxfd"
+
+enum mcp25xxfd_model {
+	CAN_MCP2517FD	= 0x2517,
+	CAN_MCP2518FD	= 0x2518,
+};
+
+struct mcp25xxfd_can_priv;
+struct mcp25xxfd_priv {
+	struct spi_device *spi;
+	struct clk *clk;
+	struct gpio_chip gpio;
+	struct mcp25xxfd_can_priv *cpriv;
+
+	/* the actual model of the mcp25xxfd */
+	enum mcp25xxfd_model model;
+
+	/* full device name used for debugfs ant interrupts */
+	char device_name[32];
+
+	/* everything clock related */
+	int clock_freq;
+	struct {
+		/* clock configuration */
+		int clock_pll;
+		int clock_div2;
+		int clock_odiv;
+		/* gpio related */
+		bool gpio_open_drain;
+		bool gpio0_xstandby;
+	} config;
+
+	/* lock for enabling/disabling the clock */
+	struct mutex clk_user_lock;
+	u32 clk_user_mask;
+	u32 clk_sleep_mask;
+
+	/* power related */
+	struct regulator *power;
+
+	/* the distinct spi_speeds to use for spi communication */
+	u32 spi_setup_speed_hz;
+	u32 spi_normal_speed_hz;
+	u32 spi_use_speed_hz;
+
+	/* spi-tx/rx buffers for efficient transfers
+	 * used during setup and irq
+	 */
+	struct mutex spi_rxtx_lock; /* protects use of spi_tx/rx */
+	u8 spi_tx[MCP25XXFD_SRAM_SIZE];
+	u8 spi_rx[MCP25XXFD_SRAM_SIZE];
+
+	/* configuration registers */
+	struct {
+		u32 osc;
+		u32 iocon;
+		u32 crc;
+		u32 ecccon;
+	} regs;
+
+	/* debugfs related */
+#if defined(CONFIG_DEBUG_FS)
+	struct dentry *debugfs_dir;
+	struct dentry *debugfs_regs_dir;
+	struct {
+		u64 spi_crc_read;
+		u64 spi_crc_read_split;
+	} stats;
+#endif
+};
+
+#endif /* __MCP25XXFD_PRIV_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h
new file mode 100644
index 000000000000..f8495e0325c2
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h
@@ -0,0 +1,681 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+ *
+ * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef __MCP25XXFD_REGS_H
+#define __MCP25XXFD_REGS_H
+
+#include <linux/bitops.h>
+
+/* some constants derived from the datasheets */
+#define MCP25XXFD_OST_DELAY_MS		3
+#define MCP25XXFD_MIN_CLOCK_FREQUENCY	1000000
+#define MCP25XXFD_MAX_CLOCK_FREQUENCY	40000000
+#define MCP25XXFD_PLL_MULTIPLIER	10
+#define MCP25XXFD_AUTO_PLL_MAX_CLOCK_FREQUENCY				\
+	(MCP25XXFD_MAX_CLOCK_FREQUENCY / MCP25XXFD_PLL_MULTIPLIER)
+#define MCP25XXFD_SCLK_DIVIDER		2
+
+/* GPIO, clock, ecc related register definitions of Controller itself */
+#define MCP25XXFD_SFR_BASE(x)			(0xE00 + (x))
+#define MCP25XXFD_OSC				MCP25XXFD_SFR_BASE(0x00)
+#  define MCP25XXFD_OSC_PLLEN			BIT(0)
+#  define MCP25XXFD_OSC_OSCDIS			BIT(2)
+#  define MCP25XXFD_OSC_SCLKDIV			BIT(4)
+#  define MCP25XXFD_OSC_CLKODIV_BITS		2
+#  define MCP25XXFD_OSC_CLKODIV_SHIFT		5
+#  define MCP25XXFD_OSC_CLKODIV_MASK					\
+	GENMASK(MCP25XXFD_OSC_CLKODIV_SHIFT				\
+		+ MCP25XXFD_OSC_CLKODIV_BITS - 1,			\
+		MCP25XXFD_OSC_CLKODIV_SHIFT)
+#  define MCP25XXFD_OSC_CLKODIV_10		3
+#  define MCP25XXFD_OSC_CLKODIV_4		2
+#  define MCP25XXFD_OSC_CLKODIV_2		1
+#  define MCP25XXFD_OSC_CLKODIV_1		0
+#  define MCP25XXFD_OSC_PLLRDY			BIT(8)
+#  define MCP25XXFD_OSC_OSCRDY			BIT(10)
+#  define MCP25XXFD_OSC_SCLKRDY			BIT(12)
+#define MCP25XXFD_IOCON				MCP25XXFD_SFR_BASE(0x04)
+#  define MCP25XXFD_IOCON_TRIS0			BIT(0)
+#  define MCP25XXFD_IOCON_TRIS1			BIT(1)
+#  define MCP25XXFD_IOCON_XSTBYEN		BIT(6)
+#  define MCP25XXFD_IOCON_LAT0			BIT(8)
+#  define MCP25XXFD_IOCON_LAT1			BIT(9)
+#  define MCP25XXFD_IOCON_GPIO0			BIT(16)
+#  define MCP25XXFD_IOCON_GPIO1			BIT(17)
+#  define MCP25XXFD_IOCON_PM0			BIT(24)
+#  define MCP25XXFD_IOCON_PM1			BIT(25)
+#  define MCP25XXFD_IOCON_TXCANOD		BIT(28)
+#  define MCP25XXFD_IOCON_SOF			BIT(29)
+#  define MCP25XXFD_IOCON_INTOD			BIT(30)
+#define MCP25XXFD_CRC				MCP25XXFD_SFR_BASE(0x08)
+#  define MCP25XXFD_CRC_MASK			GENMASK(15, 0)
+#  define MCP25XXFD_CRC_CRCERRIE		BIT(16)
+#  define MCP25XXFD_CRC_FERRIE			BIT(17)
+#  define MCP25XXFD_CRC_CRCERRIF		BIT(24)
+#  define MCP25XXFD_CRC_FERRIF			BIT(25)
+#define MCP25XXFD_ECCCON			MCP25XXFD_SFR_BASE(0x0C)
+#  define MCP25XXFD_ECCCON_ECCEN		BIT(0)
+#  define MCP25XXFD_ECCCON_SECIE		BIT(1)
+#  define MCP25XXFD_ECCCON_DEDIE		BIT(2)
+#  define MCP25XXFD_ECCCON_PARITY_BITS		6
+#  define MCP25XXFD_ECCCON_PARITY_SHIFT		8
+#  define MCP25XXFD_ECCCON_PARITY_MASK					\
+	GENMASK(MCP25XXFD_ECCCON_PARITY_SHIFT				\
+		+ MCP25XXFD_ECCCON_PARITY_BITS - 1,			\
+		MCP25XXFD_ECCCON_PARITY_SHIFT)
+#define MCP25XXFD_ECCSTAT			MCP25XXFD_SFR_BASE(0x10)
+#  define MCP25XXFD_ECCSTAT_SECIF		BIT(1)
+#  define MCP25XXFD_ECCSTAT_DEDIF		BIT(2)
+#  define MCP25XXFD_ECCSTAT_ERRADDR_SHIFT	8
+#  define MCP25XXFD_ECCSTAT_ERRADDR_MASK				\
+	GENMASK(MCP25XXFD_ECCSTAT_ERRADDR_SHIFT + 11,			\
+		MCP25XXFD_ECCSTAT_ERRADDR_SHIFT)
+
+#define MCP25XXFD_DEVID				MCP25XXFD_SFR_BASE(0x14)
+#  define MCP25XXFD_DEVID_REV_BITS		4
+#  define MCP25XXFD_DEVID_REV_SHIFT		0
+#  define MCP25XXFD_DEVID_REV_MASK					\
+	GENMASK(MCP25XXFD_DEVID_REV_SHIFT +				\
+		MCP25XXFD_DEVID_REV_BITS - 1,				\
+		MCP25XXFD_DEVID_REV_SHIFT)
+#  define MCP25XXFD_DEVID_ID_BITS		4
+#  define MCP25XXFD_DEVID_ID_SHIFT		4
+#  define MCP25XXFD_DEVID_ID_MASK					\
+	GENMASK(MCP25XXFD_DEVID_ID_SHIFT +				\
+		MCP25XXFD_DEVID_ID_BITS - 1,				\
+		MCP25XXFD_DEVID_ID_SHIFT)
+
+/* CAN related register definitions of Controller CAN block */
+#define MCP25XXFD_CAN_SFR_BASE(x)		(0x000 + (x))
+#define MCP25XXFD_CAN_CON						\
+	MCP25XXFD_CAN_SFR_BASE(0x00)
+#  define MCP25XXFD_CAN_CON_DNCNT_BITS		5
+#  define MCP25XXFD_CAN_CON_DNCNT_SHIFT		0
+#  define MCP25XXFD_CAN_CON_DNCNT_MASK					\
+	GENMASK(MCP25XXFD_CAN_CON_DNCNT_SHIFT +				\
+		MCP25XXFD_CAN_CON_DNCNT_BITS - 1,			\
+		MCP25XXFD_CAN_CON_DNCNT_SHIFT)
+#  define MCP25XXFD_CAN_CON_ISOCRCEN		BIT(5)
+#  define MCP25XXFD_CAN_CON_PXEDIS		BIT(6)
+#  define MCP25XXFD_CAN_CON_WAKFIL		BIT(8)
+#  define MCP25XXFD_CAN_CON_WFT_BITS		2
+#  define MCP25XXFD_CAN_CON_WFT_SHIFT		9
+#  define MCP25XXFD_CAN_CON_WFT_MASK					\
+	GENMASK(MCP25XXFD_CAN_CON_WFT_SHIFT +				\
+		MCP25XXFD_CAN_CON_WFT_BITS - 1,				\
+		MCP25XXFD_CAN_CON_WFT_SHIFT)
+#  define MCP25XXFD_CAN_CON_BUSY		BIT(11)
+#  define MCP25XXFD_CAN_CON_BRSDIS		BIT(12)
+#  define MCP25XXFD_CAN_CON_RTXAT		BIT(16)
+#  define MCP25XXFD_CAN_CON_ESIGM		BIT(17)
+#  define MCP25XXFD_CAN_CON_SERR2LOM		BIT(18)
+#  define MCP25XXFD_CAN_CON_STEF		BIT(19)
+#  define MCP25XXFD_CAN_CON_TXQEN		BIT(20)
+#  define MCP25XXFD_CAN_CON_OPMODE_BITS		3
+#  define MCP25XXFD_CAN_CON_OPMOD_SHIFT		21
+#  define MCP25XXFD_CAN_CON_OPMOD_MASK					\
+	GENMASK(MCP25XXFD_CAN_CON_OPMOD_SHIFT +				\
+		MCP25XXFD_CAN_CON_OPMODE_BITS - 1,			\
+		MCP25XXFD_CAN_CON_OPMOD_SHIFT)
+#  define MCP25XXFD_CAN_CON_REQOP_BITS		3
+#  define MCP25XXFD_CAN_CON_REQOP_SHIFT		24
+#  define MCP25XXFD_CAN_CON_REQOP_MASK					\
+	GENMASK(MCP25XXFD_CAN_CON_REQOP_SHIFT +				\
+		MCP25XXFD_CAN_CON_REQOP_BITS - 1,			\
+		MCP25XXFD_CAN_CON_REQOP_SHIFT)
+#    define MCP25XXFD_CAN_CON_MODE_MIXED	0
+#    define MCP25XXFD_CAN_CON_MODE_SLEEP	1
+#    define MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK	2
+#    define MCP25XXFD_CAN_CON_MODE_LISTENONLY	3
+#    define MCP25XXFD_CAN_CON_MODE_CONFIG	4
+#    define MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK	5
+#    define MCP25XXFD_CAN_CON_MODE_CAN2_0	6
+#    define MCP25XXFD_CAN_CON_MODE_RESTRICTED	7
+#  define MCP25XXFD_CAN_CON_ABAT		BIT(27)
+#  define MCP25XXFD_CAN_CON_TXBWS_BITS		3
+#  define MCP25XXFD_CAN_CON_TXBWS_SHIFT		28
+#  define MCP25XXFD_CAN_CON_TXBWS_MASK					\
+	GENMASK(MCP25XXFD_CAN_CON_TXBWS_SHIFT +				\
+		MCP25XXFD_CAN_CON_TXBWS_BITS - 1,			\
+		MCP25XXFD_CAN_CON_TXBWS_SHIFT)
+#  define MCP25XXFD_CAN_CON_DEFAULT					\
+	(MCP25XXFD_CAN_CON_ISOCRCEN |					\
+	 MCP25XXFD_CAN_CON_PXEDIS |					\
+	 MCP25XXFD_CAN_CON_WAKFIL |					\
+	 (3 << MCP25XXFD_CAN_CON_WFT_SHIFT) |				\
+	 MCP25XXFD_CAN_CON_STEF |					\
+	 MCP25XXFD_CAN_CON_TXQEN |					\
+	 (MCP25XXFD_CAN_CON_MODE_CONFIG << MCP25XXFD_CAN_CON_OPMOD_SHIFT) | \
+	 (MCP25XXFD_CAN_CON_MODE_CONFIG << MCP25XXFD_CAN_CON_REQOP_SHIFT))
+#  define MCP25XXFD_CAN_CON_DEFAULT_MASK				\
+	(MCP25XXFD_CAN_CON_DNCNT_MASK |					\
+	 MCP25XXFD_CAN_CON_ISOCRCEN |					\
+	 MCP25XXFD_CAN_CON_PXEDIS |					\
+	 MCP25XXFD_CAN_CON_WAKFIL |					\
+	 MCP25XXFD_CAN_CON_WFT_MASK |					\
+	 MCP25XXFD_CAN_CON_BRSDIS |					\
+	 MCP25XXFD_CAN_CON_RTXAT |					\
+	 MCP25XXFD_CAN_CON_ESIGM |					\
+	 MCP25XXFD_CAN_CON_SERR2LOM |					\
+	 MCP25XXFD_CAN_CON_STEF |					\
+	 MCP25XXFD_CAN_CON_TXQEN |					\
+	 MCP25XXFD_CAN_CON_OPMOD_MASK |					\
+	 MCP25XXFD_CAN_CON_REQOP_MASK |					\
+	 MCP25XXFD_CAN_CON_ABAT |					\
+	 MCP25XXFD_CAN_CON_TXBWS_MASK)
+#define MCP25XXFD_CAN_NBTCFG			MCP25XXFD_CAN_SFR_BASE(0x04)
+#  define MCP25XXFD_CAN_NBTCFG_SJW_BITS		7
+#  define MCP25XXFD_CAN_NBTCFG_SJW_SHIFT	0
+#  define MCP25XXFD_CAN_NBTCFG_SJW_MASK					\
+	GENMASK(MCP25XXFD_CAN_NBTCFG_SJW_SHIFT +			\
+		MCP25XXFD_CAN_NBTCFG_SJW_BITS - 1,			\
+		MCP25XXFD_CAN_NBTCFG_SJW_SHIFT)
+#  define MCP25XXFD_CAN_NBTCFG_TSEG2_BITS	7
+#  define MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT	8
+#  define MCP25XXFD_CAN_NBTCFG_TSEG2_MASK				\
+	GENMASK(MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT +			\
+		MCP25XXFD_CAN_NBTCFG_TSEG2_BITS - 1,			\
+		MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT)
+#  define MCP25XXFD_CAN_NBTCFG_TSEG1_BITS	8
+#  define MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT	16
+#  define MCP25XXFD_CAN_NBTCFG_TSEG1_MASK				\
+	GENMASK(MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT +			\
+		MCP25XXFD_CAN_NBTCFG_TSEG1_BITS - 1,			\
+		MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT)
+#  define MCP25XXFD_CAN_NBTCFG_BRP_BITS		8
+#  define MCP25XXFD_CAN_NBTCFG_BRP_SHIFT	24
+#  define MCP25XXFD_CAN_NBTCFG_BRP_MASK					\
+	GENMASK(MCP25XXFD_CAN_NBTCFG_BRP_SHIFT +			\
+		MCP25XXFD_CAN_NBTCFG_BRP_BITS - 1,			\
+		MCP25XXFD_CAN_NBTCFG_BRP_SHIFT)
+#define MCP25XXFD_CAN_DBTCFG			MCP25XXFD_CAN_SFR_BASE(0x08)
+#  define MCP25XXFD_CAN_DBTCFG_SJW_BITS		4
+#  define MCP25XXFD_CAN_DBTCFG_SJW_SHIFT	0
+#  define MCP25XXFD_CAN_DBTCFG_SJW_MASK					\
+	GENMASK(MCP25XXFD_CAN_DBTCFG_SJW_SHIFT +			\
+		MCP25XXFD_CAN_DBTCFG_SJW_BITS - 1,			\
+		MCP25XXFD_CAN_DBTCFG_SJW_SHIFT)
+#  define MCP25XXFD_CAN_DBTCFG_TSEG2_BITS	4
+#  define MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT	8
+#  define MCP25XXFD_CAN_DBTCFG_TSEG2_MASK				\
+	GENMASK(MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT +			\
+		MCP25XXFD_CAN_DBTCFG_TSEG2_BITS - 1,			\
+		MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT)
+#  define MCP25XXFD_CAN_DBTCFG_TSEG1_BITS	5
+#  define MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT	16
+#  define MCP25XXFD_CAN_DBTCFG_TSEG1_MASK				\
+	GENMASK(MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT +			\
+		MCP25XXFD_CAN_DBTCFG_TSEG1_BITS - 1,			\
+		MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT)
+#  define MCP25XXFD_CAN_DBTCFG_BRP_BITS		8
+#  define MCP25XXFD_CAN_DBTCFG_BRP_SHIFT	24
+#  define MCP25XXFD_CAN_DBTCFG_BRP_MASK					\
+	GENMASK(MCP25XXFD_CAN_DBTCFG_BRP_SHIFT +			\
+		MCP25XXFD_CAN_DBTCFG_BRP_BITS - 1,			\
+		MCP25XXFD_CAN_DBTCFG_BRP_SHIFT)
+#define MCP25XXFD_CAN_TDC			MCP25XXFD_CAN_SFR_BASE(0x0C)
+#  define MCP25XXFD_CAN_TDC_TDCV_BITS		5
+#  define MCP25XXFD_CAN_TDC_TDCV_SHIFT		0
+#  define MCP25XXFD_CAN_TDC_TDCV_MASK					\
+	GENMASK(MCP25XXFD_CAN_TDC_TDCV_SHIFT +				\
+		MCP25XXFD_CAN_TDC_TDCV_BITS - 1,			\
+		MCP25XXFD_CAN_TDC_TDCV_SHIFT)
+#  define MCP25XXFD_CAN_TDC_TDCO_BITS		5
+#  define MCP25XXFD_CAN_TDC_TDCO_SHIFT		8
+#  define MCP25XXFD_CAN_TDC_TDCO_MASK					\
+	GENMASK(MCP25XXFD_CAN_TDC_TDCO_SHIFT +				\
+		MCP25XXFD_CAN_TDC_TDCO_BITS - 1,			\
+		MCP25XXFD_CAN_TDC_TDCO_SHIFT)
+#  define MCP25XXFD_CAN_TDC_TDCMOD_BITS		2
+#  define MCP25XXFD_CAN_TDC_TDCMOD_SHIFT	16
+#  define MCP25XXFD_CAN_TDC_TDCMOD_MASK					\
+	GENMASK(MCP25XXFD_CAN_TDC_TDCMOD_SHIFT +			\
+		MCP25XXFD_CAN_TDC_TDCMOD_BITS - 1,			\
+		MCP25XXFD_CAN_TDC_TDCMOD_SHIFT)
+#  define MCP25XXFD_CAN_TDC_TDCMOD_DISABLED	0
+#  define MCP25XXFD_CAN_TDC_TDCMOD_MANUAL	1
+#  define MCP25XXFD_CAN_TDC_TDCMOD_AUTO		2
+#  define MCP25XXFD_CAN_TDC_SID11EN		BIT(24)
+#  define MCP25XXFD_CAN_TDC_EDGFLTEN		BIT(25)
+#define MCP25XXFD_CAN_TBC			MCP25XXFD_CAN_SFR_BASE(0x10)
+#define MCP25XXFD_CAN_TSCON			MCP25XXFD_CAN_SFR_BASE(0x14)
+#  define MCP25XXFD_CAN_TSCON_TBCPRE_BITS	10
+#  define MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT	0
+#  define MCP25XXFD_CAN_TSCON_TBCPRE_MASK				\
+	GENMASK(MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT +			\
+		MCP25XXFD_CAN_TSCON_TBCPRE_BITS - 1,			\
+		MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT)
+#  define MCP25XXFD_CAN_TSCON_TBCEN		BIT(16)
+#  define MCP25XXFD_CAN_TSCON_TSEOF		BIT(17)
+#  define MCP25XXFD_CAN_TSCON_TSRES		BIT(18)
+#define MCP25XXFD_CAN_VEC			MCP25XXFD_CAN_SFR_BASE(0x18)
+#  define MCP25XXFD_CAN_VEC_ICODE_BITS		7
+#  define MCP25XXFD_CAN_VEC_ICODE_SHIFT		0
+#  define MCP25XXFD_CAN_VEC_ICODE_MASK					\
+	GENMASK(MCP25XXFD_CAN_VEC_ICODE_SHIFT +				\
+		MCP25XXFD_CAN_VEC_ICODE_BITS - 1,			\
+		MCP25XXFD_CAN_VEC_ICODE_SHIFT)
+#  define MCP25XXFD_CAN_VEC_FILHIT_BITS		5
+#  define MCP25XXFD_CAN_VEC_FILHIT_SHIFT	8
+#  define MCP25XXFD_CAN_VEC_FILHIT_MASK					\
+	GENMASK(MCP25XXFD_CAN_VEC_FILHIT_SHIFT +			\
+		MCP25XXFD_CAN_VEC_FILHIT_BITS - 1,			\
+		MCP25XXFD_CAN_VEC_FILHIT_SHIFT)
+#  define MCP25XXFD_CAN_VEC_TXCODE_BITS		7
+#  define MCP25XXFD_CAN_VEC_TXCODE_SHIFT	16
+#  define MCP25XXFD_CAN_VEC_TXCODE_MASK					\
+	GENMASK(MCP25XXFD_CAN_VEC_TXCODE_SHIFT +			\
+		MCP25XXFD_CAN_VEC_TXCODE_BITS - 1,			\
+		MCP25XXFD_CAN_VEC_TXCODE_SHIFT)
+#  define MCP25XXFD_CAN_VEC_RXCODE_BITS		7
+#  define MCP25XXFD_CAN_VEC_RXCODE_SHIFT	24
+#  define MCP25XXFD_CAN_VEC_RXCODE_MASK					\
+	GENMASK(MCP25XXFD_CAN_VEC_RXCODE_SHIFT +			\
+		MCP25XXFD_CAN_VEC_RXCODE_BITS - 1,			\
+		MCP25XXFD_CAN_VEC_RXCODE_SHIFT)
+#define MCP25XXFD_CAN_INT			MCP25XXFD_CAN_SFR_BASE(0x1C)
+#  define MCP25XXFD_CAN_INT_IF_SHIFT		0
+#  define MCP25XXFD_CAN_INT_TXIF		BIT(0)
+#  define MCP25XXFD_CAN_INT_RXIF		BIT(1)
+#  define MCP25XXFD_CAN_INT_TBCIF		BIT(2)
+#  define MCP25XXFD_CAN_INT_MODIF		BIT(3)
+#  define MCP25XXFD_CAN_INT_TEFIF		BIT(4)
+#  define MCP25XXFD_CAN_INT_ECCIF		BIT(8)
+#  define MCP25XXFD_CAN_INT_SPICRCIF		BIT(9)
+#  define MCP25XXFD_CAN_INT_TXATIF		BIT(10)
+#  define MCP25XXFD_CAN_INT_RXOVIF		BIT(11)
+#  define MCP25XXFD_CAN_INT_SERRIF		BIT(12)
+#  define MCP25XXFD_CAN_INT_CERRIF		BIT(13)
+#  define MCP25XXFD_CAN_INT_WAKIF		BIT(14)
+#  define MCP25XXFD_CAN_INT_IVMIF		BIT(15)
+#  define MCP25XXFD_CAN_INT_IF_MASK					\
+	(MCP25XXFD_CAN_INT_TXIF |					\
+	 MCP25XXFD_CAN_INT_RXIF |					\
+	 MCP25XXFD_CAN_INT_TBCIF |					\
+	 MCP25XXFD_CAN_INT_MODIF |					\
+	 MCP25XXFD_CAN_INT_TEFIF |					\
+	 MCP25XXFD_CAN_INT_ECCIF |					\
+	 MCP25XXFD_CAN_INT_SPICRCIF |					\
+	 MCP25XXFD_CAN_INT_TXATIF |					\
+	 MCP25XXFD_CAN_INT_RXOVIF |					\
+	 MCP25XXFD_CAN_INT_CERRIF |					\
+	 MCP25XXFD_CAN_INT_SERRIF |					\
+	 MCP25XXFD_CAN_INT_WAKIF |					\
+	 MCP25XXFD_CAN_INT_IVMIF)
+#  define MCP25XXFD_CAN_INT_IF_CLEAR_MASK				\
+	(MCP25XXFD_CAN_INT_TBCIF  |					\
+	 MCP25XXFD_CAN_INT_MODIF  |					\
+	 MCP25XXFD_CAN_INT_CERRIF |					\
+	 MCP25XXFD_CAN_INT_SERRIF |					\
+	 MCP25XXFD_CAN_INT_WAKIF |					\
+	 MCP25XXFD_CAN_INT_IVMIF)
+#  define MCP25XXFD_CAN_INT_IE_SHIFT		16
+#  define MCP25XXFD_CAN_INT_TXIE					\
+	(MCP25XXFD_CAN_INT_TXIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_RXIE					\
+	(MCP25XXFD_CAN_INT_RXIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_TBCIE					\
+	(MCP25XXFD_CAN_INT_TBCIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_MODIE					\
+	(MCP25XXFD_CAN_INT_MODIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_TEFIE					\
+	(MCP25XXFD_CAN_INT_TEFIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_ECCIE					\
+	(MCP25XXFD_CAN_INT_ECCIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_SPICRCIE					\
+	(MCP25XXFD_CAN_INT_SPICRCIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_TXATIE					\
+	(MCP25XXFD_CAN_INT_TXATIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_RXOVIE					\
+	(MCP25XXFD_CAN_INT_RXOVIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_CERRIE					\
+	(MCP25XXFD_CAN_INT_CERRIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_SERRIE					\
+	(MCP25XXFD_CAN_INT_SERRIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_WAKIE					\
+	(MCP25XXFD_CAN_INT_WAKIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_IVMIE					\
+	(MCP25XXFD_CAN_INT_IVMIF << MCP25XXFD_CAN_INT_IE_SHIFT)
+#  define MCP25XXFD_CAN_INT_IE_MASK					\
+	(MCP25XXFD_CAN_INT_TXIE |					\
+	 MCP25XXFD_CAN_INT_RXIE |					\
+	 MCP25XXFD_CAN_INT_TBCIE |					\
+	 MCP25XXFD_CAN_INT_MODIE |					\
+	 MCP25XXFD_CAN_INT_TEFIE |					\
+	 MCP25XXFD_CAN_INT_ECCIE |					\
+	 MCP25XXFD_CAN_INT_SPICRCIE |					\
+	 MCP25XXFD_CAN_INT_TXATIE |					\
+	 MCP25XXFD_CAN_INT_RXOVIE |					\
+	 MCP25XXFD_CAN_INT_CERRIE |					\
+	 MCP25XXFD_CAN_INT_SERRIE |					\
+	 MCP25XXFD_CAN_INT_WAKIE |					\
+	 MCP25XXFD_CAN_INT_IVMIE)
+#define MCP25XXFD_CAN_RXIF			MCP25XXFD_CAN_SFR_BASE(0x20)
+#define MCP25XXFD_CAN_TXIF			MCP25XXFD_CAN_SFR_BASE(0x24)
+#define MCP25XXFD_CAN_RXOVIF			MCP25XXFD_CAN_SFR_BASE(0x28)
+#define MCP25XXFD_CAN_TXATIF			MCP25XXFD_CAN_SFR_BASE(0x2C)
+#define MCP25XXFD_CAN_TXREQ			MCP25XXFD_CAN_SFR_BASE(0x30)
+#define MCP25XXFD_CAN_TREC			MCP25XXFD_CAN_SFR_BASE(0x34)
+#  define MCP25XXFD_CAN_TREC_REC_BITS		8
+#  define MCP25XXFD_CAN_TREC_REC_SHIFT		0
+#  define MCP25XXFD_CAN_TREC_REC_MASK					\
+	GENMASK(MCP25XXFD_CAN_TREC_REC_SHIFT +				\
+		MCP25XXFD_CAN_TREC_REC_BITS - 1,			\
+		MCP25XXFD_CAN_TREC_REC_SHIFT)
+#  define MCP25XXFD_CAN_TREC_TEC_BITS		8
+#  define MCP25XXFD_CAN_TREC_TEC_SHIFT		8
+#  define MCP25XXFD_CAN_TREC_TEC_MASK					\
+	GENMASK(MCP25XXFD_CAN_TREC_TEC_SHIFT +				\
+		MCP25XXFD_CAN_TREC_TEC_BITS - 1,			\
+		MCP25XXFD_CAN_TREC_TEC_SHIFT)
+#  define MCP25XXFD_CAN_TREC_EWARN		BIT(16)
+#  define MCP25XXFD_CAN_TREC_RXWARN		BIT(17)
+#  define MCP25XXFD_CAN_TREC_TXWARN		BIT(18)
+#  define MCP25XXFD_CAN_TREC_RXBP		BIT(19)
+#  define MCP25XXFD_CAN_TREC_TXBP		BIT(20)
+#  define MCP25XXFD_CAN_TREC_TXBO		BIT(21)
+#define MCP25XXFD_CAN_BDIAG0			MCP25XXFD_CAN_SFR_BASE(0x38)
+#  define MCP25XXFD_CAN_BDIAG0_NRERRCNT_BITS	8
+#  define MCP25XXFD_CAN_BDIAG0_NRERRCNT_SHIFT	0
+#  define MCP25XXFD_CAN_BDIAG0_NRERRCNT_MASK				\
+	GENMASK(MCP25XXFD_CAN_BDIAG0_NRERRCNT_SHIFT +			\
+		MCP25XXFD_CAN_BDIAG0_NRERRCNT_BITS - 1,			\
+		MCP25XXFD_CAN_BDIAG0_NRERRCNT_SHIFT)
+#  define MCP25XXFD_CAN_BDIAG0_NTERRCNT_BITS	8
+#  define MCP25XXFD_CAN_BDIAG0_NTERRCNT_SHIFT	8
+#  define MCP25XXFD_CAN_BDIAG0_NTERRCNT_MASK				\
+	GENMASK(MCP25XXFD_CAN_BDIAG0_NTERRCNT_SHIFT +			\
+		MCP25XXFD_CAN_BDIAG0_NTERRCNT_BITS - 1,			\
+		MCP25XXFD_CAN_BDIAG0_NTERRCNT_SHIFT)
+#  define MCP25XXFD_CAN_BDIAG0_DRERRCNT_BITS	8
+#  define MCP25XXFD_CAN_BDIAG0_DRERRCNT_SHIFT	16
+#  define MCP25XXFD_CAN_BDIAG0_DRERRCNT_MASK				\
+	GENMASK(MCP25XXFD_CAN_BDIAG0_DRERRCNT_SHIFT +			\
+		MCP25XXFD_CAN_BDIAG0_DRERRCNT_BITS - 1,			\
+		MCP25XXFD_CAN_BDIAG0_DRERRCNT_SHIFT)
+#  define MCP25XXFD_CAN_BDIAG0_DTERRCNT_BITS	8
+#  define MCP25XXFD_CAN_BDIAG0_DTERRCNT_SHIFT	24
+#  define MCP25XXFD_CAN_BDIAG0_DTERRCNT_MASK				\
+	GENMASK(MCP25XXFD_CAN_BDIAG0_DTERRCNT_SHIFT +			\
+		MCP25XXFD_CAN_BDIAG0_DTERRCNT_BITS - 1,			\
+		MCP25XXFD_CAN_BDIAG0_DTERRCNT_SHIFT)
+#define MCP25XXFD_CAN_BDIAG1			MCP25XXFD_CAN_SFR_BASE(0x3C)
+#  define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_BITS	16
+#  define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_SHIFT	0
+#  define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_MASK				\
+	GENMASK(MCP25XXFD_CAN_BDIAG1_EFMSGCNT_SHIFT +			\
+		MCP25XXFD_CAN_BDIAG1_EFMSGCNT_BITS - 1,			\
+		MCP25XXFD_CAN_BDIAG1_EFMSGCNT_SHIFT)
+#  define MCP25XXFD_CAN_BDIAG1_NBIT0ERR		BIT(16)
+#  define MCP25XXFD_CAN_BDIAG1_NBIT1ERR		BIT(17)
+#  define MCP25XXFD_CAN_BDIAG1_NACKERR		BIT(18)
+#  define MCP25XXFD_CAN_BDIAG1_NSTUFERR		BIT(19)
+#  define MCP25XXFD_CAN_BDIAG1_NFORMERR		BIT(20)
+#  define MCP25XXFD_CAN_BDIAG1_NCRCERR		BIT(21)
+#  define MCP25XXFD_CAN_BDIAG1_TXBOERR		BIT(23)
+#  define MCP25XXFD_CAN_BDIAG1_DBIT0ERR		BIT(24)
+#  define MCP25XXFD_CAN_BDIAG1_DBIT1ERR		BIT(25)
+#  define MCP25XXFD_CAN_BDIAG1_DFORMERR		BIT(27)
+#  define MCP25XXFD_CAN_BDIAG1_DSTUFERR		BIT(28)
+#  define MCP25XXFD_CAN_BDIAG1_DCRCERR		BIT(29)
+#  define MCP25XXFD_CAN_BDIAG1_ESI		BIT(30)
+#  define MCP25XXFD_CAN_BDIAG1_DLCMM		BIT(31)
+#define MCP25XXFD_CAN_TEFCON			MCP25XXFD_CAN_SFR_BASE(0x40)
+#  define MCP25XXFD_CAN_TEFCON_TEFNEIE		BIT(0)
+#  define MCP25XXFD_CAN_TEFCON_TEFHIE		BIT(1)
+#  define MCP25XXFD_CAN_TEFCON_TEFFIE		BIT(2)
+#  define MCP25XXFD_CAN_TEFCON_TEFOVIE		BIT(3)
+#  define MCP25XXFD_CAN_TEFCON_TEFTSEN		BIT(5)
+#  define MCP25XXFD_CAN_TEFCON_UINC		BIT(8)
+#  define MCP25XXFD_CAN_TEFCON_FRESET		BIT(10)
+#  define MCP25XXFD_CAN_TEFCON_FSIZE_BITS	5
+#  define MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT	24
+#  define MCP25XXFD_CAN_TEFCON_FSIZE_MASK				\
+	GENMASK(MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT +			\
+		MCP25XXFD_CAN_TEFCON_FSIZE_BITS - 1,			\
+		MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT)
+#define MCP25XXFD_CAN_TEFSTA			MCP25XXFD_CAN_SFR_BASE(0x44)
+#  define MCP25XXFD_CAN_TEFSTA_TEFNEIF		BIT(0)
+#  define MCP25XXFD_CAN_TEFSTA_TEFHIF		BIT(1)
+#  define MCP25XXFD_CAN_TEFSTA_TEFFIF		BIT(2)
+#  define MCP25XXFD_CAN_TEFSTA_TEVOVIF		BIT(3)
+#define MCP25XXFD_CAN_TEFUA			MCP25XXFD_CAN_SFR_BASE(0x48)
+#define MCP25XXFD_CAN_RESERVED			MCP25XXFD_CAN_SFR_BASE(0x4C)
+#define MCP25XXFD_CAN_TXQCON			MCP25XXFD_CAN_SFR_BASE(0x50)
+#  define MCP25XXFD_CAN_TXQCON_TXQNIE		BIT(0)
+#  define MCP25XXFD_CAN_TXQCON_TXQEIE		BIT(2)
+#  define MCP25XXFD_CAN_TXQCON_TXATIE		BIT(4)
+#  define MCP25XXFD_CAN_TXQCON_TXEN		BIT(7)
+#  define MCP25XXFD_CAN_TXQCON_UINC		BIT(8)
+#  define MCP25XXFD_CAN_TXQCON_TXREQ		BIT(9)
+#  define MCP25XXFD_CAN_TXQCON_FRESET		BIT(10)
+#  define MCP25XXFD_CAN_TXQCON_TXPRI_BITS	5
+#  define MCP25XXFD_CAN_TXQCON_TXPRI_SHIFT	16
+#  define MCP25XXFD_CAN_TXQCON_TXPRI_MASK				\
+	GENMASK(MCP25XXFD_CAN_TXQCON_TXPRI_SHIFT +			\
+		MCP25XXFD_CAN_TXQCON_TXPRI_BITS - 1,			\
+		MCP25XXFD_CAN_TXQCON_TXPRI_SHIFT)
+#  define MCP25XXFD_CAN_TXQCON_TXAT_BITS	2
+#  define MCP25XXFD_CAN_TXQCON_TXAT_SHIFT	21
+#  define MCP25XXFD_CAN_TXQCON_TXAT_MASK				\
+	GENMASK(MCP25XXFD_CAN_TXQCON_TXAT_SHIFT +			\
+		#MCP25XXFD_CAN_TXQCON_TXAT_BITS - 1,			\
+		MCP25XXFD_CAN_TXQCON_TXAT_SHIFT)
+#  define MCP25XXFD_CAN_TXQCON_FSIZE_BITS	5
+#  define MCP25XXFD_CAN_TXQCON_FSIZE_SHIFT	24
+#  define MCP25XXFD_CAN_TXQCON_FSIZE_MASK				\
+	GENMASK(MCP25XXFD_CAN_TXQCON_FSIZE_SHIFT +			\
+		MCP25XXFD_CAN_TXQCON_FSIZE_BITS - 1,			\
+		MCP25XXFD_CAN_TXQCON_FSIZE_SHIFT)
+#  define MCP25XXFD_CAN_TXQCON_PLSIZE_BITS	3
+#  define MCP25XXFD_CAN_TXQCON_PLSIZE_SHIFT	29
+#  define MCP25XXFD_CAN_TXQCON_PLSIZE_MASK				\
+	GENMASK(MCP25XXFD_CAN_TXQCON_PLSIZE_SHIFT +			\
+		MCP25XXFD_CAN_TXQCON_PLSIZE_BITS - 1,			\
+		MCP25XXFD_CAN_TXQCON_PLSIZE_SHIFT)
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_8	0
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_12	1
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_16	2
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_20	3
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_24	4
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_32	5
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_48	6
+#    define MCP25XXFD_CAN_TXQCON_PLSIZE_64	7
+
+#define MCP25XXFD_CAN_TXQSTA			MCP25XXFD_CAN_SFR_BASE(0x54)
+#  define MCP25XXFD_CAN_TXQSTA_TXQNIF		BIT(0)
+#  define MCP25XXFD_CAN_TXQSTA_TXQEIF		BIT(2)
+#  define MCP25XXFD_CAN_TXQSTA_TXATIF		BIT(4)
+#  define MCP25XXFD_CAN_TXQSTA_TXERR		BIT(5)
+#  define MCP25XXFD_CAN_TXQSTA_TXLARB		BIT(6)
+#  define MCP25XXFD_CAN_TXQSTA_TXABT		BIT(7)
+#  define MCP25XXFD_CAN_TXQSTA_TXQCI_BITS	5
+#  define MCP25XXFD_CAN_TXQSTA_TXQCI_SHIFT	8
+#  define MCP25XXFD_CAN_TXQSTA_TXQCI_MASK				\
+	GENMASK(MCP25XXFD_CAN_TXQSTA_TXQCI_SHIFT +			\
+		MCP25XXFD_CAN_TXQSTA_TXQCI_BITS - 1,			\
+		MCP25XXFD_CAN_TXQSTA_TXQCI_SHIFT)
+
+#define MCP25XXFD_CAN_TXQUA			MCP25XXFD_CAN_SFR_BASE(0x58)
+#define MCP25XXFD_CAN_FIFOCON(x)					\
+	MCP25XXFD_CAN_SFR_BASE(0x5C + 12 * ((x) - 1))
+#define MCP25XXFD_CAN_FIFOCON_TFNRFNIE		BIT(0)
+#define MCP25XXFD_CAN_FIFOCON_TFHRFHIE		BIT(1)
+#define MCP25XXFD_CAN_FIFOCON_TFERFFIE		BIT(2)
+#define MCP25XXFD_CAN_FIFOCON_RXOVIE		BIT(3)
+#define MCP25XXFD_CAN_FIFOCON_TXATIE		BIT(4)
+#define MCP25XXFD_CAN_FIFOCON_RXTSEN		BIT(5)
+#define MCP25XXFD_CAN_FIFOCON_RTREN		BIT(6)
+#define MCP25XXFD_CAN_FIFOCON_TXEN		BIT(7)
+#define MCP25XXFD_CAN_FIFOCON_UINC		BIT(8)
+#define MCP25XXFD_CAN_FIFOCON_TXREQ		BIT(9)
+#define MCP25XXFD_CAN_FIFOCON_FRESET		BIT(10)
+#  define MCP25XXFD_CAN_FIFOCON_TXPRI_BITS	5
+#  define MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT	16
+#  define MCP25XXFD_CAN_FIFOCON_TXPRI_MASK				\
+	GENMASK(MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT +			\
+		MCP25XXFD_CAN_FIFOCON_TXPRI_BITS - 1,			\
+		MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT)
+#  define MCP25XXFD_CAN_FIFOCON_TXAT_BITS	2
+#  define MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT	21
+#  define MCP25XXFD_CAN_FIFOCON_TXAT_MASK				\
+	GENMASK(MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT +			\
+		MCP25XXFD_CAN_FIFOCON_TXAT_BITS - 1,			\
+		MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT)
+#  define MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT	0
+#  define MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT	1
+#  define MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED	2
+#  define MCP25XXFD_CAN_FIFOCON_FSIZE_BITS	5
+#  define MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT	24
+#  define MCP25XXFD_CAN_FIFOCON_FSIZE_MASK				\
+	GENMASK(MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT +			\
+		MCP25XXFD_CAN_FIFOCON_FSIZE_BITS - 1,			\
+		MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT)
+#  define MCP25XXFD_CAN_FIFOCON_PLSIZE_BITS	3
+#  define MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT	29
+#  define MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK				\
+	GENMASK(MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT +			\
+		MCP25XXFD_CAN_FIFOCON_PLSIZE_BITS - 1,			\
+		MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT)
+#define MCP25XXFD_CAN_FIFOSTA(x)					\
+	MCP25XXFD_CAN_SFR_BASE(0x60 + 12 * ((x) - 1))
+#  define MCP25XXFD_CAN_FIFOSTA_TFNRFNIF	BIT(0)
+#  define MCP25XXFD_CAN_FIFOSTA_TFHRFHIF	BIT(1)
+#  define MCP25XXFD_CAN_FIFOSTA_TFERFFIF	BIT(2)
+#  define MCP25XXFD_CAN_FIFOSTA_RXOVIF		BIT(3)
+#  define MCP25XXFD_CAN_FIFOSTA_TXATIF		BIT(4)
+#  define MCP25XXFD_CAN_FIFOSTA_TXERR		BIT(5)
+#  define MCP25XXFD_CAN_FIFOSTA_TXLARB		BIT(6)
+#  define MCP25XXFD_CAN_FIFOSTA_TXABT		BIT(7)
+#  define MCP25XXFD_CAN_FIFOSTA_FIFOCI_BITS	5
+#  define MCP25XXFD_CAN_FIFOSTA_FIFOCI_SHIFT	8
+#  define MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK				\
+	GENMASK(MCP25XXFD_CAN_FIFOSTA_FIFOCI_SHIFT +			\
+		MCP25XXFD_CAN_FIFOSTA_FIFOCI_BITS - 1,			\
+		MCP25XXFD_CAN_FIFOSTA_FIFOCI_SHIFT)
+#define MCP25XXFD_CAN_FIFOUA(x)						\
+	MCP25XXFD_CAN_SFR_BASE(0x64 + 12 * ((x) - 1))
+#define MCP25XXFD_CAN_FLTCON(x)						\
+	MCP25XXFD_CAN_SFR_BASE(0x1D0 + ((x) & 0x1c))
+#  define MCP25XXFD_CAN_FILCON_SHIFT(x)		(((x) & 3) * 8)
+#  define MCP25XXFD_CAN_FILCON_BITS(x)		MCP25XXFD_CAN_FILCON_BITS_
+#  define MCP25XXFD_CAN_FILCON_BITS_		4
+	/* avoid macro reuse warning, so do not use GENMASK as above */
+#  define MCP25XXFD_CAN_FILCON_MASK(x)					\
+	(GENMASK(MCP25XXFD_CAN_FILCON_BITS_ - 1, 0) <<			\
+	 MCP25XXFD_CAN_FILCON_SHIFT(x))
+#  define MCP25XXFD_CAN_FIFOCON_FLTEN(x)				\
+	BIT(7 + MCP25XXFD_CAN_FILCON_SHIFT(x))
+#define MCP25XXFD_CAN_FLTOBJ(x)						\
+	MCP25XXFD_CAN_SFR_BASE(0x1F0 + 8 * (x))
+#  define MCP25XXFD_CAN_FILOBJ_SID_BITS		11
+#  define MCP25XXFD_CAN_FILOBJ_SID_SHIFT	0
+#  define MCP25XXFD_CAN_FILOBJ_SID_MASK					\
+	GENMASK(MCP25XXFD_CAN_FILOBJ_SID_SHIFT +			\
+		MCP25XXFD_CAN_FILOBJ_SID_BITS - 1,			\
+		MCP25XXFD_CAN_FILOBJ_SID_SHIFT)
+#  define MCP25XXFD_CAN_FILOBJ_EID_BITS		18
+#  define MCP25XXFD_CAN_FILOBJ_EID_SHIFT	12
+#  define MCP25XXFD_CAN_FILOBJ_EID_MASK					\
+	GENMASK(MCP25XXFD_CAN_FILOBJ_EID_SHIFT +			\
+		MCP25XXFD_CAN_FILOBJ_EID_BITS - 1,			\
+		MCP25XXFD_CAN_FILOBJ_EID_SHIFT)
+#  define MCP25XXFD_CAN_FILOBJ_SID11		BIT(29)
+#  define MCP25XXFD_CAN_FILOBJ_EXIDE		BIT(30)
+#define MCP25XXFD_CAN_FLTMASK(x)					\
+	MCP25XXFD_CAN_SFR_BASE(0x1F4 + 8 * (x))
+#  define MCP25XXFD_CAN_FILMASK_MSID_BITS	11
+#  define MCP25XXFD_CAN_FILMASK_MSID_SHIFT	0
+#  define MCP25XXFD_CAN_FILMASK_MSID_MASK				\
+	GENMASK(MCP25XXFD_CAN_FILMASK_MSID_SHIFT +			\
+		MCP25XXFD_CAN_FILMASK_MSID_BITS - 1,			\
+		MCP25XXFD_CAN_FILMASK_MSID_SHIFT)
+#  define MCP25XXFD_CAN_FILMASK_MEID_BITS	18
+#  define MCP25XXFD_CAN_FILMASK_MEID_SHIFT	12
+#  define MCP25XXFD_CAN_FILMASK_MEID_MASK				\
+	GENMASK(MCP25XXFD_CAN_FILMASK_MEID_SHIFT +			\
+		MCP25XXFD_CAN_FILMASK_MEID_BITS - 1,			\
+		MCP25XXFD_CAN_FILMASK_MEID_SHIFT)
+#  define MCP25XXFD_CAN_FILMASK_MSID11		BIT(29)
+#  define MCP25XXFD_CAN_FILMASK_MIDE		BIT(30)
+
+/* the FIFO Objects in SRAM */
+#define MCP25XXFD_SRAM_SIZE 2048
+#define MCP25XXFD_SRAM_ADDR(x) (0x400 + (x))
+
+/* memory structure in sram for tx fifos */
+struct mcp25xxfd_can_obj_tx {
+	u32 id;
+	u32 flags;
+	u8 data[];
+};
+
+/* memory structure in sram for rx fifos */
+struct mcp25xxfd_can_obj_rx {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[];
+};
+
+/* memory structure in sram for tef fifos */
+struct mcp25xxfd_can_obj_tef {
+	u32 id;
+	u32 flags;
+	u32 ts;
+};
+
+#define MCP25XXFD_CAN_OBJ_ID_SID_BITS		11
+#define MCP25XXFD_CAN_OBJ_ID_SID_SHIFT		0
+#define MCP25XXFD_CAN_OBJ_ID_SID_MASK					\
+	GENMASK(MCP25XXFD_CAN_OBJ_ID_SID_SHIFT +			\
+		MCP25XXFD_CAN_OBJ_ID_SID_BITS - 1,			\
+		MCP25XXFD_CAN_OBJ_ID_SID_SHIFT)
+#define MCP25XXFD_CAN_OBJ_ID_EID_BITS		18
+#define MCP25XXFD_CAN_OBJ_ID_EID_SHIFT		11
+#define MCP25XXFD_CAN_OBJ_ID_EID_MASK					\
+	GENMASK(MCP25XXFD_CAN_OBJ_ID_EID_SHIFT +			\
+		MCP25XXFD_CAN_OBJ_ID_EID_BITS - 1,			\
+		MCP25XXFD_CAN_OBJ_ID_EID_SHIFT)
+#define MCP25XXFD_CAN_OBJ_ID_SID_BIT11		BIT(29)
+
+#define MCP25XXFD_CAN_OBJ_FLAGS_DLC_BITS	4
+#define MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT	0
+#define MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK				\
+	GENMASK(MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT +			\
+		MCP25XXFD_CAN_OBJ_FLAGS_DLC_BITS - 1,			\
+		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT)
+#define MCP25XXFD_CAN_OBJ_FLAGS_IDE		BIT(4)
+#define MCP25XXFD_CAN_OBJ_FLAGS_RTR		BIT(5)
+#define MCP25XXFD_CAN_OBJ_FLAGS_BRS		BIT(6)
+#define MCP25XXFD_CAN_OBJ_FLAGS_FDF		BIT(7)
+#define MCP25XXFD_CAN_OBJ_FLAGS_ESI		BIT(8)
+#define MCP25XXFD_CAN_OBJ_FLAGS_SEQ_BITS	7
+#define MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT	9
+#define MCP25XXFD_CAN_OBJ_FLAGS_SEQ_MASK				\
+	GENMASK(MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT +			\
+		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_BITS - 1,			\
+		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT)
+/* the mcp2518 has an extended number of SEQ bits */
+#define MCP25XXFD_CAN_OBJ_FLAGS_SEQX_BITS	23
+#define MCP25XXFD_CAN_OBJ_FLAGS_SEQX_MASK				\
+	GENMASK(MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT +			\
+		MCP25XXFD_CAN_OBJ_FLAGS_SEQX_BITS - 1,			\
+		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT)
+#define MCP25XXFD_CAN_OBJ_FLAGS_FILHIT_BITS	11
+#define MCP25XXFD_CAN_OBJ_FLAGS_FILHIT_SHIFT	5
+#define MCP25XXFD_CAN_OBJ_FLAGS_FILHIT_MASK				\
+	GENMASK(MCP25XXFD_CAN_FLAGS_FILHIT_SHIFT +			\
+		MCP25XXFD_CAN_FLAGS_FILHIT_BITS - 1,			\
+		MCP25XXFD_CAN_FLAGS_FILHIT_SHIFT)
+
+/* custom status error */
+#define MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_RX BIT(0)
+#define MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_TX BIT(1)
+#define MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_ECC	  BIT(2)
+
+#endif /* __MCP25XXFD_REGS_H */
-- 
2.11.0

