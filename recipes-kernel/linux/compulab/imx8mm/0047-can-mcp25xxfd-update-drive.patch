From c06934e87457e9b22907763ce5147a6b95fb84e0 Mon Sep 17 00:00:00 2001
From: Uri Mashiach <uri.mashiach@compulab.co.il>
Date: Tue, 2 Feb 2021 14:04:19 +0200
Subject: [PATCH 47/64] can: mcp25xxfd: update drive

The driver was taken from Raspberry Pi GitHub:
https://github.com/raspberrypi/linux/tree/rpi-5.4.y/drivers/net/can/spi/mcp251xfd

Signed-off-by: Uri Mashiach <uri.mashiach@compulab.co.il>
---
 drivers/net/can/spi/Kconfig                        |    2 +-
 drivers/net/can/spi/Makefile                       |    2 +-
 drivers/net/can/spi/mcp251xfd/Kconfig              |   17 +
 drivers/net/can/spi/mcp251xfd/Makefile             |    8 +
 drivers/net/can/spi/mcp251xfd/mcp251xfd-core.c     | 2927 ++++++++++++++++++++
 .../mcp251xfd-crc16.c}                             |   67 +-
 drivers/net/can/spi/mcp251xfd/mcp251xfd-regmap.c   |  556 ++++
 drivers/net/can/spi/mcp251xfd/mcp251xfd.h          |  835 ++++++
 drivers/net/can/spi/mcp25xxfd/Kconfig              |    5 -
 drivers/net/can/spi/mcp25xxfd/Makefile             |   18 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c     |  286 --
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h     |   14 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c      |  687 -----
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h      |   56 -
 .../net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c  |  236 --
 .../net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h  |   44 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c |  352 ---
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h |   16 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h   |   69 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c  |  734 -----
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h  |   17 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h |  203 --
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c   |  521 ----
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h   |   18 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c   |  795 ------
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h   |   86 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c    |  491 ----
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h    |   28 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c      |  401 ---
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h      |   86 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h      |   17 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c  |  116 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h  |   30 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c      |   75 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h      |   16 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c     |  255 --
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h     |   16 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c      |   73 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h      |   15 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h     |   91 -
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h     |  681 -----
 41 files changed, 4379 insertions(+), 6583 deletions(-)
 create mode 100644 drivers/net/can/spi/mcp251xfd/Kconfig
 create mode 100644 drivers/net/can/spi/mcp251xfd/Makefile
 create mode 100644 drivers/net/can/spi/mcp251xfd/mcp251xfd-core.c
 rename drivers/net/can/spi/{mcp25xxfd/mcp25xxfd_crc.c => mcp251xfd/mcp251xfd-crc16.c} (63%)
 create mode 100644 drivers/net/can/spi/mcp251xfd/mcp251xfd-regmap.c
 create mode 100644 drivers/net/can/spi/mcp251xfd/mcp251xfd.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/Kconfig
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/Makefile
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h
 delete mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h

diff --git a/drivers/net/can/spi/Kconfig b/drivers/net/can/spi/Kconfig
index d4b68eb5d386..8f145a2daf57 100644
--- a/drivers/net/can/spi/Kconfig
+++ b/drivers/net/can/spi/Kconfig
@@ -15,6 +15,6 @@ config CAN_MCP251X
 	  Driver for the Microchip MCP251x and MCP25625 SPI CAN
 	  controllers.
 
-source "drivers/net/can/spi/mcp25xxfd/Kconfig"
+source "drivers/net/can/spi/mcp251xfd/Kconfig"
 
 endmenu
diff --git a/drivers/net/can/spi/Makefile b/drivers/net/can/spi/Makefile
index 769197785331..ce4de0a05506 100644
--- a/drivers/net/can/spi/Makefile
+++ b/drivers/net/can/spi/Makefile
@@ -7,4 +7,4 @@
 obj-$(CONFIG_CAN_HI311X)	+= hi311x.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
 
-obj-y				+= mcp25xxfd/
+obj-y				+= mcp251xfd/
diff --git a/drivers/net/can/spi/mcp251xfd/Kconfig b/drivers/net/can/spi/mcp251xfd/Kconfig
new file mode 100644
index 000000000000..f5a147a92cb2
--- /dev/null
+++ b/drivers/net/can/spi/mcp251xfd/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config CAN_MCP251XFD
+	tristate "Microchip MCP251xFD SPI CAN controllers"
+	select REGMAP
+	help
+	  Driver for the Microchip MCP251XFD SPI FD-CAN controller
+	  family.
+
+config CAN_MCP251XFD_SANITY
+	depends on CAN_MCP251XFD
+	bool "Additional Sanity Checks"
+	help
+	  This option enables additional sanity checks in the driver,
+	  that compares various internal counters with the in chip
+	  variants. This comes with a runtime overhead.
+	  Disable if unsure.
diff --git a/drivers/net/can/spi/mcp251xfd/Makefile b/drivers/net/can/spi/mcp251xfd/Makefile
new file mode 100644
index 000000000000..cb71244cbe89
--- /dev/null
+++ b/drivers/net/can/spi/mcp251xfd/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-$(CONFIG_CAN_MCP251XFD) += mcp251xfd.o
+
+mcp251xfd-objs :=
+mcp251xfd-objs += mcp251xfd-core.o
+mcp251xfd-objs += mcp251xfd-crc16.o
+mcp251xfd-objs += mcp251xfd-regmap.o
diff --git a/drivers/net/can/spi/mcp251xfd/mcp251xfd-core.c b/drivers/net/can/spi/mcp251xfd/mcp251xfd-core.c
new file mode 100644
index 000000000000..ac3025ccd9d5
--- /dev/null
+++ b/drivers/net/can/spi/mcp251xfd/mcp251xfd-core.c
@@ -0,0 +1,2927 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp251xfd - Microchip MCP251xFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+// Based on:
+//
+// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+//
+// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+//
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+
+#include <asm/unaligned.h>
+
+#include "mcp251xfd.h"
+
+#define DEVICE_NAME "mcp251xfd"
+
+static const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp2517fd = {
+	.quirks = MCP251XFD_QUIRK_MAB_NO_WARN | MCP251XFD_QUIRK_CRC_REG |
+		MCP251XFD_QUIRK_CRC_RX | MCP251XFD_QUIRK_CRC_TX |
+		MCP251XFD_QUIRK_ECC,
+	.model = MCP251XFD_MODEL_MCP2517FD,
+};
+
+static const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp2518fd = {
+	.quirks = MCP251XFD_QUIRK_CRC_REG | MCP251XFD_QUIRK_CRC_RX |
+		MCP251XFD_QUIRK_CRC_TX | MCP251XFD_QUIRK_ECC,
+	.model = MCP251XFD_MODEL_MCP2518FD,
+};
+
+/* Autodetect model, start with CRC enabled. */
+static const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp251xfd = {
+	.quirks = MCP251XFD_QUIRK_CRC_REG | MCP251XFD_QUIRK_CRC_RX |
+		MCP251XFD_QUIRK_CRC_TX | MCP251XFD_QUIRK_ECC,
+	.model = MCP251XFD_MODEL_MCP251XFD,
+};
+
+static const struct can_bittiming_const mcp251xfd_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 2,
+	.tseg1_max = 256,
+	.tseg2_min = 1,
+	.tseg2_max = 128,
+	.sjw_max = 128,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+static const struct can_bittiming_const mcp251xfd_data_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 32,
+	.tseg2_min = 1,
+	.tseg2_max = 16,
+	.sjw_max = 16,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+static const char *__mcp251xfd_get_model_str(enum mcp251xfd_model model)
+{
+	switch (model) {
+	case MCP251XFD_MODEL_MCP2517FD:
+		return "MCP2517FD";
+	case MCP251XFD_MODEL_MCP2518FD:
+		return "MCP2518FD";
+	case MCP251XFD_MODEL_MCP251XFD:
+		return "MCP251xFD";
+	}
+
+	return "<unknown>";
+}
+
+static inline const char *
+mcp251xfd_get_model_str(const struct mcp251xfd_priv *priv)
+{
+	return __mcp251xfd_get_model_str(priv->devtype_data.model);
+}
+
+static const char *mcp251xfd_get_mode_str(const u8 mode)
+{
+	switch (mode) {
+	case MCP251XFD_REG_CON_MODE_MIXED:
+		return "Mixed (CAN FD/CAN 2.0)";
+	case MCP251XFD_REG_CON_MODE_SLEEP:
+		return "Sleep";
+	case MCP251XFD_REG_CON_MODE_INT_LOOPBACK:
+		return "Internal Loopback";
+	case MCP251XFD_REG_CON_MODE_LISTENONLY:
+		return "Listen Only";
+	case MCP251XFD_REG_CON_MODE_CONFIG:
+		return "Configuration";
+	case MCP251XFD_REG_CON_MODE_EXT_LOOPBACK:
+		return "External Loopback";
+	case MCP251XFD_REG_CON_MODE_CAN2_0:
+		return "CAN 2.0";
+	case MCP251XFD_REG_CON_MODE_RESTRICTED:
+		return "Restricted Operation";
+	}
+
+	return "<unknown>";
+}
+
+static inline int mcp251xfd_vdd_enable(const struct mcp251xfd_priv *priv)
+{
+	if (!priv->reg_vdd)
+		return 0;
+
+	return regulator_enable(priv->reg_vdd);
+}
+
+static inline int mcp251xfd_vdd_disable(const struct mcp251xfd_priv *priv)
+{
+	if (!priv->reg_vdd)
+		return 0;
+
+	return regulator_disable(priv->reg_vdd);
+}
+
+static inline int
+mcp251xfd_transceiver_enable(const struct mcp251xfd_priv *priv)
+{
+	if (!priv->reg_xceiver)
+		return 0;
+
+	return regulator_enable(priv->reg_xceiver);
+}
+
+static inline int
+mcp251xfd_transceiver_disable(const struct mcp251xfd_priv *priv)
+{
+	if (!priv->reg_xceiver)
+		return 0;
+
+	return regulator_disable(priv->reg_xceiver);
+}
+
+static int mcp251xfd_clks_and_vdd_enable(const struct mcp251xfd_priv *priv)
+{
+	int err;
+
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	err = mcp251xfd_vdd_enable(priv);
+	if (err)
+		clk_disable_unprepare(priv->clk);
+
+	/* Wait for oscillator stabilisation time after power up */
+	usleep_range(MCP251XFD_OSC_STAB_SLEEP_US,
+		     2 * MCP251XFD_OSC_STAB_SLEEP_US);
+
+	return err;
+}
+
+static int mcp251xfd_clks_and_vdd_disable(const struct mcp251xfd_priv *priv)
+{
+	int err;
+
+	err = mcp251xfd_vdd_disable(priv);
+	if (err)
+		return err;
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static inline u8
+mcp251xfd_cmd_prepare_write_reg(const struct mcp251xfd_priv *priv,
+				union mcp251xfd_write_reg_buf *write_reg_buf,
+				const u16 reg, const u32 mask, const u32 val)
+{
+	u8 first_byte, last_byte, len;
+	u8 *data;
+	__le32 val_le32;
+
+	first_byte = mcp251xfd_first_byte_set(mask);
+	last_byte = mcp251xfd_last_byte_set(mask);
+	len = last_byte - first_byte + 1;
+
+	data = mcp251xfd_spi_cmd_write(priv, write_reg_buf, reg + first_byte);
+	val_le32 = cpu_to_le32(val >> BITS_PER_BYTE * first_byte);
+	memcpy(data, &val_le32, len);
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG) {
+		u16 crc;
+
+		mcp251xfd_spi_cmd_crc_set_len_in_reg(&write_reg_buf->crc.cmd,
+						     len);
+		/* CRC */
+		len += sizeof(write_reg_buf->crc.cmd);
+		crc = mcp251xfd_crc16_compute(&write_reg_buf->crc, len);
+		put_unaligned_be16(crc, (void *)write_reg_buf + len);
+
+		/* Total length */
+		len += sizeof(write_reg_buf->crc.crc);
+	} else {
+		len += sizeof(write_reg_buf->nocrc.cmd);
+	}
+
+	return len;
+}
+
+static inline int
+mcp251xfd_tef_tail_get_from_chip(const struct mcp251xfd_priv *priv,
+				 u8 *tef_tail)
+{
+	u32 tef_ua;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_TEFUA, &tef_ua);
+	if (err)
+		return err;
+
+	*tef_tail = tef_ua / sizeof(struct mcp251xfd_hw_tef_obj);
+
+	return 0;
+}
+
+static inline int
+mcp251xfd_tx_tail_get_from_chip(const struct mcp251xfd_priv *priv,
+				u8 *tx_tail)
+{
+	u32 fifo_sta;
+	int err;
+
+	err = regmap_read(priv->map_reg,
+			  MCP251XFD_REG_FIFOSTA(MCP251XFD_TX_FIFO),
+			  &fifo_sta);
+	if (err)
+		return err;
+
+	*tx_tail = FIELD_GET(MCP251XFD_REG_FIFOSTA_FIFOCI_MASK, fifo_sta);
+
+	return 0;
+}
+
+static inline int
+mcp251xfd_rx_head_get_from_chip(const struct mcp251xfd_priv *priv,
+				const struct mcp251xfd_rx_ring *ring,
+				u8 *rx_head)
+{
+	u32 fifo_sta;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_FIFOSTA(ring->fifo_nr),
+			  &fifo_sta);
+	if (err)
+		return err;
+
+	*rx_head = FIELD_GET(MCP251XFD_REG_FIFOSTA_FIFOCI_MASK, fifo_sta);
+
+	return 0;
+}
+
+static inline int
+mcp251xfd_rx_tail_get_from_chip(const struct mcp251xfd_priv *priv,
+				const struct mcp251xfd_rx_ring *ring,
+				u8 *rx_tail)
+{
+	u32 fifo_ua;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_FIFOUA(ring->fifo_nr),
+			  &fifo_ua);
+	if (err)
+		return err;
+
+	fifo_ua -= ring->base - MCP251XFD_RAM_START;
+	*rx_tail = fifo_ua / ring->obj_size;
+
+	return 0;
+}
+
+static void
+mcp251xfd_tx_ring_init_tx_obj(const struct mcp251xfd_priv *priv,
+			      const struct mcp251xfd_tx_ring *ring,
+			      struct mcp251xfd_tx_obj *tx_obj,
+			      const u8 rts_buf_len,
+			      const u8 n)
+{
+	struct spi_transfer *xfer;
+	u16 addr;
+
+	/* FIFO load */
+	addr = mcp251xfd_get_tx_obj_addr(ring, n);
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_TX)
+		mcp251xfd_spi_cmd_write_crc_set_addr(&tx_obj->buf.crc.cmd,
+						     addr);
+	else
+		mcp251xfd_spi_cmd_write_nocrc(&tx_obj->buf.nocrc.cmd,
+					      addr);
+
+	xfer = &tx_obj->xfer[0];
+	xfer->tx_buf = &tx_obj->buf;
+	xfer->len = 0;	/* actual len is assigned on the fly */
+	xfer->cs_change = 1;
+	xfer->cs_change_delay = 0;
+	xfer->cs_change_delay_unit = SPI_DELAY_UNIT_NSECS;
+
+	/* FIFO request to send */
+	xfer = &tx_obj->xfer[1];
+	xfer->tx_buf = &ring->rts_buf;
+	xfer->len = rts_buf_len;
+
+	/* SPI message */
+	spi_message_init_with_transfers(&tx_obj->msg, tx_obj->xfer,
+					ARRAY_SIZE(tx_obj->xfer));
+}
+
+static void mcp251xfd_ring_init(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_tx_ring *tx_ring;
+	struct mcp251xfd_rx_ring *rx_ring, *prev_rx_ring = NULL;
+	struct mcp251xfd_tx_obj *tx_obj;
+	u32 val;
+	u16 addr;
+	u8 len;
+	int i;
+
+	/* TEF */
+	priv->tef.head = 0;
+	priv->tef.tail = 0;
+
+	/* TX */
+	tx_ring = priv->tx;
+	tx_ring->head = 0;
+	tx_ring->tail = 0;
+	tx_ring->base = mcp251xfd_get_tef_obj_addr(tx_ring->obj_num);
+
+	/* FIFO request to send */
+	addr = MCP251XFD_REG_FIFOCON(MCP251XFD_TX_FIFO);
+	val = MCP251XFD_REG_FIFOCON_TXREQ | MCP251XFD_REG_FIFOCON_UINC;
+	len = mcp251xfd_cmd_prepare_write_reg(priv, &tx_ring->rts_buf,
+					      addr, val, val);
+
+	mcp251xfd_for_each_tx_obj(tx_ring, tx_obj, i)
+		mcp251xfd_tx_ring_init_tx_obj(priv, tx_ring, tx_obj, len, i);
+
+	/* RX */
+	mcp251xfd_for_each_rx_ring(priv, rx_ring, i) {
+		rx_ring->head = 0;
+		rx_ring->tail = 0;
+		rx_ring->nr = i;
+		rx_ring->fifo_nr = MCP251XFD_RX_FIFO(i);
+
+		if (!prev_rx_ring)
+			rx_ring->base =
+				mcp251xfd_get_tx_obj_addr(tx_ring,
+							  tx_ring->obj_num);
+		else
+			rx_ring->base = prev_rx_ring->base +
+				prev_rx_ring->obj_size *
+				prev_rx_ring->obj_num;
+
+		prev_rx_ring = rx_ring;
+	}
+}
+
+static void mcp251xfd_ring_free(struct mcp251xfd_priv *priv)
+{
+	int i;
+
+	for (i = ARRAY_SIZE(priv->rx) - 1; i >= 0; i--) {
+		kfree(priv->rx[i]);
+		priv->rx[i] = NULL;
+	}
+}
+
+static int mcp251xfd_ring_alloc(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_tx_ring *tx_ring;
+	struct mcp251xfd_rx_ring *rx_ring;
+	int tef_obj_size, tx_obj_size, rx_obj_size;
+	int tx_obj_num;
+	int ram_free, i;
+
+	tef_obj_size = sizeof(struct mcp251xfd_hw_tef_obj);
+	/* listen-only mode works like FD mode */
+	if (priv->can.ctrlmode & (CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_FD)) {
+		tx_obj_num = MCP251XFD_TX_OBJ_NUM_CANFD;
+		tx_obj_size = sizeof(struct mcp251xfd_hw_tx_obj_canfd);
+		rx_obj_size = sizeof(struct mcp251xfd_hw_rx_obj_canfd);
+	} else {
+		tx_obj_num = MCP251XFD_TX_OBJ_NUM_CAN;
+		tx_obj_size = sizeof(struct mcp251xfd_hw_tx_obj_can);
+		rx_obj_size = sizeof(struct mcp251xfd_hw_rx_obj_can);
+	}
+
+	tx_ring = priv->tx;
+	tx_ring->obj_num = tx_obj_num;
+	tx_ring->obj_size = tx_obj_size;
+
+	ram_free = MCP251XFD_RAM_SIZE - tx_obj_num *
+		(tef_obj_size + tx_obj_size);
+
+	for (i = 0;
+	     i < ARRAY_SIZE(priv->rx) && ram_free >= rx_obj_size;
+	     i++) {
+		int rx_obj_num;
+
+		rx_obj_num = ram_free / rx_obj_size;
+		rx_obj_num = min(1 << (fls(rx_obj_num) - 1), 32);
+
+		rx_ring = kzalloc(sizeof(*rx_ring) + rx_obj_size * rx_obj_num,
+				  GFP_KERNEL);
+		if (!rx_ring) {
+			mcp251xfd_ring_free(priv);
+			return -ENOMEM;
+		}
+		rx_ring->obj_num = rx_obj_num;
+		rx_ring->obj_size = rx_obj_size;
+		priv->rx[i] = rx_ring;
+
+		ram_free -= rx_ring->obj_num * rx_ring->obj_size;
+	}
+	priv->rx_ring_num = i;
+
+	netdev_dbg(priv->ndev,
+		   "FIFO setup: TEF: %d*%d bytes = %d bytes, TX: %d*%d bytes = %d bytes\n",
+		   tx_obj_num, tef_obj_size, tef_obj_size * tx_obj_num,
+		   tx_obj_num, tx_obj_size, tx_obj_size * tx_obj_num);
+
+	mcp251xfd_for_each_rx_ring(priv, rx_ring, i) {
+		netdev_dbg(priv->ndev,
+			   "FIFO setup: RX-%d: %d*%d bytes = %d bytes\n",
+			   i, rx_ring->obj_num, rx_ring->obj_size,
+			   rx_ring->obj_size * rx_ring->obj_num);
+	}
+
+	netdev_dbg(priv->ndev,
+		   "FIFO setup: free: %d bytes\n",
+		   ram_free);
+
+	return 0;
+}
+
+static inline int
+mcp251xfd_chip_get_mode(const struct mcp251xfd_priv *priv, u8 *mode)
+{
+	u32 val;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_CON, &val);
+	if (err)
+		return err;
+
+	*mode = FIELD_GET(MCP251XFD_REG_CON_OPMOD_MASK, val);
+
+	return 0;
+}
+
+static int
+__mcp251xfd_chip_set_mode(const struct mcp251xfd_priv *priv,
+			  const u8 mode_req, bool nowait)
+{
+	u32 con, con_reqop;
+	int err;
+
+	con_reqop = FIELD_PREP(MCP251XFD_REG_CON_REQOP_MASK, mode_req);
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_CON,
+				 MCP251XFD_REG_CON_REQOP_MASK, con_reqop);
+	if (err)
+		return err;
+
+	if (mode_req == MCP251XFD_REG_CON_MODE_SLEEP || nowait)
+		return 0;
+
+	err = regmap_read_poll_timeout(priv->map_reg, MCP251XFD_REG_CON, con,
+				       FIELD_GET(MCP251XFD_REG_CON_OPMOD_MASK,
+						 con) == mode_req,
+				       MCP251XFD_POLL_SLEEP_US,
+				       MCP251XFD_POLL_TIMEOUT_US);
+	if (err) {
+		u8 mode = FIELD_GET(MCP251XFD_REG_CON_OPMOD_MASK, con);
+
+		netdev_err(priv->ndev,
+			   "Controller failed to enter mode %s Mode (%u) and stays in %s Mode (%u).\n",
+			   mcp251xfd_get_mode_str(mode_req), mode_req,
+			   mcp251xfd_get_mode_str(mode), mode);
+		return err;
+	}
+
+	return 0;
+}
+
+static inline int
+mcp251xfd_chip_set_mode(const struct mcp251xfd_priv *priv,
+			const u8 mode_req)
+{
+	return __mcp251xfd_chip_set_mode(priv, mode_req, false);
+}
+
+static inline int
+mcp251xfd_chip_set_mode_nowait(const struct mcp251xfd_priv *priv,
+			       const u8 mode_req)
+{
+	return __mcp251xfd_chip_set_mode(priv, mode_req, true);
+}
+
+static inline bool mcp251xfd_osc_invalid(u32 reg)
+{
+	return reg == 0x0 || reg == 0xffffffff;
+}
+
+static int mcp251xfd_chip_clock_enable(const struct mcp251xfd_priv *priv)
+{
+	u32 osc, osc_reference, osc_mask;
+	int err;
+
+	/* Set Power On Defaults for "Clock Output Divisor" and remove
+	 * "Oscillator Disable" bit.
+	 */
+	osc = FIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,
+			 MCP251XFD_REG_OSC_CLKODIV_10);
+	osc_reference = MCP251XFD_REG_OSC_OSCRDY;
+	osc_mask = MCP251XFD_REG_OSC_OSCRDY | MCP251XFD_REG_OSC_PLLRDY;
+
+	/* Note:
+	 *
+	 * If the controller is in Sleep Mode the following write only
+	 * removes the "Oscillator Disable" bit and powers it up. All
+	 * other bits are unaffected.
+	 */
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_OSC, osc);
+	if (err)
+		return err;
+
+	/* Wait for "Oscillator Ready" bit */
+	err = regmap_read_poll_timeout(priv->map_reg, MCP251XFD_REG_OSC, osc,
+				       (osc & osc_mask) == osc_reference,
+				       MCP251XFD_OSC_STAB_SLEEP_US,
+				       MCP251XFD_OSC_STAB_TIMEOUT_US);
+	if (mcp251xfd_osc_invalid(osc)) {
+		netdev_err(priv->ndev,
+			   "Failed to detect %s (osc=0x%08x).\n",
+			   mcp251xfd_get_model_str(priv), osc);
+		return -ENODEV;
+	} else if (err == -ETIMEDOUT) {
+		netdev_err(priv->ndev,
+			   "Timeout waiting for Oscillator Ready (osc=0x%08x, osc_reference=0x%08x)\n",
+			   osc, osc_reference);
+		return -ETIMEDOUT;
+	} else if (err) {
+		return err;
+	}
+
+	return 0;
+}
+
+static int mcp251xfd_chip_softreset_do(const struct mcp251xfd_priv *priv)
+{
+	const __be16 cmd = mcp251xfd_cmd_reset();
+	int err;
+
+	/* The Set Mode and SPI Reset command only seems to works if
+	 * the controller is not in Sleep Mode.
+	 */
+	err = mcp251xfd_chip_clock_enable(priv);
+	if (err)
+		return err;
+
+	err = mcp251xfd_chip_set_mode(priv, MCP251XFD_REG_CON_MODE_CONFIG);
+	if (err)
+		return err;
+
+	/* spi_write_then_read() works with non DMA-safe buffers */
+	return spi_write_then_read(priv->spi, &cmd, sizeof(cmd), NULL, 0);
+}
+
+static int mcp251xfd_chip_softreset_check(const struct mcp251xfd_priv *priv)
+{
+	u32 osc, osc_reference;
+	u8 mode;
+	int err;
+
+	err = mcp251xfd_chip_get_mode(priv, &mode);
+	if (err)
+		return err;
+
+	if (mode != MCP251XFD_REG_CON_MODE_CONFIG) {
+		netdev_info(priv->ndev,
+			    "Controller not in Config Mode after reset, but in %s Mode (%u).\n",
+			    mcp251xfd_get_mode_str(mode), mode);
+		return -ETIMEDOUT;
+	}
+
+	osc_reference = MCP251XFD_REG_OSC_OSCRDY |
+		FIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,
+			   MCP251XFD_REG_OSC_CLKODIV_10);
+
+	/* check reset defaults of OSC reg */
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_OSC, &osc);
+	if (err)
+		return err;
+
+	if (osc != osc_reference) {
+		netdev_info(priv->ndev,
+			    "Controller failed to reset. osc=0x%08x, reference value=0x%08x\n",
+			    osc, osc_reference);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int mcp251xfd_chip_softreset(const struct mcp251xfd_priv *priv)
+{
+	int err, i;
+
+	for (i = 0; i < MCP251XFD_SOFTRESET_RETRIES_MAX; i++) {
+		if (i)
+			netdev_info(priv->ndev,
+				    "Retrying to reset Controller.\n");
+
+		err = mcp251xfd_chip_softreset_do(priv);
+		if (err == -ETIMEDOUT)
+			continue;
+		if (err)
+			return err;
+
+		err = mcp251xfd_chip_softreset_check(priv);
+		if (err == -ETIMEDOUT)
+			continue;
+		if (err)
+			return err;
+
+		return 0;
+	}
+
+	if (err)
+		return err;
+
+	return -ETIMEDOUT;
+}
+
+static int mcp251xfd_chip_clock_init(const struct mcp251xfd_priv *priv)
+{
+	u32 osc;
+	int err;
+
+	/* Activate Low Power Mode on Oscillator Disable. This only
+	 * works on the MCP2518FD. The MCP2517FD will go into normal
+	 * Sleep Mode instead.
+	 */
+	osc = MCP251XFD_REG_OSC_LPMEN |
+		FIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,
+			   MCP251XFD_REG_OSC_CLKODIV_10);
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_OSC, osc);
+	if (err)
+		return err;
+
+	/* Set Time Base Counter Prescaler to 1.
+	 *
+	 * This means an overflow of the 32 bit Time Base Counter
+	 * register at 40 MHz every 107 seconds.
+	 */
+	return regmap_write(priv->map_reg, MCP251XFD_REG_TSCON,
+			    MCP251XFD_REG_TSCON_TBCEN);
+}
+
+static int mcp251xfd_set_bittiming(const struct mcp251xfd_priv *priv)
+{
+	const struct can_bittiming *bt = &priv->can.bittiming;
+	const struct can_bittiming *dbt = &priv->can.data_bittiming;
+	u32 val = 0;
+	s8 tdco;
+	int err;
+
+	/* CAN Control Register
+	 *
+	 * - no transmit bandwidth sharing
+	 * - config mode
+	 * - disable transmit queue
+	 * - store in transmit FIFO event
+	 * - transition to restricted operation mode on system error
+	 * - ESI is transmitted recessive when ESI of message is high or
+	 *   CAN controller error passive
+	 * - restricted retransmission attempts,
+	 *   use TQXCON_TXAT and FIFOCON_TXAT
+	 * - wake-up filter bits T11FILTER
+	 * - use CAN bus line filter for wakeup
+	 * - protocol exception is treated as a form error
+	 * - Do not compare data bytes
+	 */
+	val = FIELD_PREP(MCP251XFD_REG_CON_REQOP_MASK,
+			 MCP251XFD_REG_CON_MODE_CONFIG) |
+		MCP251XFD_REG_CON_STEF |
+		MCP251XFD_REG_CON_ESIGM |
+		MCP251XFD_REG_CON_RTXAT |
+		FIELD_PREP(MCP251XFD_REG_CON_WFT_MASK,
+			   MCP251XFD_REG_CON_WFT_T11FILTER) |
+		MCP251XFD_REG_CON_WAKFIL |
+		MCP251XFD_REG_CON_PXEDIS;
+
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
+		val |= MCP251XFD_REG_CON_ISOCRCEN;
+
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_CON, val);
+	if (err)
+		return err;
+
+	/* Nominal Bit Time */
+	val = FIELD_PREP(MCP251XFD_REG_NBTCFG_BRP_MASK, bt->brp - 1) |
+		FIELD_PREP(MCP251XFD_REG_NBTCFG_TSEG1_MASK,
+			   bt->prop_seg + bt->phase_seg1 - 1) |
+		FIELD_PREP(MCP251XFD_REG_NBTCFG_TSEG2_MASK,
+			   bt->phase_seg2 - 1) |
+		FIELD_PREP(MCP251XFD_REG_NBTCFG_SJW_MASK, bt->sjw - 1);
+
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_NBTCFG, val);
+	if (err)
+		return err;
+
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))
+		return 0;
+
+	/* Data Bit Time */
+	val = FIELD_PREP(MCP251XFD_REG_DBTCFG_BRP_MASK, dbt->brp - 1) |
+		FIELD_PREP(MCP251XFD_REG_DBTCFG_TSEG1_MASK,
+			   dbt->prop_seg + dbt->phase_seg1 - 1) |
+		FIELD_PREP(MCP251XFD_REG_DBTCFG_TSEG2_MASK,
+			   dbt->phase_seg2 - 1) |
+		FIELD_PREP(MCP251XFD_REG_DBTCFG_SJW_MASK, dbt->sjw - 1);
+
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_DBTCFG, val);
+	if (err)
+		return err;
+
+	/* Transmitter Delay Compensation */
+	tdco = clamp_t(int, dbt->brp * (dbt->prop_seg + dbt->phase_seg1),
+		       -64, 63);
+	val = FIELD_PREP(MCP251XFD_REG_TDC_TDCMOD_MASK,
+			 MCP251XFD_REG_TDC_TDCMOD_AUTO) |
+		FIELD_PREP(MCP251XFD_REG_TDC_TDCO_MASK, tdco);
+
+	return regmap_write(priv->map_reg, MCP251XFD_REG_TDC, val);
+}
+
+static int mcp251xfd_chip_rx_int_enable(const struct mcp251xfd_priv *priv)
+{
+	u32 val;
+
+	if (!priv->rx_int)
+		return 0;
+
+	/* Configure GPIOs:
+	 * - PIN0: GPIO Input
+	 * - PIN1: GPIO Input/RX Interrupt
+	 *
+	 * PIN1 must be Input, otherwise there is a glitch on the
+	 * rx-INT line. It happens between setting the PIN as output
+	 * (in the first byte of the SPI transfer) and configuring the
+	 * PIN as interrupt (in the last byte of the SPI transfer).
+	 */
+	val = MCP251XFD_REG_IOCON_PM0 | MCP251XFD_REG_IOCON_TRIS1 |
+		MCP251XFD_REG_IOCON_TRIS0;
+	return regmap_write(priv->map_reg, MCP251XFD_REG_IOCON, val);
+}
+
+static int mcp251xfd_chip_rx_int_disable(const struct mcp251xfd_priv *priv)
+{
+	u32 val;
+
+	if (!priv->rx_int)
+		return 0;
+
+	/* Configure GPIOs:
+	 * - PIN0: GPIO Input
+	 * - PIN1: GPIO Input
+	 */
+	val = MCP251XFD_REG_IOCON_PM1 | MCP251XFD_REG_IOCON_PM0 |
+		MCP251XFD_REG_IOCON_TRIS1 | MCP251XFD_REG_IOCON_TRIS0;
+	return regmap_write(priv->map_reg, MCP251XFD_REG_IOCON, val);
+}
+
+static int
+mcp251xfd_chip_rx_fifo_init_one(const struct mcp251xfd_priv *priv,
+				const struct mcp251xfd_rx_ring *ring)
+{
+	u32 fifo_con;
+
+	/* Enable RXOVIE on _all_ RX FIFOs, not just the last one.
+	 *
+	 * FIFOs hit by a RX MAB overflow and RXOVIE enabled will
+	 * generate a RXOVIF, use this to properly detect RX MAB
+	 * overflows.
+	 */
+	fifo_con = FIELD_PREP(MCP251XFD_REG_FIFOCON_FSIZE_MASK,
+			      ring->obj_num - 1) |
+		MCP251XFD_REG_FIFOCON_RXTSEN |
+		MCP251XFD_REG_FIFOCON_RXOVIE |
+		MCP251XFD_REG_FIFOCON_TFNRFNIE;
+
+	if (priv->can.ctrlmode & (CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_FD))
+		fifo_con |= FIELD_PREP(MCP251XFD_REG_FIFOCON_PLSIZE_MASK,
+				       MCP251XFD_REG_FIFOCON_PLSIZE_64);
+	else
+		fifo_con |= FIELD_PREP(MCP251XFD_REG_FIFOCON_PLSIZE_MASK,
+				       MCP251XFD_REG_FIFOCON_PLSIZE_8);
+
+	return regmap_write(priv->map_reg,
+			    MCP251XFD_REG_FIFOCON(ring->fifo_nr), fifo_con);
+}
+
+static int
+mcp251xfd_chip_rx_filter_init_one(const struct mcp251xfd_priv *priv,
+				  const struct mcp251xfd_rx_ring *ring)
+{
+	u32 fltcon;
+
+	fltcon = MCP251XFD_REG_FLTCON_FLTEN(ring->nr) |
+		MCP251XFD_REG_FLTCON_FBP(ring->nr, ring->fifo_nr);
+
+	return regmap_update_bits(priv->map_reg,
+				  MCP251XFD_REG_FLTCON(ring->nr >> 2),
+				  MCP251XFD_REG_FLTCON_FLT_MASK(ring->nr),
+				  fltcon);
+}
+
+static int mcp251xfd_chip_fifo_init(const struct mcp251xfd_priv *priv)
+{
+	const struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+	const struct mcp251xfd_rx_ring *rx_ring;
+	u32 val;
+	int err, n;
+
+	/* TEF */
+	val = FIELD_PREP(MCP251XFD_REG_TEFCON_FSIZE_MASK,
+			 tx_ring->obj_num - 1) |
+		MCP251XFD_REG_TEFCON_TEFTSEN |
+		MCP251XFD_REG_TEFCON_TEFOVIE |
+		MCP251XFD_REG_TEFCON_TEFNEIE;
+
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_TEFCON, val);
+	if (err)
+		return err;
+
+	/* FIFO 1 - TX */
+	val = FIELD_PREP(MCP251XFD_REG_FIFOCON_FSIZE_MASK,
+			 tx_ring->obj_num - 1) |
+		MCP251XFD_REG_FIFOCON_TXEN |
+		MCP251XFD_REG_FIFOCON_TXATIE;
+
+	if (priv->can.ctrlmode & (CAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_FD))
+		val |= FIELD_PREP(MCP251XFD_REG_FIFOCON_PLSIZE_MASK,
+				  MCP251XFD_REG_FIFOCON_PLSIZE_64);
+	else
+		val |= FIELD_PREP(MCP251XFD_REG_FIFOCON_PLSIZE_MASK,
+				  MCP251XFD_REG_FIFOCON_PLSIZE_8);
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		val |= FIELD_PREP(MCP251XFD_REG_FIFOCON_TXAT_MASK,
+				  MCP251XFD_REG_FIFOCON_TXAT_ONE_SHOT);
+	else
+		val |= FIELD_PREP(MCP251XFD_REG_FIFOCON_TXAT_MASK,
+				  MCP251XFD_REG_FIFOCON_TXAT_UNLIMITED);
+
+	err = regmap_write(priv->map_reg,
+			   MCP251XFD_REG_FIFOCON(MCP251XFD_TX_FIFO),
+			   val);
+	if (err)
+		return err;
+
+	/* RX FIFOs */
+	mcp251xfd_for_each_rx_ring(priv, rx_ring, n) {
+		err = mcp251xfd_chip_rx_fifo_init_one(priv, rx_ring);
+		if (err)
+			return err;
+
+		err = mcp251xfd_chip_rx_filter_init_one(priv, rx_ring);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static int mcp251xfd_chip_ecc_init(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_ecc *ecc = &priv->ecc;
+	void *ram;
+	u32 val = 0;
+	int err;
+
+	ecc->ecc_stat = 0;
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_ECC)
+		val = MCP251XFD_REG_ECCCON_ECCEN;
+
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCCON,
+				 MCP251XFD_REG_ECCCON_ECCEN, val);
+	if (err)
+		return err;
+
+	ram = kzalloc(MCP251XFD_RAM_SIZE, GFP_KERNEL);
+	if (!ram)
+		return -ENOMEM;
+
+	err = regmap_raw_write(priv->map_reg, MCP251XFD_RAM_START, ram,
+			       MCP251XFD_RAM_SIZE);
+	kfree(ram);
+
+	return err;
+}
+
+static inline void mcp251xfd_ecc_tefif_successful(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_ecc *ecc = &priv->ecc;
+
+	ecc->ecc_stat = 0;
+}
+
+static u8 mcp251xfd_get_normal_mode(const struct mcp251xfd_priv *priv)
+{
+	u8 mode;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)
+		mode = MCP251XFD_REG_CON_MODE_LISTENONLY;
+	else if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		mode = MCP251XFD_REG_CON_MODE_MIXED;
+	else
+		mode = MCP251XFD_REG_CON_MODE_CAN2_0;
+
+	return mode;
+}
+
+static int
+__mcp251xfd_chip_set_normal_mode(const struct mcp251xfd_priv *priv,
+				 bool nowait)
+{
+	u8 mode;
+
+	mode = mcp251xfd_get_normal_mode(priv);
+
+	return __mcp251xfd_chip_set_mode(priv, mode, nowait);
+}
+
+static inline int
+mcp251xfd_chip_set_normal_mode(const struct mcp251xfd_priv *priv)
+{
+	return __mcp251xfd_chip_set_normal_mode(priv, false);
+}
+
+static inline int
+mcp251xfd_chip_set_normal_mode_nowait(const struct mcp251xfd_priv *priv)
+{
+	return __mcp251xfd_chip_set_normal_mode(priv, true);
+}
+
+static int mcp251xfd_chip_interrupts_enable(const struct mcp251xfd_priv *priv)
+{
+	u32 val;
+	int err;
+
+	val = MCP251XFD_REG_CRC_FERRIE | MCP251XFD_REG_CRC_CRCERRIE;
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_CRC, val);
+	if (err)
+		return err;
+
+	val = MCP251XFD_REG_ECCCON_DEDIE | MCP251XFD_REG_ECCCON_SECIE;
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCCON, val, val);
+	if (err)
+		return err;
+
+	val = MCP251XFD_REG_INT_CERRIE |
+		MCP251XFD_REG_INT_SERRIE |
+		MCP251XFD_REG_INT_RXOVIE |
+		MCP251XFD_REG_INT_TXATIE |
+		MCP251XFD_REG_INT_SPICRCIE |
+		MCP251XFD_REG_INT_ECCIE |
+		MCP251XFD_REG_INT_TEFIE |
+		MCP251XFD_REG_INT_MODIE |
+		MCP251XFD_REG_INT_RXIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
+		val |= MCP251XFD_REG_INT_IVMIE;
+
+	return regmap_write(priv->map_reg, MCP251XFD_REG_INT, val);
+}
+
+static int mcp251xfd_chip_interrupts_disable(const struct mcp251xfd_priv *priv)
+{
+	int err;
+	u32 mask;
+
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_INT, 0);
+	if (err)
+		return err;
+
+	mask = MCP251XFD_REG_ECCCON_DEDIE | MCP251XFD_REG_ECCCON_SECIE;
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCCON,
+				 mask, 0x0);
+	if (err)
+		return err;
+
+	return regmap_write(priv->map_reg, MCP251XFD_REG_CRC, 0);
+}
+
+static int mcp251xfd_chip_stop(struct mcp251xfd_priv *priv,
+			       const enum can_state state)
+{
+	priv->can.state = state;
+
+	mcp251xfd_chip_interrupts_disable(priv);
+	mcp251xfd_chip_rx_int_disable(priv);
+	return mcp251xfd_chip_set_mode(priv, MCP251XFD_REG_CON_MODE_SLEEP);
+}
+
+static int mcp251xfd_chip_start(struct mcp251xfd_priv *priv)
+{
+	int err;
+
+	err = mcp251xfd_chip_softreset(priv);
+	if (err)
+		goto out_chip_stop;
+
+	err = mcp251xfd_chip_clock_init(priv);
+	if (err)
+		goto out_chip_stop;
+
+	err = mcp251xfd_set_bittiming(priv);
+	if (err)
+		goto out_chip_stop;
+
+	err = mcp251xfd_chip_rx_int_enable(priv);
+	if (err)
+		return err;
+
+	err = mcp251xfd_chip_ecc_init(priv);
+	if (err)
+		goto out_chip_stop;
+
+	mcp251xfd_ring_init(priv);
+
+	err = mcp251xfd_chip_fifo_init(priv);
+	if (err)
+		goto out_chip_stop;
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	err = mcp251xfd_chip_set_normal_mode(priv);
+	if (err)
+		goto out_chip_stop;
+
+	return 0;
+
+ out_chip_stop:
+	mcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);
+
+	return err;
+}
+
+static int mcp251xfd_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	struct mcp251xfd_priv *priv = netdev_priv(ndev);
+	int err;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		err = mcp251xfd_chip_start(priv);
+		if (err)
+			return err;
+
+		err = mcp251xfd_chip_interrupts_enable(priv);
+		if (err) {
+			mcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);
+			return err;
+		}
+
+		netif_wake_queue(ndev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int __mcp251xfd_get_berr_counter(const struct net_device *ndev,
+					struct can_berr_counter *bec)
+{
+	const struct mcp251xfd_priv *priv = netdev_priv(ndev);
+	u32 trec;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_TREC, &trec);
+	if (err)
+		return err;
+
+	if (trec & MCP251XFD_REG_TREC_TXBO)
+		bec->txerr = 256;
+	else
+		bec->txerr = FIELD_GET(MCP251XFD_REG_TREC_TEC_MASK, trec);
+	bec->rxerr = FIELD_GET(MCP251XFD_REG_TREC_REC_MASK, trec);
+
+	return 0;
+}
+
+static int mcp251xfd_get_berr_counter(const struct net_device *ndev,
+				      struct can_berr_counter *bec)
+{
+	const struct mcp251xfd_priv *priv = netdev_priv(ndev);
+
+	/* Avoid waking up the controller if the interface is down */
+	if (!(ndev->flags & IFF_UP))
+		return 0;
+
+	/* The controller is powered down during Bus Off, use saved
+	 * bec values.
+	 */
+	if (priv->can.state == CAN_STATE_BUS_OFF) {
+		*bec = priv->bec;
+		return 0;
+	}
+
+	return __mcp251xfd_get_berr_counter(ndev, bec);
+}
+
+static int mcp251xfd_check_tef_tail(const struct mcp251xfd_priv *priv)
+{
+	u8 tef_tail_chip, tef_tail;
+	int err;
+
+	if (!IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY))
+		return 0;
+
+	err = mcp251xfd_tef_tail_get_from_chip(priv, &tef_tail_chip);
+	if (err)
+		return err;
+
+	tef_tail = mcp251xfd_get_tef_tail(priv);
+	if (tef_tail_chip != tef_tail) {
+		netdev_err(priv->ndev,
+			   "TEF tail of chip (0x%02x) and ours (0x%08x) inconsistent.\n",
+			   tef_tail_chip, tef_tail);
+		return -EILSEQ;
+	}
+
+	return 0;
+}
+
+static int
+mcp251xfd_check_rx_tail(const struct mcp251xfd_priv *priv,
+			const struct mcp251xfd_rx_ring *ring)
+{
+	u8 rx_tail_chip, rx_tail;
+	int err;
+
+	if (!IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY))
+		return 0;
+
+	err = mcp251xfd_rx_tail_get_from_chip(priv, ring, &rx_tail_chip);
+	if (err)
+		return err;
+
+	rx_tail = mcp251xfd_get_rx_tail(ring);
+	if (rx_tail_chip != rx_tail) {
+		netdev_err(priv->ndev,
+			   "RX tail of chip (%d) and ours (%d) inconsistent.\n",
+			   rx_tail_chip, rx_tail);
+		return -EILSEQ;
+	}
+
+	return 0;
+}
+
+static int
+mcp251xfd_handle_tefif_recover(const struct mcp251xfd_priv *priv, const u32 seq)
+{
+	const struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+	u32 tef_sta;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_TEFSTA, &tef_sta);
+	if (err)
+		return err;
+
+	if (tef_sta & MCP251XFD_REG_TEFSTA_TEFOVIF) {
+		netdev_err(priv->ndev,
+			   "Transmit Event FIFO buffer overflow.\n");
+		return -ENOBUFS;
+	}
+
+	netdev_info(priv->ndev,
+		    "Transmit Event FIFO buffer %s. (seq=0x%08x, tef_tail=0x%08x, tef_head=0x%08x, tx_head=0x%08x)\n",
+		    tef_sta & MCP251XFD_REG_TEFSTA_TEFFIF ?
+		    "full" : tef_sta & MCP251XFD_REG_TEFSTA_TEFNEIF ?
+		    "not empty" : "empty",
+		    seq, priv->tef.tail, priv->tef.head, tx_ring->head);
+
+	/* The Sequence Number in the TEF doesn't match our tef_tail. */
+	return -EAGAIN;
+}
+
+static int
+mcp251xfd_handle_tefif_one(struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_hw_tef_obj *hw_tef_obj)
+{
+	struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+	struct net_device_stats *stats = &priv->ndev->stats;
+	u32 seq, seq_masked, tef_tail_masked;
+	int err;
+
+	seq = FIELD_GET(MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
+			hw_tef_obj->flags);
+
+	/* Use the MCP2517FD mask on the MCP2518FD, too. We only
+	 * compare 7 bits, this should be enough to detect
+	 * net-yet-completed, i.e. old TEF objects.
+	 */
+	seq_masked = seq &
+		field_mask(MCP251XFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
+	tef_tail_masked = priv->tef.tail &
+		field_mask(MCP251XFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
+	if (seq_masked != tef_tail_masked)
+		return mcp251xfd_handle_tefif_recover(priv, seq);
+
+	stats->tx_bytes +=
+		can_rx_offload_get_echo_skb(&priv->offload,
+					    mcp251xfd_get_tef_tail(priv),
+					    hw_tef_obj->ts);
+	stats->tx_packets++;
+
+	/* finally increment the TEF pointer */
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_TEFCON,
+				 GENMASK(15, 8),
+				 MCP251XFD_REG_TEFCON_UINC);
+	if (err)
+		return err;
+
+	priv->tef.tail++;
+	tx_ring->tail++;
+
+	return mcp251xfd_check_tef_tail(priv);
+}
+
+static int mcp251xfd_tef_ring_update(struct mcp251xfd_priv *priv)
+{
+	const struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+	unsigned int new_head;
+	u8 chip_tx_tail;
+	int err;
+
+	err = mcp251xfd_tx_tail_get_from_chip(priv, &chip_tx_tail);
+	if (err)
+		return err;
+
+	/* chip_tx_tail, is the next TX-Object send by the HW.
+	 * The new TEF head must be >= the old head, ...
+	 */
+	new_head = round_down(priv->tef.head, tx_ring->obj_num) + chip_tx_tail;
+	if (new_head <= priv->tef.head)
+		new_head += tx_ring->obj_num;
+
+	/* ... but it cannot exceed the TX head. */
+	priv->tef.head = min(new_head, tx_ring->head);
+
+	return mcp251xfd_check_tef_tail(priv);
+}
+
+static inline int
+mcp251xfd_tef_obj_read(const struct mcp251xfd_priv *priv,
+		       struct mcp251xfd_hw_tef_obj *hw_tef_obj,
+		       const u8 offset, const u8 len)
+{
+	const struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+
+	if (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&
+	    (offset > tx_ring->obj_num ||
+	     len > tx_ring->obj_num ||
+	     offset + len > tx_ring->obj_num)) {
+		netdev_err(priv->ndev,
+			   "Trying to read to many TEF objects (max=%d, offset=%d, len=%d).\n",
+			   tx_ring->obj_num, offset, len);
+		return -ERANGE;
+	}
+
+	return regmap_bulk_read(priv->map_rx,
+				mcp251xfd_get_tef_obj_addr(offset),
+				hw_tef_obj,
+				sizeof(*hw_tef_obj) / sizeof(u32) * len);
+}
+
+static int mcp251xfd_handle_tefif(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_hw_tef_obj hw_tef_obj[MCP251XFD_TX_OBJ_NUM_MAX];
+	u8 tef_tail, len, l;
+	int err, i;
+
+	err = mcp251xfd_tef_ring_update(priv);
+	if (err)
+		return err;
+
+	tef_tail = mcp251xfd_get_tef_tail(priv);
+	len = mcp251xfd_get_tef_len(priv);
+	l = mcp251xfd_get_tef_linear_len(priv);
+	err = mcp251xfd_tef_obj_read(priv, hw_tef_obj, tef_tail, l);
+	if (err)
+		return err;
+
+	if (l < len) {
+		err = mcp251xfd_tef_obj_read(priv, &hw_tef_obj[l], 0, len - l);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < len; i++) {
+		err = mcp251xfd_handle_tefif_one(priv, &hw_tef_obj[i]);
+		/* -EAGAIN means the Sequence Number in the TEF
+		 * doesn't match our tef_tail. This can happen if we
+		 * read the TEF objects too early. Leave loop let the
+		 * interrupt handler call us again.
+		 */
+		if (err == -EAGAIN)
+			goto out_netif_wake_queue;
+		if (err)
+			return err;
+	}
+
+ out_netif_wake_queue:
+	mcp251xfd_ecc_tefif_successful(priv);
+
+	if (mcp251xfd_get_tx_free(priv->tx)) {
+		/* Make sure that anybody stopping the queue after
+		 * this sees the new tx_ring->tail.
+		 */
+		smp_mb();
+		netif_wake_queue(priv->ndev);
+	}
+
+	return 0;
+}
+
+static int
+mcp251xfd_rx_ring_update(const struct mcp251xfd_priv *priv,
+			 struct mcp251xfd_rx_ring *ring)
+{
+	u32 new_head;
+	u8 chip_rx_head;
+	int err;
+
+	err = mcp251xfd_rx_head_get_from_chip(priv, ring, &chip_rx_head);
+	if (err)
+		return err;
+
+	/* chip_rx_head, is the next RX-Object filled by the HW.
+	 * The new RX head must be >= the old head.
+	 */
+	new_head = round_down(ring->head, ring->obj_num) + chip_rx_head;
+	if (new_head <= ring->head)
+		new_head += ring->obj_num;
+
+	ring->head = new_head;
+
+	return mcp251xfd_check_rx_tail(priv, ring);
+}
+
+static void
+mcp251xfd_hw_rx_obj_to_skb(const struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj,
+			   struct sk_buff *skb)
+{
+	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+
+	if (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_IDE) {
+		u32 sid, eid;
+
+		eid = FIELD_GET(MCP251XFD_OBJ_ID_EID_MASK, hw_rx_obj->id);
+		sid = FIELD_GET(MCP251XFD_OBJ_ID_SID_MASK, hw_rx_obj->id);
+
+		cfd->can_id = CAN_EFF_FLAG |
+			FIELD_PREP(MCP251XFD_REG_FRAME_EFF_EID_MASK, eid) |
+			FIELD_PREP(MCP251XFD_REG_FRAME_EFF_SID_MASK, sid);
+	} else {
+		cfd->can_id = FIELD_GET(MCP251XFD_OBJ_ID_SID_MASK,
+					hw_rx_obj->id);
+	}
+
+	/* CANFD */
+	if (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_FDF) {
+		u8 dlc;
+
+		if (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_ESI)
+			cfd->flags |= CANFD_ESI;
+
+		if (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_BRS)
+			cfd->flags |= CANFD_BRS;
+
+		dlc = FIELD_GET(MCP251XFD_OBJ_FLAGS_DLC, hw_rx_obj->flags);
+		cfd->len = can_dlc2len(get_canfd_dlc(dlc));
+	} else {
+		if (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_RTR)
+			cfd->can_id |= CAN_RTR_FLAG;
+
+		cfd->len = get_can_dlc(FIELD_GET(MCP251XFD_OBJ_FLAGS_DLC,
+						 hw_rx_obj->flags));
+	}
+
+	memcpy(cfd->data, hw_rx_obj->data, cfd->len);
+}
+
+static int
+mcp251xfd_handle_rxif_one(struct mcp251xfd_priv *priv,
+			  struct mcp251xfd_rx_ring *ring,
+			  const struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct canfd_frame *cfd;
+	int err;
+
+	if (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_FDF)
+		skb = alloc_canfd_skb(priv->ndev, &cfd);
+	else
+		skb = alloc_can_skb(priv->ndev, (struct can_frame **)&cfd);
+
+	if (!cfd) {
+		stats->rx_dropped++;
+		return 0;
+	}
+
+	mcp251xfd_hw_rx_obj_to_skb(priv, hw_rx_obj, skb);
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, hw_rx_obj->ts);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	ring->tail++;
+
+	/* finally increment the RX pointer */
+	return regmap_update_bits(priv->map_reg,
+				  MCP251XFD_REG_FIFOCON(ring->fifo_nr),
+				  GENMASK(15, 8),
+				  MCP251XFD_REG_FIFOCON_UINC);
+}
+
+static inline int
+mcp251xfd_rx_obj_read(const struct mcp251xfd_priv *priv,
+		      const struct mcp251xfd_rx_ring *ring,
+		      struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj,
+		      const u8 offset, const u8 len)
+{
+	int err;
+
+	err = regmap_bulk_read(priv->map_rx,
+			       mcp251xfd_get_rx_obj_addr(ring, offset),
+			       hw_rx_obj,
+			       len * ring->obj_size / sizeof(u32));
+
+	return err;
+}
+
+static int
+mcp251xfd_handle_rxif_ring(struct mcp251xfd_priv *priv,
+			   struct mcp251xfd_rx_ring *ring)
+{
+	struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj = ring->obj;
+	u8 rx_tail, len;
+	int err, i;
+
+	err = mcp251xfd_rx_ring_update(priv, ring);
+	if (err)
+		return err;
+
+	while ((len = mcp251xfd_get_rx_linear_len(ring))) {
+		rx_tail = mcp251xfd_get_rx_tail(ring);
+
+		err = mcp251xfd_rx_obj_read(priv, ring, hw_rx_obj,
+					    rx_tail, len);
+		if (err)
+			return err;
+
+		for (i = 0; i < len; i++) {
+			err = mcp251xfd_handle_rxif_one(priv, ring,
+							(void *)hw_rx_obj +
+							i * ring->obj_size);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int mcp251xfd_handle_rxif(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_rx_ring *ring;
+	int err, n;
+
+	mcp251xfd_for_each_rx_ring(priv, ring, n) {
+		err = mcp251xfd_handle_rxif_ring(priv, ring);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static inline int mcp251xfd_get_timestamp(const struct mcp251xfd_priv *priv,
+					  u32 *timestamp)
+{
+	return regmap_read(priv->map_reg, MCP251XFD_REG_TBC, timestamp);
+}
+
+static struct sk_buff *
+mcp251xfd_alloc_can_err_skb(const struct mcp251xfd_priv *priv,
+			    struct can_frame **cf, u32 *timestamp)
+{
+	int err;
+
+	err = mcp251xfd_get_timestamp(priv, timestamp);
+	if (err)
+		return NULL;
+
+	return alloc_can_err_skb(priv->ndev, cf);
+}
+
+static int mcp251xfd_handle_rxovif(struct mcp251xfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct mcp251xfd_rx_ring *ring;
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	u32 timestamp, rxovif;
+	int err, i;
+
+	stats->rx_over_errors++;
+	stats->rx_errors++;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_RXOVIF, &rxovif);
+	if (err)
+		return err;
+
+	mcp251xfd_for_each_rx_ring(priv, ring, i) {
+		if (!(rxovif & BIT(ring->fifo_nr)))
+			continue;
+
+		/* If SERRIF is active, there was a RX MAB overflow. */
+		if (priv->regs_status.intf & MCP251XFD_REG_INT_SERRIF) {
+			netdev_info(priv->ndev,
+				    "RX-%d: MAB overflow detected.\n",
+				    ring->nr);
+		} else {
+			netdev_info(priv->ndev,
+				    "RX-%d: FIFO overflow.\n", ring->nr);
+		}
+
+		err = regmap_update_bits(priv->map_reg,
+					 MCP251XFD_REG_FIFOSTA(ring->fifo_nr),
+					 MCP251XFD_REG_FIFOSTA_RXOVIF,
+					 0x0);
+		if (err)
+			return err;
+	}
+
+	skb = mcp251xfd_alloc_can_err_skb(priv, &cf, &timestamp);
+	if (!skb)
+		return 0;
+
+	cf->can_id |= CAN_ERR_CRTL;
+	cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp251xfd_handle_txatif(struct mcp251xfd_priv *priv)
+{
+	netdev_info(priv->ndev, "%s\n", __func__);
+
+	return 0;
+}
+
+static int mcp251xfd_handle_ivmif(struct mcp251xfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	u32 bdiag1, timestamp;
+	struct sk_buff *skb;
+	struct can_frame *cf = NULL;
+	int err;
+
+	err = mcp251xfd_get_timestamp(priv, &timestamp);
+	if (err)
+		return err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_BDIAG1, &bdiag1);
+	if (err)
+		return err;
+
+	/* Write 0s to clear error bits, don't write 1s to non active
+	 * bits, as they will be set.
+	 */
+	err = regmap_write(priv->map_reg, MCP251XFD_REG_BDIAG1, 0x0);
+	if (err)
+		return err;
+
+	priv->can.can_stats.bus_error++;
+
+	skb = alloc_can_err_skb(priv->ndev, &cf);
+	if (cf)
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+
+	/* Controller misconfiguration */
+	if (WARN_ON(bdiag1 & MCP251XFD_REG_BDIAG1_DLCMM))
+		netdev_err(priv->ndev,
+			   "recv'd DLC is larger than PLSIZE of FIFO element.");
+
+	/* RX errors */
+	if (bdiag1 & (MCP251XFD_REG_BDIAG1_DCRCERR |
+		      MCP251XFD_REG_BDIAG1_NCRCERR)) {
+		netdev_dbg(priv->ndev, "CRC error\n");
+
+		stats->rx_errors++;
+		if (cf)
+			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+	}
+	if (bdiag1 & (MCP251XFD_REG_BDIAG1_DSTUFERR |
+		      MCP251XFD_REG_BDIAG1_NSTUFERR)) {
+		netdev_dbg(priv->ndev, "Stuff error\n");
+
+		stats->rx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+	}
+	if (bdiag1 & (MCP251XFD_REG_BDIAG1_DFORMERR |
+		      MCP251XFD_REG_BDIAG1_NFORMERR)) {
+		netdev_dbg(priv->ndev, "Format error\n");
+
+		stats->rx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+	}
+
+	/* TX errors */
+	if (bdiag1 & MCP251XFD_REG_BDIAG1_NACKERR) {
+		netdev_dbg(priv->ndev, "NACK error\n");
+
+		stats->tx_errors++;
+		if (cf) {
+			cf->can_id |= CAN_ERR_ACK;
+			cf->data[2] |= CAN_ERR_PROT_TX;
+		}
+	}
+	if (bdiag1 & (MCP251XFD_REG_BDIAG1_DBIT1ERR |
+		      MCP251XFD_REG_BDIAG1_NBIT1ERR)) {
+		netdev_dbg(priv->ndev, "Bit1 error\n");
+
+		stats->tx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT1;
+	}
+	if (bdiag1 & (MCP251XFD_REG_BDIAG1_DBIT0ERR |
+		      MCP251XFD_REG_BDIAG1_NBIT0ERR)) {
+		netdev_dbg(priv->ndev, "Bit0 error\n");
+
+		stats->tx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT0;
+	}
+
+	if (!cf)
+		return 0;
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp251xfd_handle_cerrif(struct mcp251xfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf = NULL;
+	enum can_state new_state, rx_state, tx_state;
+	u32 trec, timestamp;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_TREC, &trec);
+	if (err)
+		return err;
+
+	if (trec & MCP251XFD_REG_TREC_TXBO)
+		tx_state = CAN_STATE_BUS_OFF;
+	else if (trec & MCP251XFD_REG_TREC_TXBP)
+		tx_state = CAN_STATE_ERROR_PASSIVE;
+	else if (trec & MCP251XFD_REG_TREC_TXWARN)
+		tx_state = CAN_STATE_ERROR_WARNING;
+	else
+		tx_state = CAN_STATE_ERROR_ACTIVE;
+
+	if (trec & MCP251XFD_REG_TREC_RXBP)
+		rx_state = CAN_STATE_ERROR_PASSIVE;
+	else if (trec & MCP251XFD_REG_TREC_RXWARN)
+		rx_state = CAN_STATE_ERROR_WARNING;
+	else
+		rx_state = CAN_STATE_ERROR_ACTIVE;
+
+	new_state = max(tx_state, rx_state);
+	if (new_state == priv->can.state)
+		return 0;
+
+	/* The skb allocation might fail, but can_change_state()
+	 * handles cf == NULL.
+	 */
+	skb = mcp251xfd_alloc_can_err_skb(priv, &cf, &timestamp);
+	can_change_state(priv->ndev, cf, tx_state, rx_state);
+
+	if (new_state == CAN_STATE_BUS_OFF) {
+		/* As we're going to switch off the chip now, let's
+		 * save the error counters and return them to
+		 * userspace, if do_get_berr_counter() is called while
+		 * the chip is in Bus Off.
+		 */
+		err = __mcp251xfd_get_berr_counter(priv->ndev, &priv->bec);
+		if (err)
+			return err;
+
+		mcp251xfd_chip_stop(priv, CAN_STATE_BUS_OFF);
+		can_bus_off(priv->ndev);
+	}
+
+	if (!skb)
+		return 0;
+
+	if (new_state != CAN_STATE_BUS_OFF) {
+		struct can_berr_counter bec;
+
+		err = mcp251xfd_get_berr_counter(priv->ndev, &bec);
+		if (err)
+			return err;
+		cf->data[6] = bec.txerr;
+		cf->data[7] = bec.rxerr;
+	}
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int
+mcp251xfd_handle_modif(const struct mcp251xfd_priv *priv, bool *set_normal_mode)
+{
+	const u8 mode_reference = mcp251xfd_get_normal_mode(priv);
+	u8 mode;
+	int err;
+
+	err = mcp251xfd_chip_get_mode(priv, &mode);
+	if (err)
+		return err;
+
+	if (mode == mode_reference) {
+		netdev_dbg(priv->ndev,
+			   "Controller changed into %s Mode (%u).\n",
+			   mcp251xfd_get_mode_str(mode), mode);
+		return 0;
+	}
+
+	/* According to MCP2517FD errata DS80000792B 1., during a TX
+	 * MAB underflow, the controller will transition to Restricted
+	 * Operation Mode or Listen Only Mode (depending on SERR2LOM).
+	 *
+	 * However this is not always the case. If SERR2LOM is
+	 * configured for Restricted Operation Mode (SERR2LOM not set)
+	 * the MCP2517FD will sometimes transition to Listen Only Mode
+	 * first. When polling this bit we see that it will transition
+	 * to Restricted Operation Mode shortly after.
+	 */
+	if ((priv->devtype_data.quirks & MCP251XFD_QUIRK_MAB_NO_WARN) &&
+	    (mode == MCP251XFD_REG_CON_MODE_RESTRICTED ||
+	     mode == MCP251XFD_REG_CON_MODE_LISTENONLY))
+		netdev_dbg(priv->ndev,
+			   "Controller changed into %s Mode (%u).\n",
+			   mcp251xfd_get_mode_str(mode), mode);
+	else
+		netdev_err(priv->ndev,
+			   "Controller changed into %s Mode (%u).\n",
+			   mcp251xfd_get_mode_str(mode), mode);
+
+	/* After the application requests Normal mode, the Controller
+	 * will automatically attempt to retransmit the message that
+	 * caused the TX MAB underflow.
+	 *
+	 * However, if there is an ECC error in the TX-RAM, we first
+	 * have to reload the tx-object before requesting Normal
+	 * mode. This is done later in mcp251xfd_handle_eccif().
+	 */
+	if (priv->regs_status.intf & MCP251XFD_REG_INT_ECCIF) {
+		*set_normal_mode = true;
+		return 0;
+	}
+
+	return mcp251xfd_chip_set_normal_mode_nowait(priv);
+}
+
+static int mcp251xfd_handle_serrif(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_ecc *ecc = &priv->ecc;
+	struct net_device_stats *stats = &priv->ndev->stats;
+	bool handled = false;
+
+	/* TX MAB underflow
+	 *
+	 * According to MCP2517FD Errata DS80000792B 1. a TX MAB
+	 * underflow is indicated by SERRIF and MODIF.
+	 *
+	 * In addition to the effects mentioned in the Errata, there
+	 * are Bus Errors due to the aborted CAN frame, so a IVMIF
+	 * will be seen as well.
+	 *
+	 * Sometimes there is an ECC error in the TX-RAM, which leads
+	 * to a TX MAB underflow.
+	 *
+	 * However, probably due to a race condition, there is no
+	 * associated MODIF pending.
+	 *
+	 * Further, there are situations, where the SERRIF is caused
+	 * by an ECC error in the TX-RAM, but not even the ECCIF is
+	 * set. This only seems to happen _after_ the first occurrence
+	 * of a ECCIF (which is tracked in ecc->cnt).
+	 *
+	 * Treat all as a known system errors..
+	 */
+	if ((priv->regs_status.intf & MCP251XFD_REG_INT_MODIF &&
+	     priv->regs_status.intf & MCP251XFD_REG_INT_IVMIF) ||
+	    priv->regs_status.intf & MCP251XFD_REG_INT_ECCIF ||
+	    ecc->cnt) {
+		const char *msg;
+
+		if (priv->regs_status.intf & MCP251XFD_REG_INT_ECCIF ||
+		    ecc->cnt)
+			msg = "TX MAB underflow due to ECC error detected.";
+		else
+			msg = "TX MAB underflow detected.";
+
+		if (priv->devtype_data.quirks & MCP251XFD_QUIRK_MAB_NO_WARN)
+			netdev_dbg(priv->ndev, "%s\n", msg);
+		else
+			netdev_info(priv->ndev, "%s\n", msg);
+
+		stats->tx_aborted_errors++;
+		stats->tx_errors++;
+		handled = true;
+	}
+
+	/* RX MAB overflow
+	 *
+	 * According to MCP2517FD Errata DS80000792B 1. a RX MAB
+	 * overflow is indicated by SERRIF.
+	 *
+	 * In addition to the effects mentioned in the Errata, (most
+	 * of the times) a RXOVIF is raised, if the FIFO that is being
+	 * received into has the RXOVIE activated (and we have enabled
+	 * RXOVIE on all FIFOs).
+	 *
+	 * Sometimes there is no RXOVIF just a RXIF is pending.
+	 *
+	 * Treat all as a known system errors..
+	 */
+	if (priv->regs_status.intf & MCP251XFD_REG_INT_RXOVIF ||
+	    priv->regs_status.intf & MCP251XFD_REG_INT_RXIF) {
+		stats->rx_dropped++;
+		handled = true;
+	}
+
+	if (!handled)
+		netdev_err(priv->ndev,
+			   "Unhandled System Error Interrupt (intf=0x%08x)!\n",
+			   priv->regs_status.intf);
+
+	return 0;
+}
+
+static int
+mcp251xfd_handle_eccif_recover(struct mcp251xfd_priv *priv, u8 nr)
+{
+	struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+	struct mcp251xfd_ecc *ecc = &priv->ecc;
+	struct mcp251xfd_tx_obj *tx_obj;
+	u8 chip_tx_tail, tx_tail, offset;
+	u16 addr;
+	int err;
+
+	addr = FIELD_GET(MCP251XFD_REG_ECCSTAT_ERRADDR_MASK, ecc->ecc_stat);
+
+	err = mcp251xfd_tx_tail_get_from_chip(priv, &chip_tx_tail);
+	if (err)
+		return err;
+
+	tx_tail = mcp251xfd_get_tx_tail(tx_ring);
+	offset = (nr - chip_tx_tail) & (tx_ring->obj_num - 1);
+
+	/* Bail out if one of the following is met:
+	 * - tx_tail information is inconsistent
+	 * - for mcp2517fd: offset not 0
+	 * - for mcp2518fd: offset not 0 or 1
+	 */
+	if (chip_tx_tail != tx_tail ||
+	    !(offset == 0 || (offset == 1 && mcp251xfd_is_2518(priv)))) {
+		netdev_err(priv->ndev,
+			   "ECC Error information inconsistent (addr=0x%04x, nr=%d, tx_tail=0x%08x(%d), chip_tx_tail=%d, offset=%d).\n",
+			   addr, nr, tx_ring->tail, tx_tail, chip_tx_tail,
+			   offset);
+		return -EINVAL;
+	}
+
+	netdev_info(priv->ndev,
+		    "Recovering %s ECC Error at address 0x%04x (in TX-RAM, tx_obj=%d, tx_tail=0x%08x(%d), offset=%d).\n",
+		    ecc->ecc_stat & MCP251XFD_REG_ECCSTAT_SECIF ?
+		    "Single" : "Double",
+		    addr, nr, tx_ring->tail, tx_tail, offset);
+
+	/* reload tx_obj into controller RAM ... */
+	tx_obj = &tx_ring->obj[nr];
+	err = spi_sync_transfer(priv->spi, tx_obj->xfer, 1);
+	if (err)
+		return err;
+
+	/* ... and trigger retransmit */
+	return mcp251xfd_chip_set_normal_mode(priv);
+}
+
+static int
+mcp251xfd_handle_eccif(struct mcp251xfd_priv *priv, bool set_normal_mode)
+{
+	struct mcp251xfd_ecc *ecc = &priv->ecc;
+	const char *msg;
+	bool in_tx_ram;
+	u32 ecc_stat;
+	u16 addr;
+	u8 nr;
+	int err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_ECCSTAT, &ecc_stat);
+	if (err)
+		return err;
+
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCSTAT,
+				 MCP251XFD_REG_ECCSTAT_IF_MASK, ~ecc_stat);
+	if (err)
+		return err;
+
+	/* Check if ECC error occurred in TX-RAM */
+	addr = FIELD_GET(MCP251XFD_REG_ECCSTAT_ERRADDR_MASK, ecc_stat);
+	err = mcp251xfd_get_tx_nr_by_addr(priv->tx, &nr, addr);
+	if (!err)
+		in_tx_ram = true;
+	else if (err == -ENOENT)
+		in_tx_ram = false;
+	else
+		return err;
+
+	/* Errata Reference:
+	 * mcp2517fd: DS80000789B, mcp2518fd: DS80000792C 2.
+	 *
+	 * ECC single error correction does not work in all cases:
+	 *
+	 * Fix/Work Around:
+	 * Enable single error correction and double error detection
+	 * interrupts by setting SECIE and DEDIE. Handle SECIF as a
+	 * detection interrupt and do not rely on the error
+	 * correction. Instead, handle both interrupts as a
+	 * notification that the RAM word at ERRADDR was corrupted.
+	 */
+	if (ecc_stat & MCP251XFD_REG_ECCSTAT_SECIF)
+		msg = "Single ECC Error detected at address";
+	else if (ecc_stat & MCP251XFD_REG_ECCSTAT_DEDIF)
+		msg = "Double ECC Error detected at address";
+	else
+		return -EINVAL;
+
+	if (!in_tx_ram) {
+		ecc->ecc_stat = 0;
+
+		netdev_notice(priv->ndev, "%s 0x%04x.\n", msg, addr);
+	} else {
+		/* Re-occurring error? */
+		if (ecc->ecc_stat == ecc_stat) {
+			ecc->cnt++;
+		} else {
+			ecc->ecc_stat = ecc_stat;
+			ecc->cnt = 1;
+		}
+
+		netdev_info(priv->ndev,
+			    "%s 0x%04x (in TX-RAM, tx_obj=%d), occurred %d time%s.\n",
+			    msg, addr, nr, ecc->cnt, ecc->cnt > 1 ? "s" : "");
+
+		if (ecc->cnt >= MCP251XFD_ECC_CNT_MAX)
+			return mcp251xfd_handle_eccif_recover(priv, nr);
+	}
+
+	if (set_normal_mode)
+		return mcp251xfd_chip_set_normal_mode_nowait(priv);
+
+	return 0;
+}
+
+static int mcp251xfd_handle_spicrcif(struct mcp251xfd_priv *priv)
+{
+	int err;
+	u32 crc;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_CRC, &crc);
+	if (err)
+		return err;
+
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_CRC,
+				 MCP251XFD_REG_CRC_IF_MASK,
+				 ~crc);
+	if (err)
+		return err;
+
+	if (crc & MCP251XFD_REG_CRC_FERRIF)
+		netdev_notice(priv->ndev, "CRC write command format error.\n");
+	else if (crc & MCP251XFD_REG_CRC_CRCERRIF)
+		netdev_notice(priv->ndev,
+			      "CRC write error detected. CRC=0x%04lx.\n",
+			      FIELD_GET(MCP251XFD_REG_CRC_MASK, crc));
+
+	return 0;
+}
+
+#define mcp251xfd_handle(priv, irq, ...) \
+({ \
+	struct mcp251xfd_priv *_priv = (priv); \
+	int err; \
+\
+	err = mcp251xfd_handle_##irq(_priv, ## __VA_ARGS__); \
+	if (err) \
+		netdev_err(_priv->ndev, \
+			"IRQ handler mcp251xfd_handle_%s() returned %d.\n", \
+			__stringify(irq), err); \
+	err; \
+})
+
+static irqreturn_t mcp251xfd_irq(int irq, void *dev_id)
+{
+	struct mcp251xfd_priv *priv = dev_id;
+	irqreturn_t handled = IRQ_NONE;
+	int err;
+
+	if (priv->rx_int)
+		do {
+			int rx_pending;
+
+			rx_pending = gpiod_get_value_cansleep(priv->rx_int);
+			if (!rx_pending)
+				break;
+
+			err = mcp251xfd_handle(priv, rxif);
+			if (err)
+				goto out_fail;
+
+			handled = IRQ_HANDLED;
+		} while (1);
+
+	do {
+		u32 intf_pending, intf_pending_clearable;
+		bool set_normal_mode = false;
+
+		err = regmap_bulk_read(priv->map_reg, MCP251XFD_REG_INT,
+				       &priv->regs_status,
+				       sizeof(priv->regs_status) /
+				       sizeof(u32));
+		if (err)
+			goto out_fail;
+
+		intf_pending = FIELD_GET(MCP251XFD_REG_INT_IF_MASK,
+					 priv->regs_status.intf) &
+			FIELD_GET(MCP251XFD_REG_INT_IE_MASK,
+				  priv->regs_status.intf);
+
+		if (!(intf_pending))
+			return handled;
+
+		/* Some interrupts must be ACKed in the
+		 * MCP251XFD_REG_INT register.
+		 * - First ACK then handle, to avoid lost-IRQ race
+		 *   condition on fast re-occurring interrupts.
+		 * - Write "0" to clear active IRQs, "1" to all other,
+		 *   to avoid r/m/w race condition on the
+		 *   MCP251XFD_REG_INT register.
+		 */
+		intf_pending_clearable = intf_pending &
+			MCP251XFD_REG_INT_IF_CLEARABLE_MASK;
+		if (intf_pending_clearable) {
+			err = regmap_update_bits(priv->map_reg,
+						 MCP251XFD_REG_INT,
+						 MCP251XFD_REG_INT_IF_MASK,
+						 ~intf_pending_clearable);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_MODIF) {
+			err = mcp251xfd_handle(priv, modif, &set_normal_mode);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_RXIF) {
+			err = mcp251xfd_handle(priv, rxif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_TEFIF) {
+			err = mcp251xfd_handle(priv, tefif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_RXOVIF) {
+			err = mcp251xfd_handle(priv, rxovif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_TXATIF) {
+			err = mcp251xfd_handle(priv, txatif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_IVMIF) {
+			err = mcp251xfd_handle(priv, ivmif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_SERRIF) {
+			err = mcp251xfd_handle(priv, serrif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_ECCIF) {
+			err = mcp251xfd_handle(priv, eccif, set_normal_mode);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP251XFD_REG_INT_SPICRCIF) {
+			err = mcp251xfd_handle(priv, spicrcif);
+			if (err)
+				goto out_fail;
+		}
+
+		/* On the MCP2527FD and MCP2518FD, we don't get a
+		 * CERRIF IRQ on the transition TX ERROR_WARNING -> TX
+		 * ERROR_ACTIVE.
+		 */
+		if (intf_pending & MCP251XFD_REG_INT_CERRIF ||
+		    priv->can.state > CAN_STATE_ERROR_ACTIVE) {
+			err = mcp251xfd_handle(priv, cerrif);
+			if (err)
+				goto out_fail;
+
+			/* In Bus Off we completely shut down the
+			 * controller. Every subsequent register read
+			 * will read bogus data, and if
+			 * MCP251XFD_QUIRK_CRC_REG is enabled the CRC
+			 * check will fail, too. So leave IRQ handler
+			 * directly.
+			 */
+			if (priv->can.state == CAN_STATE_BUS_OFF)
+				return IRQ_HANDLED;
+		}
+
+		handled = IRQ_HANDLED;
+	} while (1);
+
+ out_fail:
+	netdev_err(priv->ndev, "IRQ handler returned %d (intf=0x%08x).\n",
+		   err, priv->regs_status.intf);
+	mcp251xfd_chip_interrupts_disable(priv);
+
+	return handled;
+}
+
+static inline struct
+mcp251xfd_tx_obj *mcp251xfd_get_tx_obj_next(struct mcp251xfd_tx_ring *tx_ring)
+{
+	u8 tx_head;
+
+	tx_head = mcp251xfd_get_tx_head(tx_ring);
+
+	return &tx_ring->obj[tx_head];
+}
+
+static void
+mcp251xfd_tx_obj_from_skb(const struct mcp251xfd_priv *priv,
+			  struct mcp251xfd_tx_obj *tx_obj,
+			  const struct sk_buff *skb,
+			  unsigned int seq)
+{
+	const struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+	struct mcp251xfd_hw_tx_obj_raw *hw_tx_obj;
+	union mcp251xfd_tx_obj_load_buf *load_buf;
+	u8 dlc;
+	u32 id, flags;
+	int offset, len;
+
+	if (cfd->can_id & CAN_EFF_FLAG) {
+		u32 sid, eid;
+
+		sid = FIELD_GET(MCP251XFD_REG_FRAME_EFF_SID_MASK, cfd->can_id);
+		eid = FIELD_GET(MCP251XFD_REG_FRAME_EFF_EID_MASK, cfd->can_id);
+
+		id = FIELD_PREP(MCP251XFD_OBJ_ID_EID_MASK, eid) |
+			FIELD_PREP(MCP251XFD_OBJ_ID_SID_MASK, sid);
+
+		flags = MCP251XFD_OBJ_FLAGS_IDE;
+	} else {
+		id = FIELD_PREP(MCP251XFD_OBJ_ID_SID_MASK, cfd->can_id);
+		flags = 0;
+	}
+
+	/* Use the MCP2518FD mask even on the MCP2517FD. It doesn't
+	 * harm, only the lower 7 bits will be transferred into the
+	 * TEF object.
+	 */
+	dlc = can_len2dlc(cfd->len);
+	flags |= FIELD_PREP(MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK, seq) |
+		FIELD_PREP(MCP251XFD_OBJ_FLAGS_DLC, dlc);
+
+	if (cfd->can_id & CAN_RTR_FLAG)
+		flags |= MCP251XFD_OBJ_FLAGS_RTR;
+
+	/* CANFD */
+	if (can_is_canfd_skb(skb)) {
+		if (cfd->flags & CANFD_ESI)
+			flags |= MCP251XFD_OBJ_FLAGS_ESI;
+
+		flags |= MCP251XFD_OBJ_FLAGS_FDF;
+
+		if (cfd->flags & CANFD_BRS)
+			flags |= MCP251XFD_OBJ_FLAGS_BRS;
+	}
+
+	load_buf = &tx_obj->buf;
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_TX)
+		hw_tx_obj = &load_buf->crc.hw_tx_obj;
+	else
+		hw_tx_obj = &load_buf->nocrc.hw_tx_obj;
+
+	put_unaligned_le32(id, &hw_tx_obj->id);
+	put_unaligned_le32(flags, &hw_tx_obj->flags);
+
+	/* Clear data at end of CAN frame */
+	offset = round_down(cfd->len, sizeof(u32));
+	len = round_up(can_dlc2len(dlc), sizeof(u32)) - offset;
+	if (MCP251XFD_SANITIZE_CAN && len)
+		memset(hw_tx_obj->data + offset, 0x0, len);
+	memcpy(hw_tx_obj->data, cfd->data, cfd->len);
+
+	/* Number of bytes to be written into the RAM of the controller */
+	len = sizeof(hw_tx_obj->id) + sizeof(hw_tx_obj->flags);
+	if (MCP251XFD_SANITIZE_CAN)
+		len += round_up(can_dlc2len(dlc), sizeof(u32));
+	else
+		len += round_up(cfd->len, sizeof(u32));
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_TX) {
+		u16 crc;
+
+		mcp251xfd_spi_cmd_crc_set_len_in_ram(&load_buf->crc.cmd,
+						     len);
+		/* CRC */
+		len += sizeof(load_buf->crc.cmd);
+		crc = mcp251xfd_crc16_compute(&load_buf->crc, len);
+		put_unaligned_be16(crc, (void *)load_buf + len);
+
+		/* Total length */
+		len += sizeof(load_buf->crc.crc);
+	} else {
+		len += sizeof(load_buf->nocrc.cmd);
+	}
+
+	tx_obj->xfer[0].len = len;
+}
+
+static int mcp251xfd_tx_obj_write(const struct mcp251xfd_priv *priv,
+				  struct mcp251xfd_tx_obj *tx_obj)
+{
+	return spi_async(priv->spi, &tx_obj->msg);
+}
+
+static bool mcp251xfd_tx_busy(const struct mcp251xfd_priv *priv,
+			      struct mcp251xfd_tx_ring *tx_ring)
+{
+	if (mcp251xfd_get_tx_free(tx_ring) > 0)
+		return false;
+
+	netif_stop_queue(priv->ndev);
+
+	/* Memory barrier before checking tx_free (head and tail) */
+	smp_mb();
+
+	if (mcp251xfd_get_tx_free(tx_ring) == 0) {
+		netdev_dbg(priv->ndev,
+			   "Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\n",
+			   tx_ring->head, tx_ring->tail,
+			   tx_ring->head - tx_ring->tail);
+
+		return true;
+	}
+
+	netif_start_queue(priv->ndev);
+
+	return false;
+}
+
+static netdev_tx_t mcp251xfd_start_xmit(struct sk_buff *skb,
+					struct net_device *ndev)
+{
+	struct mcp251xfd_priv *priv = netdev_priv(ndev);
+	struct mcp251xfd_tx_ring *tx_ring = priv->tx;
+	struct mcp251xfd_tx_obj *tx_obj;
+	u8 tx_head;
+	int err;
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+	if (mcp251xfd_tx_busy(priv, tx_ring))
+		return NETDEV_TX_BUSY;
+
+	tx_obj = mcp251xfd_get_tx_obj_next(tx_ring);
+	mcp251xfd_tx_obj_from_skb(priv, tx_obj, skb, tx_ring->head);
+
+	/* Stop queue if we occupy the complete TX FIFO */
+	tx_head = mcp251xfd_get_tx_head(tx_ring);
+	tx_ring->head++;
+	if (tx_ring->head - tx_ring->tail >= tx_ring->obj_num)
+		netif_stop_queue(ndev);
+
+	can_put_echo_skb(skb, ndev, tx_head);
+
+	err = mcp251xfd_tx_obj_write(priv, tx_obj);
+	if (err)
+		goto out_err;
+
+	return NETDEV_TX_OK;
+
+ out_err:
+	netdev_err(priv->ndev, "ERROR in %s: %d\n", __func__, err);
+
+	return NETDEV_TX_OK;
+}
+
+static int mcp251xfd_open(struct net_device *ndev)
+{
+	struct mcp251xfd_priv *priv = netdev_priv(ndev);
+	const struct spi_device *spi = priv->spi;
+	int err;
+
+	err = pm_runtime_get_sync(ndev->dev.parent);
+	if (err < 0) {
+		pm_runtime_put_noidle(ndev->dev.parent);
+		return err;
+	}
+
+	err = open_candev(ndev);
+	if (err)
+		goto out_pm_runtime_put;
+
+	err = mcp251xfd_ring_alloc(priv);
+	if (err)
+		goto out_close_candev;
+
+	err = mcp251xfd_transceiver_enable(priv);
+	if (err)
+		goto out_mcp251xfd_ring_free;
+
+	err = mcp251xfd_chip_start(priv);
+	if (err)
+		goto out_transceiver_disable;
+
+	can_rx_offload_enable(&priv->offload);
+
+	err = request_threaded_irq(spi->irq, NULL, mcp251xfd_irq,
+				   IRQF_ONESHOT, dev_name(&spi->dev),
+				   priv);
+	if (err)
+		goto out_can_rx_offload_disable;
+
+	err = mcp251xfd_chip_interrupts_enable(priv);
+	if (err)
+		goto out_free_irq;
+
+	netif_start_queue(ndev);
+
+	return 0;
+
+ out_free_irq:
+	free_irq(spi->irq, priv);
+ out_can_rx_offload_disable:
+	can_rx_offload_disable(&priv->offload);
+ out_transceiver_disable:
+	mcp251xfd_transceiver_disable(priv);
+ out_mcp251xfd_ring_free:
+	mcp251xfd_ring_free(priv);
+ out_close_candev:
+	close_candev(ndev);
+ out_pm_runtime_put:
+	mcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);
+	pm_runtime_put(ndev->dev.parent);
+
+	return err;
+}
+
+static int mcp251xfd_stop(struct net_device *ndev)
+{
+	struct mcp251xfd_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	mcp251xfd_chip_interrupts_disable(priv);
+	free_irq(ndev->irq, priv);
+	can_rx_offload_disable(&priv->offload);
+	mcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);
+	mcp251xfd_transceiver_disable(priv);
+	mcp251xfd_ring_free(priv);
+	close_candev(ndev);
+
+	pm_runtime_put(ndev->dev.parent);
+
+	return 0;
+}
+
+static const struct net_device_ops mcp251xfd_netdev_ops = {
+	.ndo_open = mcp251xfd_open,
+	.ndo_stop = mcp251xfd_stop,
+	.ndo_start_xmit	= mcp251xfd_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+static void
+mcp251xfd_register_quirks(struct mcp251xfd_priv *priv)
+{
+	const struct spi_device *spi = priv->spi;
+	const struct spi_controller *ctlr = spi->controller;
+
+	if (ctlr->flags & SPI_CONTROLLER_HALF_DUPLEX)
+		priv->devtype_data.quirks |= MCP251XFD_QUIRK_HALF_DUPLEX;
+}
+
+static int mcp251xfd_register_chip_detect(struct mcp251xfd_priv *priv)
+{
+	const struct net_device *ndev = priv->ndev;
+	const struct mcp251xfd_devtype_data *devtype_data;
+	u32 osc;
+	int err;
+
+	/* The OSC_LPMEN is only supported on MCP2518FD, so use it to
+	 * autodetect the model.
+	 */
+	err = regmap_update_bits(priv->map_reg, MCP251XFD_REG_OSC,
+				 MCP251XFD_REG_OSC_LPMEN,
+				 MCP251XFD_REG_OSC_LPMEN);
+	if (err)
+		return err;
+
+	err = regmap_read(priv->map_reg, MCP251XFD_REG_OSC, &osc);
+	if (err)
+		return err;
+
+	if (osc & MCP251XFD_REG_OSC_LPMEN)
+		devtype_data = &mcp251xfd_devtype_data_mcp2518fd;
+	else
+		devtype_data = &mcp251xfd_devtype_data_mcp2517fd;
+
+	if (!mcp251xfd_is_251X(priv) &&
+	    priv->devtype_data.model != devtype_data->model) {
+		netdev_info(ndev,
+			    "Detected %s, but firmware specifies a %s. Fixing up.",
+			    __mcp251xfd_get_model_str(devtype_data->model),
+			    mcp251xfd_get_model_str(priv));
+	}
+	priv->devtype_data = *devtype_data;
+
+	/* We need to preserve the Half Duplex Quirk. */
+	mcp251xfd_register_quirks(priv);
+
+	/* Re-init regmap with quirks of detected model. */
+	return mcp251xfd_regmap_init(priv);
+}
+
+static int mcp251xfd_register_check_rx_int(struct mcp251xfd_priv *priv)
+{
+	int err, rx_pending;
+
+	if (!priv->rx_int)
+		return 0;
+
+	err = mcp251xfd_chip_rx_int_enable(priv);
+	if (err)
+		return err;
+
+	/* Check if RX_INT is properly working. The RX_INT should not
+	 * be active after a softreset.
+	 */
+	rx_pending = gpiod_get_value_cansleep(priv->rx_int);
+
+	err = mcp251xfd_chip_rx_int_disable(priv);
+	if (err)
+		return err;
+
+	if (!rx_pending)
+		return 0;
+
+	netdev_info(priv->ndev,
+		    "RX_INT active after softreset, disabling RX_INT support.");
+	devm_gpiod_put(&priv->spi->dev, priv->rx_int);
+	priv->rx_int = NULL;
+
+	return 0;
+}
+
+static int
+mcp251xfd_register_get_dev_id(const struct mcp251xfd_priv *priv,
+			      u32 *dev_id, u32 *effective_speed_hz)
+{
+	struct mcp251xfd_map_buf_nocrc *buf_rx;
+	struct mcp251xfd_map_buf_nocrc *buf_tx;
+	struct spi_transfer xfer[2] = { };
+	int err;
+
+	buf_rx = kzalloc(sizeof(*buf_rx), GFP_KERNEL);
+	if (!buf_rx)
+		return -ENOMEM;
+
+	buf_tx = kzalloc(sizeof(*buf_tx), GFP_KERNEL);
+	if (!buf_tx) {
+		err = -ENOMEM;
+		goto out_kfree_buf_rx;
+	}
+
+	xfer[0].tx_buf = buf_tx;
+	xfer[0].len = sizeof(buf_tx->cmd);
+	xfer[1].rx_buf = buf_rx->data;
+	xfer[1].len = sizeof(dev_id);
+
+	mcp251xfd_spi_cmd_read_nocrc(&buf_tx->cmd, MCP251XFD_REG_DEVID);
+	err = spi_sync_transfer(priv->spi, xfer, ARRAY_SIZE(xfer));
+	if (err)
+		goto out_kfree_buf_tx;
+
+	*dev_id = be32_to_cpup((__be32 *)buf_rx->data);
+	*effective_speed_hz = xfer->effective_speed_hz;
+
+ out_kfree_buf_tx:
+	kfree(buf_tx);
+ out_kfree_buf_rx:
+	kfree(buf_rx);
+
+	return 0;
+}
+
+#define MCP251XFD_QUIRK_ACTIVE(quirk) \
+	(priv->devtype_data.quirks & MCP251XFD_QUIRK_##quirk ? '+' : '-')
+
+static int
+mcp251xfd_register_done(const struct mcp251xfd_priv *priv)
+{
+	u32 dev_id, effective_speed_hz;
+	int err;
+
+	err = mcp251xfd_register_get_dev_id(priv, &dev_id,
+					    &effective_speed_hz);
+	if (err)
+		return err;
+
+	netdev_info(priv->ndev,
+		    "%s rev%lu.%lu (%cRX_INT %cMAB_NO_WARN %cCRC_REG %cCRC_RX %cCRC_TX %cECC %cHD c:%u.%02uMHz m:%u.%02uMHz r:%u.%02uMHz e:%u.%02uMHz) successfully initialized.\n",
+		    mcp251xfd_get_model_str(priv),
+		    FIELD_GET(MCP251XFD_REG_DEVID_ID_MASK, dev_id),
+		    FIELD_GET(MCP251XFD_REG_DEVID_REV_MASK, dev_id),
+		    priv->rx_int ? '+' : '-',
+		    MCP251XFD_QUIRK_ACTIVE(MAB_NO_WARN),
+		    MCP251XFD_QUIRK_ACTIVE(CRC_REG),
+		    MCP251XFD_QUIRK_ACTIVE(CRC_RX),
+		    MCP251XFD_QUIRK_ACTIVE(CRC_TX),
+		    MCP251XFD_QUIRK_ACTIVE(ECC),
+		    MCP251XFD_QUIRK_ACTIVE(HALF_DUPLEX),
+		    priv->can.clock.freq / 1000000,
+		    priv->can.clock.freq % 1000000 / 1000 / 10,
+		    priv->spi_max_speed_hz_orig / 1000000,
+		    priv->spi_max_speed_hz_orig % 1000000 / 1000 / 10,
+		    priv->spi->max_speed_hz / 1000000,
+		    priv->spi->max_speed_hz % 1000000 / 1000 / 10,
+		    effective_speed_hz / 1000000,
+		    effective_speed_hz % 1000000 / 1000 / 10);
+
+	return 0;
+}
+
+static int mcp251xfd_register(struct mcp251xfd_priv *priv)
+{
+	struct net_device *ndev = priv->ndev;
+	int err;
+
+	err = mcp251xfd_clks_and_vdd_enable(priv);
+	if (err)
+		return err;
+
+	pm_runtime_get_noresume(ndev->dev.parent);
+	err = pm_runtime_set_active(ndev->dev.parent);
+	if (err)
+		goto out_runtime_put_noidle;
+	pm_runtime_enable(ndev->dev.parent);
+
+	mcp251xfd_register_quirks(priv);
+
+	err = mcp251xfd_chip_softreset(priv);
+	if (err == -ENODEV)
+		goto out_runtime_disable;
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp251xfd_register_chip_detect(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp251xfd_register_check_rx_int(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = register_candev(ndev);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp251xfd_register_done(priv);
+	if (err)
+		goto out_unregister_candev;
+
+	/* Put controller into sleep mode and let pm_runtime_put()
+	 * disable the clocks and vdd. If CONFIG_PM is not enabled,
+	 * the clocks and vdd will stay powered.
+	 */
+	err = mcp251xfd_chip_set_mode(priv, MCP251XFD_REG_CON_MODE_SLEEP);
+	if (err)
+		goto out_unregister_candev;
+
+	pm_runtime_put(ndev->dev.parent);
+
+	return 0;
+
+ out_unregister_candev:
+	unregister_candev(ndev);
+ out_chip_set_mode_sleep:
+	mcp251xfd_chip_set_mode(priv, MCP251XFD_REG_CON_MODE_SLEEP);
+ out_runtime_disable:
+	pm_runtime_disable(ndev->dev.parent);
+ out_runtime_put_noidle:
+	pm_runtime_put_noidle(ndev->dev.parent);
+	mcp251xfd_clks_and_vdd_disable(priv);
+
+	return err;
+}
+
+static inline void mcp251xfd_unregister(struct mcp251xfd_priv *priv)
+{
+	struct net_device *ndev	= priv->ndev;
+
+	unregister_candev(ndev);
+
+	pm_runtime_get_sync(ndev->dev.parent);
+	pm_runtime_put_noidle(ndev->dev.parent);
+	mcp251xfd_clks_and_vdd_disable(priv);
+	pm_runtime_disable(ndev->dev.parent);
+}
+
+static const struct of_device_id mcp251xfd_of_match[] = {
+	{
+		.compatible = "microchip,mcp2517fd",
+		.data = &mcp251xfd_devtype_data_mcp2517fd,
+	}, {
+		.compatible = "microchip,mcp2518fd",
+		.data = &mcp251xfd_devtype_data_mcp2518fd,
+	}, {
+		.compatible = "microchip,mcp251xfd",
+		.data = &mcp251xfd_devtype_data_mcp251xfd,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, mcp251xfd_of_match);
+
+static const struct spi_device_id mcp251xfd_id_table[] = {
+	{
+		.name = "mcp2517fd",
+		.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp2517fd,
+	}, {
+		.name = "mcp2518fd",
+		.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp2518fd,
+	}, {
+		.name = "mcp251xfd",
+		.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp251xfd,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(spi, mcp251xfd_id_table);
+
+static int mcp251xfd_probe(struct spi_device *spi)
+{
+	const void *match;
+	struct net_device *ndev;
+	struct mcp251xfd_priv *priv;
+	struct gpio_desc *rx_int;
+	struct regulator *reg_vdd, *reg_xceiver;
+	struct clk *clk;
+	u32 freq;
+	int err;
+
+	rx_int = devm_gpiod_get_optional(&spi->dev, "microchip,rx-int",
+					 GPIOD_IN);
+	if (PTR_ERR(rx_int) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (IS_ERR(rx_int))
+		return PTR_ERR(rx_int);
+
+	reg_vdd = devm_regulator_get_optional(&spi->dev, "vdd");
+	if (PTR_ERR(reg_vdd) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (PTR_ERR(reg_vdd) == -ENODEV)
+		reg_vdd = NULL;
+	else if (IS_ERR(reg_vdd))
+		return PTR_ERR(reg_vdd);
+
+	reg_xceiver = devm_regulator_get_optional(&spi->dev, "xceiver");
+	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (PTR_ERR(reg_xceiver) == -ENODEV)
+		reg_xceiver = NULL;
+	else if (IS_ERR(reg_xceiver))
+		return PTR_ERR(reg_xceiver);
+
+	clk = devm_clk_get(&spi->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&spi->dev, "No Oscillator (clock) defined.\n");
+		return PTR_ERR(clk);
+	}
+	freq = clk_get_rate(clk);
+
+	/* Sanity check */
+	if (freq < MCP251XFD_SYSCLOCK_HZ_MIN ||
+	    freq > MCP251XFD_SYSCLOCK_HZ_MAX) {
+		dev_err(&spi->dev,
+			"Oscillator frequency (%u Hz) is too low or high.\n",
+			freq);
+		return -ERANGE;
+	}
+
+	if (freq <= MCP251XFD_SYSCLOCK_HZ_MAX / MCP251XFD_OSC_PLL_MULTIPLIER) {
+		dev_err(&spi->dev,
+			"Oscillator frequency (%u Hz) is too low and PLL is not supported.\n",
+			freq);
+		return -ERANGE;
+	}
+
+	ndev = alloc_candev(sizeof(struct mcp251xfd_priv),
+			    MCP251XFD_TX_OBJ_NUM_MAX);
+	if (!ndev)
+		return -ENOMEM;
+
+	SET_NETDEV_DEV(ndev, &spi->dev);
+
+	ndev->netdev_ops = &mcp251xfd_netdev_ops;
+	ndev->irq = spi->irq;
+	ndev->flags |= IFF_ECHO;
+
+	priv = netdev_priv(ndev);
+	spi_set_drvdata(spi, priv);
+	priv->can.clock.freq = freq;
+	priv->can.do_set_mode = mcp251xfd_set_mode;
+	priv->can.do_get_berr_counter = mcp251xfd_get_berr_counter;
+	priv->can.bittiming_const = &mcp251xfd_bittiming_const;
+	priv->can.data_bittiming_const = &mcp251xfd_data_bittiming_const;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
+		CAN_CTRLMODE_BERR_REPORTING | CAN_CTRLMODE_FD |
+		CAN_CTRLMODE_FD_NON_ISO;
+	priv->ndev = ndev;
+	priv->spi = spi;
+	priv->rx_int = rx_int;
+	priv->clk = clk;
+	priv->reg_vdd = reg_vdd;
+	priv->reg_xceiver = reg_xceiver;
+
+	match = device_get_match_data(&spi->dev);
+	if (match)
+		priv->devtype_data = *(struct mcp251xfd_devtype_data *)match;
+	else
+		priv->devtype_data = *(struct mcp251xfd_devtype_data *)
+			spi_get_device_id(spi)->driver_data;
+
+	/* Errata Reference:
+	 * mcp2517fd: DS80000789B, mcp2518fd: DS80000792C 4.
+	 *
+	 * The SPI can write corrupted data to the RAM at fast SPI
+	 * speeds:
+	 *
+	 * Simultaneous activity on the CAN bus while writing data to
+	 * RAM via the SPI interface, with high SCK frequency, can
+	 * lead to corrupted data being written to RAM.
+	 *
+	 * Fix/Work Around:
+	 * Ensure that FSCK is less than or equal to 0.85 *
+	 * (FSYSCLK/2).
+	 *
+	 * Known good and bad combinations are:
+	 *
+	 * MCP	ext-clk	SoC			SPI			SPI-clk		max-clk	parent-clk	Status	config
+	 *
+	 * 2518	20 MHz	allwinner,sun8i-h3	allwinner,sun8i-h3-spi	 8333333 Hz	 83.33%	600000000 Hz	good	assigned-clocks = <&ccu CLK_SPIx>
+	 * 2518	20 MHz	allwinner,sun8i-h3	allwinner,sun8i-h3-spi	 9375000 Hz	 93.75%	600000000 Hz	bad	assigned-clocks = <&ccu CLK_SPIx>
+	 * 2518	40 MHz	allwinner,sun8i-h3	allwinner,sun8i-h3-spi	16666667 Hz	 83.33%	600000000 Hz	good	assigned-clocks = <&ccu CLK_SPIx>
+	 * 2518	40 MHz	allwinner,sun8i-h3	allwinner,sun8i-h3-spi	18750000 Hz	 93.75%	600000000 Hz	bad	assigned-clocks = <&ccu CLK_SPIx>
+	 * 2517	20 MHz	fsl,imx8mm		fsl,imx51-ecspi		 8333333 Hz	 83.33%	 16666667 Hz	good	assigned-clocks = <&clk IMX8MM_CLK_ECSPIx_ROOT>
+	 * 2517	20 MHz	fsl,imx8mm		fsl,imx51-ecspi		 9523809 Hz	 95.34%	 28571429 Hz	bad	assigned-clocks = <&clk IMX8MM_CLK_ECSPIx_ROOT>
+	 * 2517 40 MHz	atmel,sama5d27		atmel,at91rm9200-spi	16400000 Hz	 82.00%	 82000000 Hz	good	default
+	 * 2518 40 MHz	atmel,sama5d27		atmel,at91rm9200-spi	16400000 Hz	 82.00%	 82000000 Hz	good	default
+	 *
+	 */
+	priv->spi_max_speed_hz_orig = spi->max_speed_hz;
+	spi->max_speed_hz = min(spi->max_speed_hz, freq / 2 / 1000 * 850);
+	spi->bits_per_word = 8;
+	spi->rt = true;
+	err = spi_setup(spi);
+	if (err)
+		goto out_free_candev;
+
+	err = mcp251xfd_regmap_init(priv);
+	if (err)
+		goto out_free_candev;
+
+	err = can_rx_offload_add_manual(ndev, &priv->offload,
+					MCP251XFD_NAPI_WEIGHT);
+	if (err)
+		goto out_free_candev;
+
+	err = mcp251xfd_register(priv);
+	if (err)
+		goto out_free_candev;
+
+	return 0;
+
+ out_free_candev:
+	spi->max_speed_hz = priv->spi_max_speed_hz_orig;
+
+	free_candev(ndev);
+
+	return err;
+}
+
+static int mcp251xfd_remove(struct spi_device *spi)
+{
+	struct mcp251xfd_priv *priv = spi_get_drvdata(spi);
+	struct net_device *ndev = priv->ndev;
+
+	can_rx_offload_del(&priv->offload);
+	mcp251xfd_unregister(priv);
+	spi->max_speed_hz = priv->spi_max_speed_hz_orig;
+	free_candev(ndev);
+
+	return 0;
+}
+
+static int __maybe_unused mcp251xfd_runtime_suspend(struct device *device)
+{
+	const struct mcp251xfd_priv *priv = dev_get_drvdata(device);
+
+	return mcp251xfd_clks_and_vdd_disable(priv);
+}
+
+static int __maybe_unused mcp251xfd_runtime_resume(struct device *device)
+{
+	const struct mcp251xfd_priv *priv = dev_get_drvdata(device);
+
+	return mcp251xfd_clks_and_vdd_enable(priv);
+}
+
+static const struct dev_pm_ops mcp251xfd_pm_ops = {
+	SET_RUNTIME_PM_OPS(mcp251xfd_runtime_suspend,
+			   mcp251xfd_runtime_resume, NULL)
+};
+
+static struct spi_driver mcp251xfd_driver = {
+	.driver = {
+		.name = DEVICE_NAME,
+		.pm = &mcp251xfd_pm_ops,
+		.of_match_table = mcp251xfd_of_match,
+	},
+	.probe = mcp251xfd_probe,
+	.remove = mcp251xfd_remove,
+	.id_table = mcp251xfd_id_table,
+};
+module_spi_driver(mcp251xfd_driver);
+
+MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutronix.de>");
+MODULE_DESCRIPTION("Microchip MCP251xFD Family CAN controller driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.c b/drivers/net/can/spi/mcp251xfd/mcp251xfd-crc16.c
similarity index 63%
rename from drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.c
rename to drivers/net/can/spi/mcp251xfd/mcp251xfd-crc16.c
index 466f989845dd..a02ca76ac239 100644
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.c
+++ b/drivers/net/can/spi/mcp251xfd/mcp251xfd-crc16.c
@@ -1,26 +1,26 @@
 // SPDX-License-Identifier: GPL-2.0
+//
+// mcp251xfd - Microchip MCP251xFD Family CAN controller driver
+//
+// Copyright (c) 2020 Pengutronix,
+//                    Marc Kleine-Budde <kernel@pengutronix.de>
+//
+// Based on:
+//
+// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+//
+// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+//
 
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#include <linux/kernel.h>
-#include <linux/spi/spi.h>
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_crc.h"
-#include "mcp25xxfd_regs.h"
-#include "mcp25xxfd_priv.h"
+#include "mcp251xfd.h"
 
-/* the standard crc16 in linux/crc16.h is unfortunately not
- * computing the correct results (left shift vs. right shift)
- * so here an implementation with a table generated by:
- * http://lkml.iu.edu/hypermail/linux/kernel/0508.1/1085.html
+/* The standard crc16 in linux/crc16.h is unfortunately not computing
+ * the correct results (left shift vs. right shift). So here an
+ * implementation with a table generated with the help of:
  *
- * if someone has a better idea how to make crc16 produce the expected
- * result, then please come forward...
+ * http://lkml.iu.edu/hypermail/linux/kernel/0508.1/1085.html
  */
-static const u16 _mcp25xxfd_crc_table[256] = {
+static const u16 mcp251xfd_crc16_table[] = {
 	0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011,
 	0x8033, 0x0036, 0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022,
 	0x8063, 0x0066, 0x006c, 0x8069, 0x0078, 0x807d, 0x8077, 0x0072,
@@ -55,34 +55,35 @@ static const u16 _mcp25xxfd_crc_table[256] = {
 	0x8213, 0x0216, 0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202
 };
 
-static inline u16 mcp25xxfd_crc_byte(u16 crc, const u8 data)
+static inline u16 mcp251xfd_crc16_byte(u16 crc, const u8 data)
 {
 	u8 index = (crc >> 8) ^ data;
 
-	return (crc << 8) ^ _mcp25xxfd_crc_table[index];
+	return (crc << 8) ^ mcp251xfd_crc16_table[index];
 }
 
-u16 mcp25xxfd_crc(u16 crc, u8 const *buffer, size_t len)
+static u16 mcp251xfd_crc16(u16 crc, u8 const *buffer, size_t len)
 {
 	while (len--)
-		crc = mcp25xxfd_crc_byte(crc, *buffer++);
+		crc = mcp251xfd_crc16_byte(crc, *buffer++);
+
 	return crc;
 }
 
-int mcp25xxfd_crc_enable_int(struct mcp25xxfd_priv *priv, bool enable)
+u16 mcp251xfd_crc16_compute(const void *data, size_t data_size)
 {
-	u32 mask = MCP25XXFD_CRC_CRCERRIE | MCP25XXFD_CRC_FERRIE;
-
-	priv->regs.crc &= ~mask;
-	priv->regs.crc |= enable ? mask : 0;
+	u16 crc = 0xffff;
 
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CRC,
-					priv->regs.crc, mask);
+	return mcp251xfd_crc16(crc, data, data_size);
 }
 
-int mcp25xxfd_crc_clear_int(struct mcp25xxfd_priv *priv)
+u16 mcp251xfd_crc16_compute2(const void *cmd, size_t cmd_size,
+			     const void *data, size_t data_size)
 {
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CRC, 0,
-					MCP25XXFD_CRC_CRCERRIF |
-					MCP25XXFD_CRC_FERRIF);
+	u16 crc;
+
+	crc = mcp251xfd_crc16_compute(cmd, cmd_size);
+	crc = mcp251xfd_crc16(crc, data, data_size);
+
+	return crc;
 }
diff --git a/drivers/net/can/spi/mcp251xfd/mcp251xfd-regmap.c b/drivers/net/can/spi/mcp251xfd/mcp251xfd-regmap.c
new file mode 100644
index 000000000000..314f868b3465
--- /dev/null
+++ b/drivers/net/can/spi/mcp251xfd/mcp251xfd-regmap.c
@@ -0,0 +1,556 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp251xfd - Microchip MCP251xFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include "mcp251xfd.h"
+
+#include <asm/unaligned.h>
+
+static const struct regmap_config mcp251xfd_regmap_crc;
+
+static int
+mcp251xfd_regmap_nocrc_write(void *context, const void *data, size_t count)
+{
+	struct spi_device *spi = context;
+
+	return spi_write(spi, data, count);
+}
+
+static int
+mcp251xfd_regmap_nocrc_gather_write(void *context,
+				    const void *reg, size_t reg_len,
+				    const void *val, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp251xfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp251xfd_map_buf_nocrc *buf_tx = priv->map_buf_nocrc_tx;
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = buf_tx,
+			.len = sizeof(buf_tx->cmd) + val_len,
+		},
+	};
+
+	BUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16));
+
+	if (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&
+	    reg_len != sizeof(buf_tx->cmd.cmd))
+		return -EINVAL;
+
+	memcpy(&buf_tx->cmd, reg, sizeof(buf_tx->cmd));
+	memcpy(buf_tx->data, val, val_len);
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static inline bool mcp251xfd_update_bits_read_reg(unsigned int reg)
+{
+	switch (reg) {
+	case MCP251XFD_REG_INT:
+	case MCP251XFD_REG_TEFCON:
+	case MCP251XFD_REG_FIFOCON(MCP251XFD_RX_FIFO(0)):
+	case MCP251XFD_REG_FLTCON(0):
+	case MCP251XFD_REG_ECCSTAT:
+	case MCP251XFD_REG_CRC:
+		return false;
+	case MCP251XFD_REG_CON:
+	case MCP251XFD_REG_FIFOSTA(MCP251XFD_RX_FIFO(0)):
+	case MCP251XFD_REG_OSC:
+	case MCP251XFD_REG_ECCCON:
+		return true;
+	default:
+		WARN(1, "Status of reg 0x%04x unknown.\n", reg);
+	}
+
+	return true;
+}
+
+static int
+mcp251xfd_regmap_nocrc_update_bits(void *context, unsigned int reg,
+				   unsigned int mask, unsigned int val)
+{
+	struct spi_device *spi = context;
+	struct mcp251xfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp251xfd_map_buf_nocrc *buf_rx = priv->map_buf_nocrc_rx;
+	struct mcp251xfd_map_buf_nocrc *buf_tx = priv->map_buf_nocrc_tx;
+	__le32 orig_le32 = 0, mask_le32, val_le32, tmp_le32;
+	u8 first_byte, last_byte, len;
+	int err;
+
+	BUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16));
+	BUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16));
+
+	if (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&
+	    mask == 0)
+		return -EINVAL;
+
+	first_byte = mcp251xfd_first_byte_set(mask);
+	last_byte = mcp251xfd_last_byte_set(mask);
+	len = last_byte - first_byte + 1;
+
+	if (mcp251xfd_update_bits_read_reg(reg)) {
+		struct spi_transfer xfer[2] = { };
+		struct spi_message msg;
+
+		spi_message_init(&msg);
+		spi_message_add_tail(&xfer[0], &msg);
+
+		if (priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX) {
+			xfer[0].tx_buf = buf_tx;
+			xfer[0].len = sizeof(buf_tx->cmd);
+
+			xfer[1].rx_buf = buf_rx->data;
+			xfer[1].len = len;
+			spi_message_add_tail(&xfer[1], &msg);
+		} else {
+			xfer[0].tx_buf = buf_tx;
+			xfer[0].rx_buf = buf_rx;
+			xfer[0].len = sizeof(buf_tx->cmd) + len;
+
+			if (MCP251XFD_SANITIZE_SPI)
+				memset(buf_tx->data, 0x0, len);
+		}
+
+		mcp251xfd_spi_cmd_read_nocrc(&buf_tx->cmd, reg + first_byte);
+		err = spi_sync(spi, &msg);
+		if (err)
+			return err;
+
+		memcpy(&orig_le32, buf_rx->data, len);
+	}
+
+	mask_le32 = cpu_to_le32(mask >> BITS_PER_BYTE * first_byte);
+	val_le32 = cpu_to_le32(val >> BITS_PER_BYTE * first_byte);
+
+	tmp_le32 = orig_le32 & ~mask_le32;
+	tmp_le32 |= val_le32 & mask_le32;
+
+	mcp251xfd_spi_cmd_write_nocrc(&buf_tx->cmd, reg + first_byte);
+	memcpy(buf_tx->data, &tmp_le32, len);
+
+	return spi_write(spi, buf_tx, sizeof(buf_tx->cmd) + len);
+}
+
+static int
+mcp251xfd_regmap_nocrc_read(void *context,
+			    const void *reg, size_t reg_len,
+			    void *val_buf, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp251xfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp251xfd_map_buf_nocrc *buf_rx = priv->map_buf_nocrc_rx;
+	struct mcp251xfd_map_buf_nocrc *buf_tx = priv->map_buf_nocrc_tx;
+	struct spi_transfer xfer[2] = { };
+	struct spi_message msg;
+	int err;
+
+	BUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16));
+	BUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16));
+
+	if (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&
+	    reg_len != sizeof(buf_tx->cmd.cmd))
+		return -EINVAL;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer[0], &msg);
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX) {
+		xfer[0].tx_buf = reg;
+		xfer[0].len = sizeof(buf_tx->cmd);
+
+		xfer[1].rx_buf = val_buf;
+		xfer[1].len = val_len;
+		spi_message_add_tail(&xfer[1], &msg);
+	} else {
+		xfer[0].tx_buf = buf_tx;
+		xfer[0].rx_buf = buf_rx;
+		xfer[0].len = sizeof(buf_tx->cmd) + val_len;
+
+		memcpy(&buf_tx->cmd, reg, sizeof(buf_tx->cmd));
+		if (MCP251XFD_SANITIZE_SPI)
+			memset(buf_tx->data, 0x0, val_len);
+	}
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	if (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX))
+		memcpy(val_buf, buf_rx->data, val_len);
+
+	return 0;
+}
+
+static int
+mcp251xfd_regmap_crc_gather_write(void *context,
+				  const void *reg_p, size_t reg_len,
+				  const void *val, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp251xfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp251xfd_map_buf_crc *buf_tx = priv->map_buf_crc_tx;
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = buf_tx,
+			.len = sizeof(buf_tx->cmd) + val_len +
+				sizeof(buf_tx->crc),
+		},
+	};
+	u16 reg = *(u16 *)reg_p;
+	u16 crc;
+
+	BUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16) + sizeof(u8));
+
+	if (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&
+	    reg_len != sizeof(buf_tx->cmd.cmd) +
+	    mcp251xfd_regmap_crc.pad_bits / BITS_PER_BYTE)
+		return -EINVAL;
+
+	mcp251xfd_spi_cmd_write_crc(&buf_tx->cmd, reg, val_len);
+	memcpy(buf_tx->data, val, val_len);
+
+	crc = mcp251xfd_crc16_compute(buf_tx, sizeof(buf_tx->cmd) + val_len);
+	put_unaligned_be16(crc, buf_tx->data + val_len);
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static int
+mcp251xfd_regmap_crc_write(void *context,
+			   const void *data, size_t count)
+{
+	const size_t data_offset = sizeof(__be16) +
+		mcp251xfd_regmap_crc.pad_bits / BITS_PER_BYTE;
+
+	return mcp251xfd_regmap_crc_gather_write(context,
+						 data, data_offset,
+						 data + data_offset,
+						 count - data_offset);
+}
+
+static int
+mcp251xfd_regmap_crc_read_one(struct mcp251xfd_priv *priv,
+			      struct spi_message *msg, unsigned int data_len)
+{
+	const struct mcp251xfd_map_buf_crc *buf_rx = priv->map_buf_crc_rx;
+	const struct mcp251xfd_map_buf_crc *buf_tx = priv->map_buf_crc_tx;
+	u16 crc_received, crc_calculated;
+	int err;
+
+	BUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16) + sizeof(u8));
+	BUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16) + sizeof(u8));
+
+	err = spi_sync(priv->spi, msg);
+	if (err)
+		return err;
+
+	crc_received = get_unaligned_be16(buf_rx->data + data_len);
+	crc_calculated = mcp251xfd_crc16_compute2(&buf_tx->cmd,
+						  sizeof(buf_tx->cmd),
+						  buf_rx->data,
+						  data_len);
+	if (crc_received != crc_calculated)
+		return -EBADMSG;
+
+	return 0;
+}
+
+static int
+mcp251xfd_regmap_crc_read(void *context,
+			  const void *reg_p, size_t reg_len,
+			  void *val_buf, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp251xfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp251xfd_map_buf_crc *buf_rx = priv->map_buf_crc_rx;
+	struct mcp251xfd_map_buf_crc *buf_tx = priv->map_buf_crc_tx;
+	struct spi_transfer xfer[2] = { };
+	struct spi_message msg;
+	u16 reg = *(u16 *)reg_p;
+	int i, err;
+
+	BUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16) + sizeof(u8));
+	BUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16) + sizeof(u8));
+
+	if (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&
+	    reg_len != sizeof(buf_tx->cmd.cmd) +
+	    mcp251xfd_regmap_crc.pad_bits / BITS_PER_BYTE)
+		return -EINVAL;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer[0], &msg);
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX) {
+		xfer[0].tx_buf = buf_tx;
+		xfer[0].len = sizeof(buf_tx->cmd);
+
+		xfer[1].rx_buf = buf_rx->data;
+		xfer[1].len = val_len + sizeof(buf_tx->crc);
+		spi_message_add_tail(&xfer[1], &msg);
+	} else {
+		xfer[0].tx_buf = buf_tx;
+		xfer[0].rx_buf = buf_rx;
+		xfer[0].len = sizeof(buf_tx->cmd) + val_len +
+			sizeof(buf_tx->crc);
+
+		if (MCP251XFD_SANITIZE_SPI)
+			memset(buf_tx->data, 0x0, val_len +
+			       sizeof(buf_tx->crc));
+	}
+
+	mcp251xfd_spi_cmd_read_crc(&buf_tx->cmd, reg, val_len);
+
+	for (i = 0; i < MCP251XFD_READ_CRC_RETRIES_MAX; i++) {
+		err = mcp251xfd_regmap_crc_read_one(priv, &msg, val_len);
+		if (!err)
+			goto out;
+		if (err != -EBADMSG)
+			return err;
+
+		/* MCP251XFD_REG_OSC is the first ever reg we read from.
+		 *
+		 * The chip may be in deep sleep and this SPI transfer
+		 * (i.e. the assertion of the CS) will wake the chip
+		 * up. This takes about 3ms. The CRC of this transfer
+		 * is wrong.
+		 *
+		 * Or there isn't a chip at all, in this case the CRC
+		 * will be wrong, too.
+		 *
+		 * In both cases ignore the CRC and copy the read data
+		 * to the caller. It will take care of both cases.
+		 *
+		 */
+		if (reg == MCP251XFD_REG_OSC) {
+			err = 0;
+			goto out;
+		}
+
+		netdev_info(priv->ndev,
+			    "CRC read error at address 0x%04x (length=%zd, data=%*ph, CRC=0x%04x) retrying.\n",
+			    reg, val_len, (int)val_len, buf_rx->data,
+			    get_unaligned_be16(buf_rx->data + val_len));
+	}
+
+	if (err) {
+		netdev_err(priv->ndev,
+			   "CRC read error at address 0x%04x (length=%zd, data=%*ph, CRC=0x%04x).\n",
+			   reg, val_len, (int)val_len, buf_rx->data,
+			   get_unaligned_be16(buf_rx->data + val_len));
+
+		return err;
+	}
+ out:
+	memcpy(val_buf, buf_rx->data, val_len);
+
+	return 0;
+}
+
+static const struct regmap_range mcp251xfd_reg_table_yes_range[] = {
+	regmap_reg_range(0x000, 0x2ec),	/* CAN FD Controller Module SFR */
+	regmap_reg_range(0x400, 0xbfc),	/* RAM */
+	regmap_reg_range(0xe00, 0xe14),	/* MCP2517/18FD SFR */
+};
+
+static const struct regmap_access_table mcp251xfd_reg_table = {
+	.yes_ranges = mcp251xfd_reg_table_yes_range,
+	.n_yes_ranges = ARRAY_SIZE(mcp251xfd_reg_table_yes_range),
+};
+
+static const struct regmap_config mcp251xfd_regmap_nocrc = {
+	.name = "nocrc",
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.pad_bits = 0,
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.wr_table = &mcp251xfd_reg_table,
+	.rd_table = &mcp251xfd_reg_table,
+	.cache_type = REGCACHE_NONE,
+	.read_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_READ),
+	.write_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_WRITE),
+};
+
+static const struct regmap_bus mcp251xfd_bus_nocrc = {
+	.write = mcp251xfd_regmap_nocrc_write,
+	.gather_write = mcp251xfd_regmap_nocrc_gather_write,
+	.reg_update_bits = mcp251xfd_regmap_nocrc_update_bits,
+	.read = mcp251xfd_regmap_nocrc_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+	.max_raw_read = sizeof_field(struct mcp251xfd_map_buf_nocrc, data),
+	.max_raw_write = sizeof_field(struct mcp251xfd_map_buf_nocrc, data),
+};
+
+static const struct regmap_config mcp251xfd_regmap_crc = {
+	.name = "crc",
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.pad_bits = 16,		/* keep data bits aligned */
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.wr_table = &mcp251xfd_reg_table,
+	.rd_table = &mcp251xfd_reg_table,
+	.cache_type = REGCACHE_NONE,
+};
+
+static const struct regmap_bus mcp251xfd_bus_crc = {
+	.write = mcp251xfd_regmap_crc_write,
+	.gather_write = mcp251xfd_regmap_crc_gather_write,
+	.read = mcp251xfd_regmap_crc_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+	.max_raw_read = sizeof_field(struct mcp251xfd_map_buf_crc, data),
+	.max_raw_write = sizeof_field(struct mcp251xfd_map_buf_crc, data),
+};
+
+static inline bool
+mcp251xfd_regmap_use_nocrc(struct mcp251xfd_priv *priv)
+{
+	return (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG)) ||
+		(!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX));
+}
+
+static inline bool
+mcp251xfd_regmap_use_crc(struct mcp251xfd_priv *priv)
+{
+	return (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG) ||
+		(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX);
+}
+
+static int
+mcp251xfd_regmap_init_nocrc(struct mcp251xfd_priv *priv)
+{
+	if (!priv->map_nocrc) {
+		struct regmap *map;
+
+		map = devm_regmap_init(&priv->spi->dev, &mcp251xfd_bus_nocrc,
+				       priv->spi, &mcp251xfd_regmap_nocrc);
+		if (IS_ERR(map))
+			return PTR_ERR(map);
+
+		priv->map_nocrc = map;
+	}
+
+	if (!priv->map_buf_nocrc_rx) {
+		priv->map_buf_nocrc_rx =
+			devm_kzalloc(&priv->spi->dev,
+				     sizeof(*priv->map_buf_nocrc_rx),
+				     GFP_KERNEL);
+		if (!priv->map_buf_nocrc_rx)
+			return -ENOMEM;
+	}
+
+	if (!priv->map_buf_nocrc_tx) {
+		priv->map_buf_nocrc_tx =
+			devm_kzalloc(&priv->spi->dev,
+				     sizeof(*priv->map_buf_nocrc_tx),
+				     GFP_KERNEL);
+		if (!priv->map_buf_nocrc_tx)
+			return -ENOMEM;
+	}
+
+	if (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG))
+		priv->map_reg = priv->map_nocrc;
+
+	if (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX))
+		priv->map_rx = priv->map_nocrc;
+
+	return 0;
+}
+
+static void mcp251xfd_regmap_destroy_nocrc(struct mcp251xfd_priv *priv)
+{
+	if (priv->map_buf_nocrc_rx) {
+		devm_kfree(&priv->spi->dev, priv->map_buf_nocrc_rx);
+		priv->map_buf_nocrc_rx = NULL;
+	}
+	if (priv->map_buf_nocrc_tx) {
+		devm_kfree(&priv->spi->dev, priv->map_buf_nocrc_tx);
+		priv->map_buf_nocrc_tx = NULL;
+	}
+}
+
+static int
+mcp251xfd_regmap_init_crc(struct mcp251xfd_priv *priv)
+{
+	if (!priv->map_crc) {
+		struct regmap *map;
+
+		map = devm_regmap_init(&priv->spi->dev, &mcp251xfd_bus_crc,
+				       priv->spi, &mcp251xfd_regmap_crc);
+		if (IS_ERR(map))
+			return PTR_ERR(map);
+
+		priv->map_crc = map;
+	}
+
+	if (!priv->map_buf_crc_rx) {
+		priv->map_buf_crc_rx =
+			devm_kzalloc(&priv->spi->dev,
+				     sizeof(*priv->map_buf_crc_rx),
+				     GFP_KERNEL);
+		if (!priv->map_buf_crc_rx)
+			return -ENOMEM;
+	}
+
+	if (!priv->map_buf_crc_tx) {
+		priv->map_buf_crc_tx =
+			devm_kzalloc(&priv->spi->dev,
+				     sizeof(*priv->map_buf_crc_tx),
+				     GFP_KERNEL);
+		if (!priv->map_buf_crc_tx)
+			return -ENOMEM;
+	}
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG)
+		priv->map_reg = priv->map_crc;
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX)
+		priv->map_rx = priv->map_crc;
+
+	return 0;
+}
+
+static void mcp251xfd_regmap_destroy_crc(struct mcp251xfd_priv *priv)
+{
+	if (priv->map_buf_crc_rx) {
+		devm_kfree(&priv->spi->dev, priv->map_buf_crc_rx);
+		priv->map_buf_crc_rx = NULL;
+	}
+	if (priv->map_buf_crc_tx) {
+		devm_kfree(&priv->spi->dev, priv->map_buf_crc_tx);
+		priv->map_buf_crc_tx = NULL;
+	}
+}
+
+int mcp251xfd_regmap_init(struct mcp251xfd_priv *priv)
+{
+	int err;
+
+	if (mcp251xfd_regmap_use_nocrc(priv)) {
+		err = mcp251xfd_regmap_init_nocrc(priv);
+
+		if (err)
+			return err;
+	} else {
+		mcp251xfd_regmap_destroy_nocrc(priv);
+	}
+
+	if (mcp251xfd_regmap_use_crc(priv)) {
+		err = mcp251xfd_regmap_init_crc(priv);
+
+		if (err)
+			return err;
+	} else {
+		mcp251xfd_regmap_destroy_crc(priv);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/can/spi/mcp251xfd/mcp251xfd.h b/drivers/net/can/spi/mcp251xfd/mcp251xfd.h
new file mode 100644
index 000000000000..fa1246e39980
--- /dev/null
+++ b/drivers/net/can/spi/mcp251xfd/mcp251xfd.h
@@ -0,0 +1,835 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp251xfd - Microchip MCP251xFD Family CAN controller driver
+ *
+ * Copyright (c) 2019 Pengutronix,
+ *                    Marc Kleine-Budde <kernel@pengutronix.de>
+ * Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef _MCP251XFD_H
+#define _MCP251XFD_H
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/can/rx-offload.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+/* MPC251x registers */
+
+/* CAN FD Controller Module SFR */
+#define MCP251XFD_REG_CON 0x00
+#define MCP251XFD_REG_CON_TXBWS_MASK GENMASK(31, 28)
+#define MCP251XFD_REG_CON_ABAT BIT(27)
+#define MCP251XFD_REG_CON_REQOP_MASK GENMASK(26, 24)
+#define MCP251XFD_REG_CON_MODE_MIXED 0
+#define MCP251XFD_REG_CON_MODE_SLEEP 1
+#define MCP251XFD_REG_CON_MODE_INT_LOOPBACK 2
+#define MCP251XFD_REG_CON_MODE_LISTENONLY 3
+#define MCP251XFD_REG_CON_MODE_CONFIG 4
+#define MCP251XFD_REG_CON_MODE_EXT_LOOPBACK 5
+#define MCP251XFD_REG_CON_MODE_CAN2_0 6
+#define MCP251XFD_REG_CON_MODE_RESTRICTED 7
+#define MCP251XFD_REG_CON_OPMOD_MASK GENMASK(23, 21)
+#define MCP251XFD_REG_CON_TXQEN BIT(20)
+#define MCP251XFD_REG_CON_STEF BIT(19)
+#define MCP251XFD_REG_CON_SERR2LOM BIT(18)
+#define MCP251XFD_REG_CON_ESIGM BIT(17)
+#define MCP251XFD_REG_CON_RTXAT BIT(16)
+#define MCP251XFD_REG_CON_BRSDIS BIT(12)
+#define MCP251XFD_REG_CON_BUSY BIT(11)
+#define MCP251XFD_REG_CON_WFT_MASK GENMASK(10, 9)
+#define MCP251XFD_REG_CON_WFT_T00FILTER 0x0
+#define MCP251XFD_REG_CON_WFT_T01FILTER 0x1
+#define MCP251XFD_REG_CON_WFT_T10FILTER 0x2
+#define MCP251XFD_REG_CON_WFT_T11FILTER 0x3
+#define MCP251XFD_REG_CON_WAKFIL BIT(8)
+#define MCP251XFD_REG_CON_PXEDIS BIT(6)
+#define MCP251XFD_REG_CON_ISOCRCEN BIT(5)
+#define MCP251XFD_REG_CON_DNCNT_MASK GENMASK(4, 0)
+
+#define MCP251XFD_REG_NBTCFG 0x04
+#define MCP251XFD_REG_NBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP251XFD_REG_NBTCFG_TSEG1_MASK GENMASK(23, 16)
+#define MCP251XFD_REG_NBTCFG_TSEG2_MASK GENMASK(14, 8)
+#define MCP251XFD_REG_NBTCFG_SJW_MASK GENMASK(6, 0)
+
+#define MCP251XFD_REG_DBTCFG 0x08
+#define MCP251XFD_REG_DBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP251XFD_REG_DBTCFG_TSEG1_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_DBTCFG_TSEG2_MASK GENMASK(11, 8)
+#define MCP251XFD_REG_DBTCFG_SJW_MASK GENMASK(3, 0)
+
+#define MCP251XFD_REG_TDC 0x0c
+#define MCP251XFD_REG_TDC_EDGFLTEN BIT(25)
+#define MCP251XFD_REG_TDC_SID11EN BIT(24)
+#define MCP251XFD_REG_TDC_TDCMOD_MASK GENMASK(17, 16)
+#define MCP251XFD_REG_TDC_TDCMOD_AUTO 2
+#define MCP251XFD_REG_TDC_TDCMOD_MANUAL 1
+#define MCP251XFD_REG_TDC_TDCMOD_DISABLED 0
+#define MCP251XFD_REG_TDC_TDCO_MASK GENMASK(14, 8)
+#define MCP251XFD_REG_TDC_TDCV_MASK GENMASK(5, 0)
+
+#define MCP251XFD_REG_TBC 0x10
+
+#define MCP251XFD_REG_TSCON 0x14
+#define MCP251XFD_REG_TSCON_TSRES BIT(18)
+#define MCP251XFD_REG_TSCON_TSEOF BIT(17)
+#define MCP251XFD_REG_TSCON_TBCEN BIT(16)
+#define MCP251XFD_REG_TSCON_TBCPRE_MASK GENMASK(9, 0)
+
+#define MCP251XFD_REG_VEC 0x18
+#define MCP251XFD_REG_VEC_RXCODE_MASK GENMASK(30, 24)
+#define MCP251XFD_REG_VEC_TXCODE_MASK GENMASK(22, 16)
+#define MCP251XFD_REG_VEC_FILHIT_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_VEC_ICODE_MASK GENMASK(6, 0)
+
+#define MCP251XFD_REG_INT 0x1c
+#define MCP251XFD_REG_INT_IF_MASK GENMASK(15, 0)
+#define MCP251XFD_REG_INT_IE_MASK GENMASK(31, 16)
+#define MCP251XFD_REG_INT_IVMIE BIT(31)
+#define MCP251XFD_REG_INT_WAKIE BIT(30)
+#define MCP251XFD_REG_INT_CERRIE BIT(29)
+#define MCP251XFD_REG_INT_SERRIE BIT(28)
+#define MCP251XFD_REG_INT_RXOVIE BIT(27)
+#define MCP251XFD_REG_INT_TXATIE BIT(26)
+#define MCP251XFD_REG_INT_SPICRCIE BIT(25)
+#define MCP251XFD_REG_INT_ECCIE BIT(24)
+#define MCP251XFD_REG_INT_TEFIE BIT(20)
+#define MCP251XFD_REG_INT_MODIE BIT(19)
+#define MCP251XFD_REG_INT_TBCIE BIT(18)
+#define MCP251XFD_REG_INT_RXIE BIT(17)
+#define MCP251XFD_REG_INT_TXIE BIT(16)
+#define MCP251XFD_REG_INT_IVMIF BIT(15)
+#define MCP251XFD_REG_INT_WAKIF BIT(14)
+#define MCP251XFD_REG_INT_CERRIF BIT(13)
+#define MCP251XFD_REG_INT_SERRIF BIT(12)
+#define MCP251XFD_REG_INT_RXOVIF BIT(11)
+#define MCP251XFD_REG_INT_TXATIF BIT(10)
+#define MCP251XFD_REG_INT_SPICRCIF BIT(9)
+#define MCP251XFD_REG_INT_ECCIF BIT(8)
+#define MCP251XFD_REG_INT_TEFIF BIT(4)
+#define MCP251XFD_REG_INT_MODIF BIT(3)
+#define MCP251XFD_REG_INT_TBCIF BIT(2)
+#define MCP251XFD_REG_INT_RXIF BIT(1)
+#define MCP251XFD_REG_INT_TXIF BIT(0)
+/* These IRQ flags must be cleared by SW in the CAN_INT register */
+#define MCP251XFD_REG_INT_IF_CLEARABLE_MASK \
+	(MCP251XFD_REG_INT_IVMIF | MCP251XFD_REG_INT_WAKIF | \
+	 MCP251XFD_REG_INT_CERRIF |  MCP251XFD_REG_INT_SERRIF | \
+	 MCP251XFD_REG_INT_MODIF)
+
+#define MCP251XFD_REG_RXIF 0x20
+#define MCP251XFD_REG_TXIF 0x24
+#define MCP251XFD_REG_RXOVIF 0x28
+#define MCP251XFD_REG_TXATIF 0x2c
+#define MCP251XFD_REG_TXREQ 0x30
+
+#define MCP251XFD_REG_TREC 0x34
+#define MCP251XFD_REG_TREC_TXBO BIT(21)
+#define MCP251XFD_REG_TREC_TXBP BIT(20)
+#define MCP251XFD_REG_TREC_RXBP BIT(19)
+#define MCP251XFD_REG_TREC_TXWARN BIT(18)
+#define MCP251XFD_REG_TREC_RXWARN BIT(17)
+#define MCP251XFD_REG_TREC_EWARN BIT(16)
+#define MCP251XFD_REG_TREC_TEC_MASK GENMASK(15, 8)
+#define MCP251XFD_REG_TREC_REC_MASK GENMASK(7, 0)
+
+#define MCP251XFD_REG_BDIAG0 0x38
+#define MCP251XFD_REG_BDIAG0_DTERRCNT_MASK GENMASK(31, 24)
+#define MCP251XFD_REG_BDIAG0_DRERRCNT_MASK GENMASK(23, 16)
+#define MCP251XFD_REG_BDIAG0_NTERRCNT_MASK GENMASK(15, 8)
+#define MCP251XFD_REG_BDIAG0_NRERRCNT_MASK GENMASK(7, 0)
+
+#define MCP251XFD_REG_BDIAG1 0x3c
+#define MCP251XFD_REG_BDIAG1_DLCMM BIT(31)
+#define MCP251XFD_REG_BDIAG1_ESI BIT(30)
+#define MCP251XFD_REG_BDIAG1_DCRCERR BIT(29)
+#define MCP251XFD_REG_BDIAG1_DSTUFERR BIT(28)
+#define MCP251XFD_REG_BDIAG1_DFORMERR BIT(27)
+#define MCP251XFD_REG_BDIAG1_DBIT1ERR BIT(25)
+#define MCP251XFD_REG_BDIAG1_DBIT0ERR BIT(24)
+#define MCP251XFD_REG_BDIAG1_TXBOERR BIT(23)
+#define MCP251XFD_REG_BDIAG1_NCRCERR BIT(21)
+#define MCP251XFD_REG_BDIAG1_NSTUFERR BIT(20)
+#define MCP251XFD_REG_BDIAG1_NFORMERR BIT(19)
+#define MCP251XFD_REG_BDIAG1_NACKERR BIT(18)
+#define MCP251XFD_REG_BDIAG1_NBIT1ERR BIT(17)
+#define MCP251XFD_REG_BDIAG1_NBIT0ERR BIT(16)
+#define MCP251XFD_REG_BDIAG1_BERR_MASK \
+	(MCP251XFD_REG_BDIAG1_DLCMM | MCP251XFD_REG_BDIAG1_ESI | \
+	 MCP251XFD_REG_BDIAG1_DCRCERR | MCP251XFD_REG_BDIAG1_DSTUFERR | \
+	 MCP251XFD_REG_BDIAG1_DFORMERR | MCP251XFD_REG_BDIAG1_DBIT1ERR | \
+	 MCP251XFD_REG_BDIAG1_DBIT0ERR | MCP251XFD_REG_BDIAG1_TXBOERR | \
+	 MCP251XFD_REG_BDIAG1_NCRCERR | MCP251XFD_REG_BDIAG1_NSTUFERR | \
+	 MCP251XFD_REG_BDIAG1_NFORMERR | MCP251XFD_REG_BDIAG1_NACKERR | \
+	 MCP251XFD_REG_BDIAG1_NBIT1ERR | MCP251XFD_REG_BDIAG1_NBIT0ERR)
+#define MCP251XFD_REG_BDIAG1_EFMSGCNT_MASK GENMASK(15, 0)
+
+#define MCP251XFD_REG_TEFCON 0x40
+#define MCP251XFD_REG_TEFCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_TEFCON_FRESET BIT(10)
+#define MCP251XFD_REG_TEFCON_UINC BIT(8)
+#define MCP251XFD_REG_TEFCON_TEFTSEN BIT(5)
+#define MCP251XFD_REG_TEFCON_TEFOVIE BIT(3)
+#define MCP251XFD_REG_TEFCON_TEFFIE BIT(2)
+#define MCP251XFD_REG_TEFCON_TEFHIE BIT(1)
+#define MCP251XFD_REG_TEFCON_TEFNEIE BIT(0)
+
+#define MCP251XFD_REG_TEFSTA 0x44
+#define MCP251XFD_REG_TEFSTA_TEFOVIF BIT(3)
+#define MCP251XFD_REG_TEFSTA_TEFFIF BIT(2)
+#define MCP251XFD_REG_TEFSTA_TEFHIF BIT(1)
+#define MCP251XFD_REG_TEFSTA_TEFNEIF BIT(0)
+
+#define MCP251XFD_REG_TEFUA 0x48
+
+#define MCP251XFD_REG_TXQCON 0x50
+#define MCP251XFD_REG_TXQCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP251XFD_REG_TXQCON_PLSIZE_8 0
+#define MCP251XFD_REG_TXQCON_PLSIZE_12 1
+#define MCP251XFD_REG_TXQCON_PLSIZE_16 2
+#define MCP251XFD_REG_TXQCON_PLSIZE_20 3
+#define MCP251XFD_REG_TXQCON_PLSIZE_24 4
+#define MCP251XFD_REG_TXQCON_PLSIZE_32 5
+#define MCP251XFD_REG_TXQCON_PLSIZE_48 6
+#define MCP251XFD_REG_TXQCON_PLSIZE_64 7
+#define MCP251XFD_REG_TXQCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_TXQCON_TXAT_UNLIMITED 3
+#define MCP251XFD_REG_TXQCON_TXAT_THREE_SHOT 1
+#define MCP251XFD_REG_TXQCON_TXAT_ONE_SHOT 0
+#define MCP251XFD_REG_TXQCON_TXAT_MASK GENMASK(22, 21)
+#define MCP251XFD_REG_TXQCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_TXQCON_FRESET BIT(10)
+#define MCP251XFD_REG_TXQCON_TXREQ BIT(9)
+#define MCP251XFD_REG_TXQCON_UINC BIT(8)
+#define MCP251XFD_REG_TXQCON_TXEN BIT(7)
+#define MCP251XFD_REG_TXQCON_TXATIE BIT(4)
+#define MCP251XFD_REG_TXQCON_TXQEIE BIT(2)
+#define MCP251XFD_REG_TXQCON_TXQNIE BIT(0)
+
+#define MCP251XFD_REG_TXQSTA 0x54
+#define MCP251XFD_REG_TXQSTA_TXQCI_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_TXQSTA_TXABT BIT(7)
+#define MCP251XFD_REG_TXQSTA_TXLARB BIT(6)
+#define MCP251XFD_REG_TXQSTA_TXERR BIT(5)
+#define MCP251XFD_REG_TXQSTA_TXATIF BIT(4)
+#define MCP251XFD_REG_TXQSTA_TXQEIF BIT(2)
+#define MCP251XFD_REG_TXQSTA_TXQNIF BIT(0)
+
+#define MCP251XFD_REG_TXQUA 0x58
+
+#define MCP251XFD_REG_FIFOCON(x) (0x50 + 0xc * (x))
+#define MCP251XFD_REG_FIFOCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP251XFD_REG_FIFOCON_PLSIZE_8 0
+#define MCP251XFD_REG_FIFOCON_PLSIZE_12 1
+#define MCP251XFD_REG_FIFOCON_PLSIZE_16 2
+#define MCP251XFD_REG_FIFOCON_PLSIZE_20 3
+#define MCP251XFD_REG_FIFOCON_PLSIZE_24 4
+#define MCP251XFD_REG_FIFOCON_PLSIZE_32 5
+#define MCP251XFD_REG_FIFOCON_PLSIZE_48 6
+#define MCP251XFD_REG_FIFOCON_PLSIZE_64 7
+#define MCP251XFD_REG_FIFOCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_FIFOCON_TXAT_MASK GENMASK(22, 21)
+#define MCP251XFD_REG_FIFOCON_TXAT_ONE_SHOT 0
+#define MCP251XFD_REG_FIFOCON_TXAT_THREE_SHOT 1
+#define MCP251XFD_REG_FIFOCON_TXAT_UNLIMITED 3
+#define MCP251XFD_REG_FIFOCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_FIFOCON_FRESET BIT(10)
+#define MCP251XFD_REG_FIFOCON_TXREQ BIT(9)
+#define MCP251XFD_REG_FIFOCON_UINC BIT(8)
+#define MCP251XFD_REG_FIFOCON_TXEN BIT(7)
+#define MCP251XFD_REG_FIFOCON_RTREN BIT(6)
+#define MCP251XFD_REG_FIFOCON_RXTSEN BIT(5)
+#define MCP251XFD_REG_FIFOCON_TXATIE BIT(4)
+#define MCP251XFD_REG_FIFOCON_RXOVIE BIT(3)
+#define MCP251XFD_REG_FIFOCON_TFERFFIE BIT(2)
+#define MCP251XFD_REG_FIFOCON_TFHRFHIE BIT(1)
+#define MCP251XFD_REG_FIFOCON_TFNRFNIE BIT(0)
+
+#define MCP251XFD_REG_FIFOSTA(x) (0x54 + 0xc * (x))
+#define MCP251XFD_REG_FIFOSTA_FIFOCI_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_FIFOSTA_TXABT BIT(7)
+#define MCP251XFD_REG_FIFOSTA_TXLARB BIT(6)
+#define MCP251XFD_REG_FIFOSTA_TXERR BIT(5)
+#define MCP251XFD_REG_FIFOSTA_TXATIF BIT(4)
+#define MCP251XFD_REG_FIFOSTA_RXOVIF BIT(3)
+#define MCP251XFD_REG_FIFOSTA_TFERFFIF BIT(2)
+#define MCP251XFD_REG_FIFOSTA_TFHRFHIF BIT(1)
+#define MCP251XFD_REG_FIFOSTA_TFNRFNIF BIT(0)
+
+#define MCP251XFD_REG_FIFOUA(x) (0x58 + 0xc * (x))
+
+#define MCP251XFD_REG_FLTCON(x) (0x1d0 + 0x4 * (x))
+#define MCP251XFD_REG_FLTCON_FLTEN3 BIT(31)
+#define MCP251XFD_REG_FLTCON_F3BP_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_FLTCON_FLTEN2 BIT(23)
+#define MCP251XFD_REG_FLTCON_F2BP_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_FLTCON_FLTEN1 BIT(15)
+#define MCP251XFD_REG_FLTCON_F1BP_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_FLTCON_FLTEN0 BIT(7)
+#define MCP251XFD_REG_FLTCON_F0BP_MASK GENMASK(4, 0)
+#define MCP251XFD_REG_FLTCON_FLTEN(x) (BIT(7) << 8 * ((x) & 0x3))
+#define MCP251XFD_REG_FLTCON_FLT_MASK(x) (GENMASK(7, 0) << (8 * ((x) & 0x3)))
+#define MCP251XFD_REG_FLTCON_FBP(x, fifo) ((fifo) << 8 * ((x) & 0x3))
+
+#define MCP251XFD_REG_FLTOBJ(x) (0x1f0 + 0x8 * (x))
+#define MCP251XFD_REG_FLTOBJ_EXIDE BIT(30)
+#define MCP251XFD_REG_FLTOBJ_SID11 BIT(29)
+#define MCP251XFD_REG_FLTOBJ_EID_MASK GENMASK(28, 11)
+#define MCP251XFD_REG_FLTOBJ_SID_MASK GENMASK(10, 0)
+
+#define MCP251XFD_REG_FLTMASK(x) (0x1f4 + 0x8 * (x))
+#define MCP251XFD_REG_MASK_MIDE BIT(30)
+#define MCP251XFD_REG_MASK_MSID11 BIT(29)
+#define MCP251XFD_REG_MASK_MEID_MASK GENMASK(28, 11)
+#define MCP251XFD_REG_MASK_MSID_MASK GENMASK(10, 0)
+
+/* RAM */
+#define MCP251XFD_RAM_START 0x400
+#define MCP251XFD_RAM_SIZE SZ_2K
+
+/* Message Object */
+#define MCP251XFD_OBJ_ID_SID11 BIT(29)
+#define MCP251XFD_OBJ_ID_EID_MASK GENMASK(28, 11)
+#define MCP251XFD_OBJ_ID_SID_MASK GENMASK(10, 0)
+#define MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK GENMASK(31, 9)
+#define MCP251XFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK GENMASK(15, 9)
+#define MCP251XFD_OBJ_FLAGS_SEQ_MASK MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK
+#define MCP251XFD_OBJ_FLAGS_ESI BIT(8)
+#define MCP251XFD_OBJ_FLAGS_FDF BIT(7)
+#define MCP251XFD_OBJ_FLAGS_BRS BIT(6)
+#define MCP251XFD_OBJ_FLAGS_RTR BIT(5)
+#define MCP251XFD_OBJ_FLAGS_IDE BIT(4)
+#define MCP251XFD_OBJ_FLAGS_DLC GENMASK(3, 0)
+
+#define MCP251XFD_REG_FRAME_EFF_SID_MASK GENMASK(28, 18)
+#define MCP251XFD_REG_FRAME_EFF_EID_MASK GENMASK(17, 0)
+
+/* MCP2517/18FD SFR */
+#define MCP251XFD_REG_OSC 0xe00
+#define MCP251XFD_REG_OSC_SCLKRDY BIT(12)
+#define MCP251XFD_REG_OSC_OSCRDY BIT(10)
+#define MCP251XFD_REG_OSC_PLLRDY BIT(8)
+#define MCP251XFD_REG_OSC_CLKODIV_10 3
+#define MCP251XFD_REG_OSC_CLKODIV_4 2
+#define MCP251XFD_REG_OSC_CLKODIV_2 1
+#define MCP251XFD_REG_OSC_CLKODIV_1 0
+#define MCP251XFD_REG_OSC_CLKODIV_MASK GENMASK(6, 5)
+#define MCP251XFD_REG_OSC_SCLKDIV BIT(4)
+#define MCP251XFD_REG_OSC_LPMEN BIT(3)	/* MCP2518FD only */
+#define MCP251XFD_REG_OSC_OSCDIS BIT(2)
+#define MCP251XFD_REG_OSC_PLLEN BIT(0)
+
+#define MCP251XFD_REG_IOCON 0xe04
+#define MCP251XFD_REG_IOCON_INTOD BIT(30)
+#define MCP251XFD_REG_IOCON_SOF BIT(29)
+#define MCP251XFD_REG_IOCON_TXCANOD BIT(28)
+#define MCP251XFD_REG_IOCON_PM1 BIT(25)
+#define MCP251XFD_REG_IOCON_PM0 BIT(24)
+#define MCP251XFD_REG_IOCON_GPIO1 BIT(17)
+#define MCP251XFD_REG_IOCON_GPIO0 BIT(16)
+#define MCP251XFD_REG_IOCON_LAT1 BIT(9)
+#define MCP251XFD_REG_IOCON_LAT0 BIT(8)
+#define MCP251XFD_REG_IOCON_XSTBYEN BIT(6)
+#define MCP251XFD_REG_IOCON_TRIS1 BIT(1)
+#define MCP251XFD_REG_IOCON_TRIS0 BIT(0)
+
+#define MCP251XFD_REG_CRC 0xe08
+#define MCP251XFD_REG_CRC_FERRIE BIT(25)
+#define MCP251XFD_REG_CRC_CRCERRIE BIT(24)
+#define MCP251XFD_REG_CRC_FERRIF BIT(17)
+#define MCP251XFD_REG_CRC_CRCERRIF BIT(16)
+#define MCP251XFD_REG_CRC_IF_MASK GENMASK(17, 16)
+#define MCP251XFD_REG_CRC_MASK GENMASK(15, 0)
+
+#define MCP251XFD_REG_ECCCON 0xe0c
+#define MCP251XFD_REG_ECCCON_PARITY_MASK GENMASK(14, 8)
+#define MCP251XFD_REG_ECCCON_DEDIE BIT(2)
+#define MCP251XFD_REG_ECCCON_SECIE BIT(1)
+#define MCP251XFD_REG_ECCCON_ECCEN BIT(0)
+
+#define MCP251XFD_REG_ECCSTAT 0xe10
+#define MCP251XFD_REG_ECCSTAT_ERRADDR_MASK GENMASK(27, 16)
+#define MCP251XFD_REG_ECCSTAT_IF_MASK GENMASK(2, 1)
+#define MCP251XFD_REG_ECCSTAT_DEDIF BIT(2)
+#define MCP251XFD_REG_ECCSTAT_SECIF BIT(1)
+
+#define MCP251XFD_REG_DEVID 0xe14	/* MCP2518FD only */
+#define MCP251XFD_REG_DEVID_ID_MASK GENMASK(7, 4)
+#define MCP251XFD_REG_DEVID_REV_MASK GENMASK(3, 0)
+
+/* number of TX FIFO objects, depending on CAN mode
+ *
+ * FIFO setup: tef: 8*12 bytes = 96 bytes, tx: 8*16 bytes = 128 bytes
+ * FIFO setup: tef: 4*12 bytes = 48 bytes, tx: 4*72 bytes = 288 bytes
+ */
+#define MCP251XFD_TX_OBJ_NUM_CAN 8
+#define MCP251XFD_TX_OBJ_NUM_CANFD 4
+
+#if MCP251XFD_TX_OBJ_NUM_CAN > MCP251XFD_TX_OBJ_NUM_CANFD
+#define MCP251XFD_TX_OBJ_NUM_MAX MCP251XFD_TX_OBJ_NUM_CAN
+#else
+#define MCP251XFD_TX_OBJ_NUM_MAX MCP251XFD_TX_OBJ_NUM_CANFD
+#endif
+
+#define MCP251XFD_NAPI_WEIGHT 32
+#define MCP251XFD_TX_FIFO 1
+#define MCP251XFD_RX_FIFO(x) (MCP251XFD_TX_FIFO + 1 + (x))
+
+/* SPI commands */
+#define MCP251XFD_SPI_INSTRUCTION_RESET 0x0000
+#define MCP251XFD_SPI_INSTRUCTION_WRITE 0x2000
+#define MCP251XFD_SPI_INSTRUCTION_READ 0x3000
+#define MCP251XFD_SPI_INSTRUCTION_WRITE_CRC 0xa000
+#define MCP251XFD_SPI_INSTRUCTION_READ_CRC 0xb000
+#define MCP251XFD_SPI_INSTRUCTION_WRITE_CRC_SAFE 0xc000
+#define MCP251XFD_SPI_ADDRESS_MASK GENMASK(11, 0)
+
+#define MCP251XFD_SYSCLOCK_HZ_MAX 40000000
+#define MCP251XFD_SYSCLOCK_HZ_MIN 1000000
+#define MCP251XFD_SPICLOCK_HZ_MAX 20000000
+#define MCP251XFD_OSC_PLL_MULTIPLIER 10
+#define MCP251XFD_OSC_STAB_SLEEP_US (3 * USEC_PER_MSEC)
+#define MCP251XFD_OSC_STAB_TIMEOUT_US (10 * MCP251XFD_OSC_STAB_SLEEP_US)
+#define MCP251XFD_POLL_SLEEP_US (10)
+#define MCP251XFD_POLL_TIMEOUT_US (USEC_PER_MSEC)
+#define MCP251XFD_SOFTRESET_RETRIES_MAX 3
+#define MCP251XFD_READ_CRC_RETRIES_MAX 3
+#define MCP251XFD_ECC_CNT_MAX 2
+#define MCP251XFD_SANITIZE_SPI 1
+#define MCP251XFD_SANITIZE_CAN 1
+
+/* Silence TX MAB overflow warnings */
+#define MCP251XFD_QUIRK_MAB_NO_WARN BIT(0)
+/* Use CRC to access registers */
+#define MCP251XFD_QUIRK_CRC_REG BIT(1)
+/* Use CRC to access RX/TEF-RAM */
+#define MCP251XFD_QUIRK_CRC_RX BIT(2)
+/* Use CRC to access TX-RAM */
+#define MCP251XFD_QUIRK_CRC_TX BIT(3)
+/* Enable ECC for RAM */
+#define MCP251XFD_QUIRK_ECC BIT(4)
+/* Use Half Duplex SPI transfers */
+#define MCP251XFD_QUIRK_HALF_DUPLEX BIT(5)
+
+struct mcp251xfd_hw_tef_obj {
+	u32 id;
+	u32 flags;
+	u32 ts;
+};
+
+/* The tx_obj_raw version is used in spi async, i.e. without
+ * regmap. We have to take care of endianness ourselves.
+ */
+struct mcp251xfd_hw_tx_obj_raw {
+	__le32 id;
+	__le32 flags;
+	u8 data[sizeof_field(struct canfd_frame, data)];
+};
+
+struct mcp251xfd_hw_tx_obj_can {
+	u32 id;
+	u32 flags;
+	u8 data[sizeof_field(struct can_frame, data)];
+};
+
+struct mcp251xfd_hw_tx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u8 data[sizeof_field(struct canfd_frame, data)];
+};
+
+struct mcp251xfd_hw_rx_obj_can {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[sizeof_field(struct can_frame, data)];
+};
+
+struct mcp251xfd_hw_rx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[sizeof_field(struct canfd_frame, data)];
+};
+
+struct mcp251xfd_tef_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	/* u8 obj_num equals tx_ring->obj_num */
+	/* u8 obj_size equals sizeof(struct mcp251xfd_hw_tef_obj) */
+};
+
+struct __packed mcp251xfd_buf_cmd {
+	__be16 cmd;
+};
+
+struct __packed mcp251xfd_buf_cmd_crc {
+	__be16 cmd;
+	u8 len;
+};
+
+union mcp251xfd_tx_obj_load_buf {
+	struct __packed {
+		struct mcp251xfd_buf_cmd cmd;
+		struct mcp251xfd_hw_tx_obj_raw hw_tx_obj;
+	} nocrc;
+	struct __packed {
+		struct mcp251xfd_buf_cmd_crc cmd;
+		struct mcp251xfd_hw_tx_obj_raw hw_tx_obj;
+		__be16 crc;
+	} crc;
+} ____cacheline_aligned;
+
+union mcp251xfd_write_reg_buf {
+	struct __packed {
+		struct mcp251xfd_buf_cmd cmd;
+		u8 data[4];
+	} nocrc;
+	struct __packed {
+		struct mcp251xfd_buf_cmd_crc cmd;
+		u8 data[4];
+		__be16 crc;
+	} crc;
+} ____cacheline_aligned;
+
+struct mcp251xfd_tx_obj {
+	struct spi_message msg;
+	struct spi_transfer xfer[2];
+	union mcp251xfd_tx_obj_load_buf buf;
+};
+
+struct mcp251xfd_tx_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u16 base;
+	u8 obj_num;
+	u8 obj_size;
+
+	struct mcp251xfd_tx_obj obj[MCP251XFD_TX_OBJ_NUM_MAX];
+	union mcp251xfd_write_reg_buf rts_buf;
+};
+
+struct mcp251xfd_rx_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u16 base;
+	u8 nr;
+	u8 fifo_nr;
+	u8 obj_num;
+	u8 obj_size;
+
+	struct mcp251xfd_hw_rx_obj_canfd obj[];
+};
+
+struct __packed mcp251xfd_map_buf_nocrc {
+	struct mcp251xfd_buf_cmd cmd;
+	u8 data[256];
+} ____cacheline_aligned;
+
+struct __packed mcp251xfd_map_buf_crc {
+	struct mcp251xfd_buf_cmd_crc cmd;
+	u8 data[256 - 4];
+	__be16 crc;
+} ____cacheline_aligned;
+
+struct mcp251xfd_ecc {
+	u32 ecc_stat;
+	int cnt;
+};
+
+struct mcp251xfd_regs_status {
+	u32 intf;
+};
+
+enum mcp251xfd_model {
+	MCP251XFD_MODEL_MCP2517FD = 0x2517,
+	MCP251XFD_MODEL_MCP2518FD = 0x2518,
+	MCP251XFD_MODEL_MCP251XFD = 0xffff,	/* autodetect model */
+};
+
+struct mcp251xfd_devtype_data {
+	enum mcp251xfd_model model;
+	u32 quirks;
+};
+
+struct mcp251xfd_priv {
+	struct can_priv can;
+	struct can_rx_offload offload;
+	struct net_device *ndev;
+
+	struct regmap *map_reg;			/* register access */
+	struct regmap *map_rx;			/* RX/TEF RAM access */
+
+	struct regmap *map_nocrc;
+	struct mcp251xfd_map_buf_nocrc *map_buf_nocrc_rx;
+	struct mcp251xfd_map_buf_nocrc *map_buf_nocrc_tx;
+
+	struct regmap *map_crc;
+	struct mcp251xfd_map_buf_crc *map_buf_crc_rx;
+	struct mcp251xfd_map_buf_crc *map_buf_crc_tx;
+
+	struct spi_device *spi;
+	u32 spi_max_speed_hz_orig;
+
+	struct mcp251xfd_tef_ring tef;
+	struct mcp251xfd_tx_ring tx[1];
+	struct mcp251xfd_rx_ring *rx[1];
+
+	u8 rx_ring_num;
+
+	struct mcp251xfd_ecc ecc;
+	struct mcp251xfd_regs_status regs_status;
+
+	struct gpio_desc *rx_int;
+	struct clk *clk;
+	struct regulator *reg_vdd;
+	struct regulator *reg_xceiver;
+
+	struct mcp251xfd_devtype_data devtype_data;
+	struct can_berr_counter bec;
+};
+
+#define MCP251XFD_IS(_model) \
+static inline bool \
+mcp251xfd_is_##_model(const struct mcp251xfd_priv *priv) \
+{ \
+	return priv->devtype_data.model == MCP251XFD_MODEL_MCP##_model##FD; \
+}
+
+MCP251XFD_IS(2517);
+MCP251XFD_IS(2518);
+MCP251XFD_IS(251X);
+
+static inline u8 mcp251xfd_first_byte_set(u32 mask)
+{
+	return (mask & 0x0000ffff) ?
+		((mask & 0x000000ff) ? 0 : 1) :
+		((mask & 0x00ff0000) ? 2 : 3);
+}
+
+static inline u8 mcp251xfd_last_byte_set(u32 mask)
+{
+	return (mask & 0xffff0000) ?
+		((mask & 0xff000000) ? 3 : 2) :
+		((mask & 0x0000ff00) ? 1 : 0);
+}
+
+static inline __be16 mcp251xfd_cmd_reset(void)
+{
+	return cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_RESET);
+}
+
+static inline void
+mcp251xfd_spi_cmd_read_nocrc(struct mcp251xfd_buf_cmd *cmd, u16 addr)
+{
+	cmd->cmd = cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_READ | addr);
+}
+
+static inline void
+mcp251xfd_spi_cmd_write_nocrc(struct mcp251xfd_buf_cmd *cmd, u16 addr)
+{
+	cmd->cmd = cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_WRITE | addr);
+}
+
+static inline bool mcp251xfd_reg_in_ram(unsigned int reg)
+{
+	static const struct regmap_range range =
+		regmap_reg_range(MCP251XFD_RAM_START,
+				 MCP251XFD_RAM_START + MCP251XFD_RAM_SIZE - 4);
+
+	return regmap_reg_in_range(reg, &range);
+}
+
+static inline void
+__mcp251xfd_spi_cmd_crc_set_len(struct mcp251xfd_buf_cmd_crc *cmd,
+				u16 len, bool in_ram)
+{
+	/* Number of u32 for RAM access, number of u8 otherwise. */
+	if (in_ram)
+		cmd->len = len >> 2;
+	else
+		cmd->len = len;
+}
+
+static inline void
+mcp251xfd_spi_cmd_crc_set_len_in_ram(struct mcp251xfd_buf_cmd_crc *cmd, u16 len)
+{
+	__mcp251xfd_spi_cmd_crc_set_len(cmd, len, true);
+}
+
+static inline void
+mcp251xfd_spi_cmd_crc_set_len_in_reg(struct mcp251xfd_buf_cmd_crc *cmd, u16 len)
+{
+	__mcp251xfd_spi_cmd_crc_set_len(cmd, len, false);
+}
+
+static inline void
+mcp251xfd_spi_cmd_read_crc_set_addr(struct mcp251xfd_buf_cmd_crc *cmd, u16 addr)
+{
+	cmd->cmd = cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_READ_CRC | addr);
+}
+
+static inline void
+mcp251xfd_spi_cmd_read_crc(struct mcp251xfd_buf_cmd_crc *cmd,
+			   u16 addr, u16 len)
+{
+	mcp251xfd_spi_cmd_read_crc_set_addr(cmd, addr);
+	__mcp251xfd_spi_cmd_crc_set_len(cmd, len, mcp251xfd_reg_in_ram(addr));
+}
+
+static inline void
+mcp251xfd_spi_cmd_write_crc_set_addr(struct mcp251xfd_buf_cmd_crc *cmd,
+				     u16 addr)
+{
+	cmd->cmd = cpu_to_be16(MCP251XFD_SPI_INSTRUCTION_WRITE_CRC | addr);
+}
+
+static inline void
+mcp251xfd_spi_cmd_write_crc(struct mcp251xfd_buf_cmd_crc *cmd,
+			    u16 addr, u16 len)
+{
+	mcp251xfd_spi_cmd_write_crc_set_addr(cmd, addr);
+	__mcp251xfd_spi_cmd_crc_set_len(cmd, len, mcp251xfd_reg_in_ram(addr));
+}
+
+static inline u8 *
+mcp251xfd_spi_cmd_write(const struct mcp251xfd_priv *priv,
+			union mcp251xfd_write_reg_buf *write_reg_buf,
+			u16 addr)
+{
+	u8 *data;
+
+	if (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG) {
+		mcp251xfd_spi_cmd_write_crc_set_addr(&write_reg_buf->crc.cmd,
+						     addr);
+		data = write_reg_buf->crc.data;
+	} else {
+		mcp251xfd_spi_cmd_write_nocrc(&write_reg_buf->nocrc.cmd,
+					      addr);
+		data = write_reg_buf->nocrc.data;
+	}
+
+	return data;
+}
+
+static inline u16 mcp251xfd_get_tef_obj_addr(u8 n)
+{
+	return MCP251XFD_RAM_START +
+		sizeof(struct mcp251xfd_hw_tef_obj) * n;
+}
+
+static inline u16
+mcp251xfd_get_tx_obj_addr(const struct mcp251xfd_tx_ring *ring, u8 n)
+{
+	return ring->base + ring->obj_size * n;
+}
+
+static inline u16
+mcp251xfd_get_rx_obj_addr(const struct mcp251xfd_rx_ring *ring, u8 n)
+{
+	return ring->base + ring->obj_size * n;
+}
+
+static inline u8 mcp251xfd_get_tef_head(const struct mcp251xfd_priv *priv)
+{
+	return priv->tef.head & (priv->tx->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_tef_tail(const struct mcp251xfd_priv *priv)
+{
+	return priv->tef.tail & (priv->tx->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_tef_len(const struct mcp251xfd_priv *priv)
+{
+	return priv->tef.head - priv->tef.tail;
+}
+
+static inline u8 mcp251xfd_get_tef_linear_len(const struct mcp251xfd_priv *priv)
+{
+	u8 len;
+
+	len = mcp251xfd_get_tef_len(priv);
+
+	return min_t(u8, len, priv->tx->obj_num - mcp251xfd_get_tef_tail(priv));
+}
+
+static inline u8 mcp251xfd_get_tx_head(const struct mcp251xfd_tx_ring *ring)
+{
+	return ring->head & (ring->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_tx_tail(const struct mcp251xfd_tx_ring *ring)
+{
+	return ring->tail & (ring->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_tx_free(const struct mcp251xfd_tx_ring *ring)
+{
+	return ring->obj_num - (ring->head - ring->tail);
+}
+
+static inline int
+mcp251xfd_get_tx_nr_by_addr(const struct mcp251xfd_tx_ring *tx_ring, u8 *nr,
+			    u16 addr)
+{
+	if (addr < mcp251xfd_get_tx_obj_addr(tx_ring, 0) ||
+	    addr >= mcp251xfd_get_tx_obj_addr(tx_ring, tx_ring->obj_num))
+		return -ENOENT;
+
+	*nr = (addr - mcp251xfd_get_tx_obj_addr(tx_ring, 0)) /
+		tx_ring->obj_size;
+
+	return 0;
+}
+
+static inline u8 mcp251xfd_get_rx_head(const struct mcp251xfd_rx_ring *ring)
+{
+	return ring->head & (ring->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_rx_tail(const struct mcp251xfd_rx_ring *ring)
+{
+	return ring->tail & (ring->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_rx_len(const struct mcp251xfd_rx_ring *ring)
+{
+	return ring->head - ring->tail;
+}
+
+static inline u8
+mcp251xfd_get_rx_linear_len(const struct mcp251xfd_rx_ring *ring)
+{
+	u8 len;
+
+	len = mcp251xfd_get_rx_len(ring);
+
+	return min_t(u8, len, ring->obj_num - mcp251xfd_get_rx_tail(ring));
+}
+
+#define mcp251xfd_for_each_tx_obj(ring, _obj, n) \
+	for ((n) = 0, (_obj) = &(ring)->obj[(n)]; \
+	     (n) < (ring)->obj_num; \
+	     (n)++, (_obj) = &(ring)->obj[(n)])
+
+#define mcp251xfd_for_each_rx_ring(priv, ring, n) \
+	for ((n) = 0, (ring) = *((priv)->rx + (n)); \
+	     (n) < (priv)->rx_ring_num; \
+	     (n)++, (ring) = *((priv)->rx + (n)))
+
+int mcp251xfd_regmap_init(struct mcp251xfd_priv *priv);
+u16 mcp251xfd_crc16_compute2(const void *cmd, size_t cmd_size,
+			     const void *data, size_t data_size);
+u16 mcp251xfd_crc16_compute(const void *data, size_t data_size);
+
+#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/Kconfig b/drivers/net/can/spi/mcp25xxfd/Kconfig
deleted file mode 100644
index f720f1377612..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/Kconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-config CAN_MCP25XXFD
-	tristate "Microchip MCP25xxFD SPI CAN controllers"
-	depends on HAS_DMA
-	help
-	  Driver for the Microchip MCP25XXFD SPI FD-CAN controller family.
diff --git a/drivers/net/can/spi/mcp25xxfd/Makefile b/drivers/net/can/spi/mcp25xxfd/Makefile
deleted file mode 100644
index 04e6fcbb3676..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/Makefile
+++ /dev/null
@@ -1,18 +0,0 @@
-#
-#  Makefile for the Linux Controller Area Network SPI drivers.
-#
-obj-$(CONFIG_CAN_MCP25XXFD)	+= mcp25xxfd.o
-mcp25xxfd-objs			:= mcp25xxfd_base.o
-mcp25xxfd-objs			+= mcp25xxfd_can.o
-mcp25xxfd-objs			+= mcp25xxfd_can_debugfs.o
-mcp25xxfd-objs			+= mcp25xxfd_can_fifo.o
-mcp25xxfd-objs			+= mcp25xxfd_can_int.o
-mcp25xxfd-objs			+= mcp25xxfd_can_rx.o
-mcp25xxfd-objs			+= mcp25xxfd_can_tx.o
-mcp25xxfd-objs			+= mcp25xxfd_clock.o
-mcp25xxfd-objs			+= mcp25xxfd_cmd.o
-mcp25xxfd-objs			+= mcp25xxfd_crc.o
-mcp25xxfd-objs			+= mcp25xxfd_debugfs.o
-mcp25xxfd-objs			+= mcp25xxfd_ecc.o
-mcp25xxfd-objs			+= mcp25xxfd_gpio.o
-mcp25xxfd-objs			+= mcp25xxfd_int.o
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c
deleted file mode 100644
index d9396e8819e8..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.c
+++ /dev/null
@@ -1,286 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-
-#include "mcp25xxfd_base.h"
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_clock.h"
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_debugfs.h"
-#include "mcp25xxfd_ecc.h"
-#include "mcp25xxfd_gpio.h"
-#include "mcp25xxfd_int.h"
-#include "mcp25xxfd_priv.h"
-
-/* Device description and rational:
- *
- * The mcp25xxfd is a CanFD controller that also supports can2.0 only
- * modes.
- * It is connected via spi to the host and requires at minimum a single
- * irq line in addition to the SPI lines - it is not mentioned explicitly
- * in the documentation but in principle SPI 3-wire should be possible.
- *
- * The clock connected is typically 4MHz, 20MHz or 40MHz.
- * When using a 4MHz clock the controller can use an integrated PLL to
- * get 40MHz.
- *
- * The controller itself has 2KB of SRAM for CAN-data.
- * ECC can get enabled for SRAM.
- * CRC-16 checksumming of SPI transfers can get implemented
- *   - some optimization options may not be efficient in such a situation.
- *   - more SPI bus bandwidth is used for transfer of CRCs and
- *     transfer length information
- *
- * It also contains 2 GPIO pins that can get used either as interrupt lines
- * or GPIO IN or Out or STANDBY flags.
- * In addition there is a PIN that allows output of a (divided) clock out
- * or as a SOF (Start of Can FRAME) interrupt line - e.g for wakeup.
- */
-
-int mcp25xxfd_base_power_enable(struct regulator *reg, int enable)
-{
-	if (IS_ERR_OR_NULL(reg))
-		return 0;
-
-	if (enable)
-		return regulator_enable(reg);
-	else
-		return regulator_disable(reg);
-}
-
-static const struct of_device_id mcp25xxfd_of_match[] = {
-	{
-		.compatible	= "microchip,mcp2517fd",
-		.data		= (void *)CAN_MCP2517FD,
-	},
-	{ }
-};
-MODULE_DEVICE_TABLE(of, mcp25xxfd_of_match);
-
-static int mcp25xxfd_base_probe(struct spi_device *spi)
-{
-	const struct of_device_id *of_id =
-		of_match_device(mcp25xxfd_of_match, &spi->dev);
-	struct mcp25xxfd_priv *priv;
-	int ret;
-
-	/* as irq_create_fwspec_mapping() can return 0, check for it */
-	if (spi->irq <= 0) {
-		dev_err(&spi->dev, "no valid irq line defined: irq = %i\n",
-			spi->irq);
-		return -EINVAL;
-	}
-
-	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	/* cross assigns */
-	spi_set_drvdata(spi, priv);
-	priv->spi = spi;
-
-	/* assign name */
-	snprintf(priv->device_name, sizeof(priv->device_name),
-		 DEVICE_NAME "-%s", dev_name(&priv->spi->dev));
-
-	/* assign model from of or driver_data */
-	if (of_id)
-		priv->model = (enum mcp25xxfd_model)of_id->data;
-	else
-		priv->model = spi_get_device_id(spi)->driver_data;
-
-	mutex_init(&priv->spi_rxtx_lock);
-
-	ret = mcp25xxfd_clock_init(priv);
-	if (ret)
-		goto out_free;
-
-	/* Configure the SPI bus */
-	spi->bits_per_word = 8;
-	ret = spi_setup(spi);
-	if (ret)
-		goto out_clk;
-
-	priv->power = devm_regulator_get_optional(&spi->dev, "vdd");
-	if (PTR_ERR(priv->power) == -EPROBE_DEFER) {
-		ret = -EPROBE_DEFER;
-		goto out_clk;
-	}
-
-	ret = mcp25xxfd_base_power_enable(priv->power, 1);
-	if (ret)
-		goto out_clk;
-
-	/* this will also enable the MCP25XXFD_CLK_USER_CAN clock */
-	ret = mcp25xxfd_clock_probe(priv);
-	if (ret)
-		goto out_probe;
-
-	/* enable the can controller clock */
-	ret = mcp25xxfd_clock_start(priv, MCP25XXFD_CLK_USER_CAN);
-	if (ret)
-		goto out_probe;
-
-	/* try to identify the can-controller - we need the clock here */
-	ret = mcp25xxfd_can_probe(priv);
-	if (ret)
-		goto out_ctlclk;
-
-	/* add debugfs */
-	mcp25xxfd_debugfs_setup(priv);
-
-	/* disable interrupts */
-	ret = mcp25xxfd_int_enable(priv, false);
-	if (ret)
-		goto out_debugfs;
-
-	/* setup ECC for SRAM */
-	ret = mcp25xxfd_ecc_enable(priv);
-	if (ret)
-		goto out_debugfs;
-
-	/* setting up GPIO */
-	ret = mcp25xxfd_gpio_setup(priv);
-	if (ret)
-		goto out_debugfs;
-
-	/* setting up CAN */
-	ret = mcp25xxfd_can_setup(priv);
-	if (ret)
-		goto out_gpio;
-
-	/* and put controller to sleep by stopping the can clock */
-	ret = mcp25xxfd_clock_stop(priv, MCP25XXFD_CLK_USER_CAN);
-	if (ret)
-		goto out_can;
-
-	dev_info(&spi->dev,
-		 "MCP%x successfully initialized.\n", priv->model);
-	return 0;
-
-out_can:
-	mcp25xxfd_can_remove(priv);
-out_gpio:
-	mcp25xxfd_gpio_remove(priv);
-out_debugfs:
-	mcp25xxfd_debugfs_remove(priv);
-out_ctlclk:
-	mcp25xxfd_clock_stop(priv, MCP25XXFD_CLK_USER_CAN);
-out_probe:
-	mcp25xxfd_base_power_enable(priv->power, 0);
-out_clk:
-	mcp25xxfd_clock_release(priv);
-out_free:
-	dev_err(&spi->dev, "Probe failed, err=%d\n", -ret);
-	return ret;
-}
-
-static int mcp25xxfd_base_remove(struct spi_device *spi)
-{
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-
-	/* remove can */
-	mcp25xxfd_can_remove(priv);
-
-	/* remove gpio */
-	mcp25xxfd_gpio_remove(priv);
-
-	/* clear all running clocks */
-	mcp25xxfd_clock_stop(priv, priv->clk_user_mask);
-
-	mcp25xxfd_debugfs_remove(priv);
-
-	mcp25xxfd_base_power_enable(priv->power, 0);
-
-	mcp25xxfd_clock_release(priv);
-
-	return 0;
-}
-
-static int __maybe_unused mcp25xxfd_base_suspend(struct device *dev)
-{
-	struct spi_device *spi = to_spi_device(dev);
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-
-	mutex_lock(&priv->clk_user_lock);
-	priv->clk_sleep_mask = priv->clk_user_mask;
-	mutex_unlock(&priv->clk_user_lock);
-
-	/* disable interrupts */
-	mcp25xxfd_int_enable(priv, false);
-
-	/* stop the clocks */
-	mcp25xxfd_clock_stop(priv, priv->clk_sleep_mask);
-
-	/* disable power to controller */
-	return mcp25xxfd_base_power_enable(priv->power, 0);
-}
-
-static int __maybe_unused mcp25xxfd_base_resume(struct device *dev)
-{
-	struct spi_device *spi = to_spi_device(dev);
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	int ret = 0;
-
-	/* enable power to controller */
-	mcp25xxfd_base_power_enable(priv->power, 1);
-
-	/* if there is no sleep mask, then there is nothing to wake */
-	if (!priv->clk_sleep_mask)
-		return 0;
-
-	/* start the clocks */
-	ret = mcp25xxfd_clock_start(priv, priv->clk_sleep_mask);
-	if (ret)
-		return 0;
-
-	/* clear the sleep mask */
-	mutex_lock(&priv->clk_user_lock);
-	priv->clk_sleep_mask = 0;
-	mutex_unlock(&priv->clk_user_lock);
-
-	/* enable the interrupts again */
-	return mcp25xxfd_int_enable(priv, true);
-}
-
-static SIMPLE_DEV_PM_OPS(mcp25xxfd_base_pm_ops, mcp25xxfd_base_suspend,
-			 mcp25xxfd_base_resume);
-
-static const struct spi_device_id mcp25xxfd_id_table[] = {
-	{
-		.name		= "mcp2517fd",
-		.driver_data	= (kernel_ulong_t)CAN_MCP2517FD,
-	},
-	{
-		.name		= "mcp2518fd",
-		.driver_data	= (kernel_ulong_t)CAN_MCP2518FD,
-	},
-	{ }
-};
-MODULE_DEVICE_TABLE(spi, mcp25xxfd_id_table);
-
-static struct spi_driver mcp25xxfd_can_driver = {
-	.driver = {
-		.name = DEVICE_NAME,
-		.of_match_table = mcp25xxfd_of_match,
-		.pm = &mcp25xxfd_base_pm_ops,
-	},
-	.id_table = mcp25xxfd_id_table,
-	.probe = mcp25xxfd_base_probe,
-	.remove = mcp25xxfd_base_remove,
-};
-module_spi_driver(mcp25xxfd_can_driver);
-
-MODULE_AUTHOR("Martin Sperl <kernel@martin.sperl.org>");
-MODULE_DESCRIPTION("Microchip 25XXFD CAN driver");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h
deleted file mode 100644
index 4559ac60645c..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_base.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_BASE_H
-#define __MCP25XXFD_BASE_H
-
-#include <linux/regulator/consumer.h>
-
-int mcp25xxfd_base_power_enable(struct regulator *reg, int enable);
-
-#endif /* __MCP25XXFD_BASE_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c
deleted file mode 100644
index 187717a3623e..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.c
+++ /dev/null
@@ -1,687 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-/* controller details
- *
- *  It has 32 FIFOs (of up to 32 CAN-frames).
- *
- * There are 4 Fifo types which can get configured:
- * * TEF - Transmission Event Fifo - which consumes FIFO 0
- *   even if it is not configured
- * * Tansmission Queue - for up to 32 Frames.
- *   this queue reorders CAN frames to get transmitted following the
- *   typical CAN dominant/recessive rules on the can bus itself.
- *   This FIFO is optional.
- * * TX FIFO: generic TX fifos that can contain arbitrary data
- *   and which come with a configurable priority for transmission
- *   It is also possible to have the Controller automatically trigger
- *   a transfer when a Filter Rule for a RTR frame matches.
- *   Each of these fifos in principle can get configured for distinct
- *   dlc sizes (8 thru 64 bytes)
- * * RX FIFO: generic RX fifo which is filled via filter-rules.
- *   Each of these fifos in principle can get configured for distinct
- *   dlc sizes (8 thru 64 bytes)
- *   Unfortunately there is no filter rule that would allow triggering
- *   on different frame sizes, so for all practical purposes the
- *   RX fifos have to be of the same size (unless one wants to experience
- *   lost data).
- * When a Can Frame is transmitted from the TX Queue or an individual
- * TX FIFO then a small TEF Frame can get added to the TEF FIFO queue
- * to log the Transmission of the frame - this includes ID, Flags
- * (including a custom identifier/index) and the timestamp (see below).
- *
- * The controller provides an optional free running counter with a divider
- * for timestamping of RX frames as well as for TEF entries.
- */
-
-#include <linux/can/core.h>
-#include <linux/can/dev.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_base.h"
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_can_debugfs.h"
-#include "mcp25xxfd_can_fifo.h"
-#include "mcp25xxfd_can_int.h"
-#include "mcp25xxfd_can_priv.h"
-#include "mcp25xxfd_can_tx.h"
-#include "mcp25xxfd_clock.h"
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_int.h"
-#include "mcp25xxfd_priv.h"
-#include "mcp25xxfd_regs.h"
-
-#include <uapi/linux/can/netlink.h>
-
-/* module parameters */
-static unsigned int bw_sharing_log2bits;
-module_param(bw_sharing_log2bits, uint, 0664);
-MODULE_PARM_DESC(bw_sharing_log2bits,
-		 "Delay between 2 transmissions in number of arbitration bit times\n");
-static bool enable_edge_filter;
-module_param(enable_edge_filter, bool, 0664);
-MODULE_PARM_DESC(enable_edge_filter,
-		 "Enable ISO11898-1:2015 edge_filtering");
-static unsigned int tdc_mode = 2;
-module_param(tdc_mode, uint, 0664);
-MODULE_PARM_DESC(tdc_mode,
-		 "Transmitter Delay Mode - 0 = disabled, 1 = fixed, 2 = auto\n");
-static unsigned int tdc_value;
-module_param(tdc_value, uint, 0664);
-MODULE_PARM_DESC(tdc_value,
-		 "Transmission Delay Value - range: [0:63] SCLK");
-static int tdc_offset = 64; /* outside of range to use computed values */
-module_param(tdc_offset, int, 0664);
-MODULE_PARM_DESC(tdc_offset,
-		 "Transmission Delay offset - range: [-64:63] SCLK");
-
-/* everything related to bit timing */
-static
-const struct can_bittiming_const mcp25xxfd_can_nominal_bittiming_const = {
-	.name           = DEVICE_NAME,
-	.tseg1_min      = 2,
-	.tseg1_max      = BIT(MCP25XXFD_CAN_NBTCFG_TSEG1_BITS),
-	.tseg2_min      = 1,
-	.tseg2_max      = BIT(MCP25XXFD_CAN_NBTCFG_TSEG2_BITS),
-	.sjw_max        = BIT(MCP25XXFD_CAN_NBTCFG_SJW_BITS),
-	.brp_min        = 1,
-	.brp_max        = BIT(MCP25XXFD_CAN_NBTCFG_BRP_BITS),
-	.brp_inc        = 1,
-};
-
-static
-const struct can_bittiming_const mcp25xxfd_can_data_bittiming_const = {
-	.name           = DEVICE_NAME,
-	.tseg1_min      = 1,
-	.tseg1_max      = BIT(MCP25XXFD_CAN_DBTCFG_TSEG1_BITS),
-	.tseg2_min      = 1,
-	.tseg2_max      = BIT(MCP25XXFD_CAN_DBTCFG_TSEG2_BITS),
-	.sjw_max        = BIT(MCP25XXFD_CAN_DBTCFG_SJW_BITS),
-	.brp_min        = 1,
-	.brp_max        = BIT(MCP25XXFD_CAN_DBTCFG_BRP_BITS),
-	.brp_inc        = 1,
-};
-
-static int mcp25xxfd_can_do_set_nominal_bittiming(struct net_device *net)
-{
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-	struct can_bittiming *bt = &cpriv->can.bittiming;
-
-	int sjw = bt->sjw;
-	int pseg2 = bt->phase_seg2;
-	int pseg1 = bt->phase_seg1;
-	int propseg = bt->prop_seg;
-	int brp = bt->brp;
-
-	int tseg1 = propseg + pseg1;
-	int tseg2 = pseg2;
-
-	/* calculate nominal bit timing */
-	cpriv->regs.nbtcfg = ((sjw - 1) << MCP25XXFD_CAN_NBTCFG_SJW_SHIFT) |
-		((tseg2 - 1) << MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT) |
-		((tseg1 - 1) << MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT) |
-		((brp - 1) << MCP25XXFD_CAN_NBTCFG_BRP_SHIFT);
-
-	return mcp25xxfd_cmd_write(cpriv->priv->spi, MCP25XXFD_CAN_NBTCFG,
-				   cpriv->regs.nbtcfg);
-}
-
-static int mcp25xxfd_can_do_set_data_bittiming(struct net_device *net)
-{
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-	struct mcp25xxfd_priv *priv = cpriv->priv;
-	struct can_bittiming *bt = &cpriv->can.data_bittiming;
-	struct spi_device *spi = priv->spi;
-
-	int sjw = bt->sjw;
-	int pseg2 = bt->phase_seg2;
-	int pseg1 = bt->phase_seg1;
-	int propseg = bt->prop_seg;
-	int brp = bt->brp;
-
-	int tseg1 = propseg + pseg1;
-	int tseg2 = pseg2;
-
-	int tdco;
-	int ret;
-
-	/* set up Transmitter delay compensation */
-	cpriv->regs.tdc = 0;
-	/* configure TDC mode */
-	if (tdc_mode < 4)
-		cpriv->regs.tdc = tdc_mode << MCP25XXFD_CAN_TDC_TDCMOD_SHIFT;
-	else
-		cpriv->regs.tdc = MCP25XXFD_CAN_TDC_TDCMOD_AUTO <<
-			MCP25XXFD_CAN_TDC_TDCMOD_SHIFT;
-
-	/* configure TDC offsets */
-	if ((tdc_offset >= -64) && tdc_offset < 64)
-		tdco = tdc_offset;
-	else
-		tdco = clamp_t(int, bt->brp * tseg1, -64, 63);
-	cpriv->regs.tdc |= (tdco << MCP25XXFD_CAN_TDC_TDCO_SHIFT) &
-		MCP25XXFD_CAN_TDC_TDCO_MASK;
-
-	/* configure TDC value */
-	if (tdc_value < 64)
-		cpriv->regs.tdc |= tdc_value << MCP25XXFD_CAN_TDC_TDCV_SHIFT;
-
-	/* enable edge filtering */
-	if (enable_edge_filter)
-		cpriv->regs.tdc |= MCP25XXFD_CAN_TDC_EDGFLTEN;
-
-	/* set TDC */
-	ret = mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_TDC, cpriv->regs.tdc);
-	if (ret)
-		return ret;
-
-	/* calculate data bit timing */
-	cpriv->regs.dbtcfg = ((sjw - 1) << MCP25XXFD_CAN_DBTCFG_SJW_SHIFT) |
-		((tseg2 - 1) << MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT) |
-		((tseg1 - 1) << MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT) |
-		((brp - 1) << MCP25XXFD_CAN_DBTCFG_BRP_SHIFT);
-
-	return mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_DBTCFG,
-				   cpriv->regs.dbtcfg);
-}
-
-int mcp25xxfd_can_get_mode(struct mcp25xxfd_priv *priv, u32 *reg)
-{
-	int ret;
-
-	ret = mcp25xxfd_cmd_read(priv->spi, MCP25XXFD_CAN_CON, reg);
-	if (ret)
-		return ret;
-
-	return (*reg & MCP25XXFD_CAN_CON_OPMOD_MASK) >>
-		MCP25XXFD_CAN_CON_OPMOD_SHIFT;
-}
-
-int mcp25xxfd_can_switch_mode_no_wait(struct mcp25xxfd_priv *priv,
-				      u32 *reg, int mode)
-{
-	u32 dummy;
-	int ret;
-
-	/* get the current mode/register - if reg is NULL
-	 * when the can controller is not setup yet
-	 * typically by calling mcp25xxfd_can_sleep_mode
-	 * (this only happens during initialization phase)
-	 */
-	if (reg) {
-		if (!*reg) {
-			ret = mcp25xxfd_can_get_mode(priv, reg);
-			if (ret < 0)
-				return ret;
-		}
-	} else {
-		/* alternatively use dummy */
-		dummy = 0;
-		reg = &dummy;
-	}
-
-	/* compute the effective mode in osc*/
-	*reg &= ~(MCP25XXFD_CAN_CON_REQOP_MASK |
-		  MCP25XXFD_CAN_CON_OPMOD_MASK);
-	*reg |= (mode << MCP25XXFD_CAN_CON_REQOP_SHIFT) |
-		(mode << MCP25XXFD_CAN_CON_OPMOD_SHIFT);
-
-	/* if the opmode is sleep then the oscilator will be disabled
-	 * and also not ready, so fake this change
-	 */
-	if (mode == MCP25XXFD_CAN_CON_MODE_SLEEP)
-		mcp25xxfd_clock_fake_sleep(priv);
-
-	/* request the mode switch */
-	return mcp25xxfd_cmd_write(priv->spi, MCP25XXFD_CAN_CON, *reg);
-}
-
-int mcp25xxfd_can_switch_mode(struct mcp25xxfd_priv *priv, u32 *reg, int mode)
-{
-	int ret, i;
-
-	/* trigger the mode switch itself */
-	ret = mcp25xxfd_can_switch_mode_no_wait(priv, reg, mode);
-	if (ret)
-		return ret;
-
-	/* if we are in now sleep mode then return immediately
-	 * the controller does not respond back!
-	 */
-	if (mode == MCP25XXFD_CAN_CON_MODE_SLEEP)
-		return 0;
-
-	/* wait for it to stabilize/switch mode
-	 * we assume 256 rounds should be enough as this is > 12ms
-	 * at 1MHz Can Bus speed without any extra overhead
-	 *
-	 * The assumption here is that it depends on bus activity
-	 * how long it takes the controller to switch modes
-	 */
-	for (i = 0; i < 256; i++) {
-		/* get the mode */
-		ret = mcp25xxfd_can_get_mode(priv, reg);
-		if (ret < 0)
-			return ret;
-		/* check that we have reached our mode */
-		if (ret == mode)
-			return 0;
-	}
-
-	dev_err(&priv->spi->dev, "Failed to switch to mode %u in time\n",
-		mode);
-	return -ETIMEDOUT;
-}
-
-static int mcp25xxfd_can_probe_modeswitch(struct mcp25xxfd_priv *priv)
-{
-	u32 mode_data;
-	int ret;
-
-	/* so we should be in config mode now, so move to INT_LOOPBACK */
-	ret = mcp25xxfd_can_switch_mode(priv, &mode_data,
-					MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK);
-	if (ret) {
-		dev_err(&priv->spi->dev,
-			"Failed to switch into loopback mode\n");
-		return ret;
-	}
-
-	/* and back into config mode */
-	ret = mcp25xxfd_can_switch_mode(priv, &mode_data,
-					MCP25XXFD_CAN_CON_MODE_CONFIG);
-	if (ret) {
-		dev_err(&priv->spi->dev,
-			"Failed to switch back to config mode\n");
-		return ret;
-	}
-
-	/* so we have checked basic functionality successfully */
-	return 0;
-}
-
-int mcp25xxfd_can_sleep_mode(struct mcp25xxfd_priv *priv)
-{
-	return mcp25xxfd_can_switch_mode(priv, NULL,
-					 MCP25XXFD_CAN_CON_MODE_SLEEP);
-}
-
-int mcp25xxfd_can_probe(struct mcp25xxfd_priv *priv)
-{
-	struct spi_device *spi = priv->spi;
-	u32 mode_data;
-	int mode, ret;
-
-	/* read TXQCON - the TXEN bit should always read as 1 */
-	ret = mcp25xxfd_cmd_read(spi, MCP25XXFD_CAN_TXQCON, &mode_data);
-	if (ret)
-		return ret;
-	if ((mode_data & MCP25XXFD_CAN_TXQCON_TXEN) == 0) {
-		dev_err(&spi->dev,
-			"Register TXQCON does not have bit TXEN set - reads as %08x - this may be a problem with spi bus signal quality - try reducing spi-clock speed if this can get reproduced",
-			mode_data);
-		return -EINVAL;
-	}
-
-	/* try to get the current mode */
-	mode = mcp25xxfd_can_get_mode(priv, &mode_data);
-	if (mode < 0)
-		return mode;
-
-	/* we would expect to be in config mode, as a SPI-reset should
-	 * have moved us into config mode.
-	 * But then the documentation says that SPI-reset may only work
-	 * reliably when already in config mode
-	 */
-
-	/* so if we are in config mode then everything is fine
-	 * and we check that a mode switch works propperly
-	 */
-	if (mode == MCP25XXFD_CAN_CON_MODE_CONFIG)
-		return mcp25xxfd_can_probe_modeswitch(priv);
-
-	/* if the bitfield is 0 then there is something is wrong */
-	if (!mode_data) {
-		dev_err(&spi->dev,
-			"got controller config register reading as 0\n");
-		return -EINVAL;
-	}
-
-	/* any other mode is unexpected */
-	dev_err(&spi->dev,
-		"Found controller in unexpected mode %i - register reads as %08x\n",
-		mode, mode_data);
-
-	/* so try to move to config mode
-	 * if this fails, then everything is lost and the controller
-	 * is not identified
-	 * This action MAY be destructive if a different device is connected
-	 * but note that the first hurdle (oscillator) was already
-	 * successful - so we should be safe...
-	 */
-	ret = mcp25xxfd_can_switch_mode(priv, &mode_data,
-					MCP25XXFD_CAN_CON_MODE_CONFIG);
-	if (ret) {
-		dev_err(&priv->spi->dev,
-			"Mode did not switch to config as expected - could not identify controller - register reads as %08x\n",
-			mode_data);
-		return -EINVAL;
-	}
-	/* check that modeswitch is really working */
-	return mcp25xxfd_can_probe_modeswitch(priv);
-}
-
-static int mcp25xxfd_can_config(struct net_device *net)
-{
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-	struct mcp25xxfd_priv *priv = cpriv->priv;
-	struct spi_device *spi = priv->spi;
-	int ret;
-
-	/* setup value of con_register */
-	cpriv->regs.con = MCP25XXFD_CAN_CON_STEF; /* enable TEF, disable TXQ */
-
-	/* transmission bandwidth sharing bits */
-	if (bw_sharing_log2bits > 12)
-		bw_sharing_log2bits = 12;
-	cpriv->regs.con |= bw_sharing_log2bits <<
-		MCP25XXFD_CAN_CON_TXBWS_SHIFT;
-
-	/* non iso FD mode */
-	if (!(cpriv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
-		cpriv->regs.con |= MCP25XXFD_CAN_CON_ISOCRCEN;
-
-	/* one shot */
-	if (cpriv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
-		cpriv->regs.con |= MCP25XXFD_CAN_CON_RTXAT;
-
-	/* apply it now together with a mode switch */
-	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
-					MCP25XXFD_CAN_CON_MODE_CONFIG);
-	if (ret)
-		return 0;
-
-	/* time stamp control register - 1ns resolution */
-	cpriv->regs.tscon = 0;
-	ret = mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_TBC, 0);
-	if (ret)
-		return ret;
-
-	cpriv->regs.tscon = MCP25XXFD_CAN_TSCON_TBCEN |
-		((cpriv->can.clock.freq / 1000000)
-		 << MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT);
-	ret = mcp25xxfd_cmd_write(spi, MCP25XXFD_CAN_TSCON, cpriv->regs.tscon);
-	if (ret)
-		return ret;
-
-	/* setup fifos */
-	ret = mcp25xxfd_can_fifo_setup(cpriv);
-	if (ret)
-		return ret;
-
-	/* setup can bittiming now - the do_set_bittiming methods
-	 * are not used as they get callled before open
-	 */
-	ret = mcp25xxfd_can_do_set_nominal_bittiming(net);
-	if (ret)
-		return ret;
-	ret = mcp25xxfd_can_do_set_data_bittiming(net);
-	if (ret)
-		return ret;
-
-	return ret;
-}
-
-/* mode setting */
-static int mcp25xxfd_can_do_set_mode(struct net_device *net,
-				     enum can_mode mode)
-{
-	switch (mode) {
-	case CAN_MODE_START:
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-/* binary error counters */
-static int mcp25xxfd_can_get_berr_counter(const struct net_device *net,
-					  struct can_berr_counter *bec)
-{
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-
-	bec->txerr = (cpriv->status.trec & MCP25XXFD_CAN_TREC_TEC_MASK) >>
-		MCP25XXFD_CAN_TREC_TEC_SHIFT;
-	bec->rxerr = (cpriv->status.trec & MCP25XXFD_CAN_TREC_REC_MASK) >>
-		MCP25XXFD_CAN_TREC_REC_SHIFT;
-
-	return 0;
-}
-
-static int mcp25xxfd_can_open(struct net_device *net)
-{
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-	struct spi_device *spi = cpriv->priv->spi;
-	int ret;
-
-	ret = open_candev(net);
-	if (ret) {
-		netdev_err(net, "unable to set initial baudrate!\n");
-		return ret;
-	}
-
-	/* clear those statistics */
-	memset(&cpriv->stats, 0, sizeof(cpriv->stats));
-
-	/* request an IRQ but keep disabled for now */
-	ret = request_threaded_irq(spi->irq, NULL,
-				   mcp25xxfd_can_int,
-				   IRQF_ONESHOT | IRQF_TRIGGER_LOW,
-				   cpriv->priv->device_name, cpriv);
-	if (ret) {
-		dev_err(&spi->dev, "failed to acquire irq %d - %i\n",
-			spi->irq, ret);
-		goto out_candev;
-	}
-	disable_irq(spi->irq);
-	cpriv->irq.allocated = true;
-	cpriv->irq.enabled = false;
-
-	/* enable power to the transceiver */
-	ret = mcp25xxfd_base_power_enable(cpriv->transceiver, 1);
-	if (ret)
-		goto out_irq;
-
-	/* enable clock (so that spi works) */
-	ret = mcp25xxfd_clock_start(cpriv->priv, MCP25XXFD_CLK_USER_CAN);
-	if (ret)
-		goto out_transceiver;
-
-	/* configure controller for reception */
-	ret = mcp25xxfd_can_config(net);
-	if (ret)
-		goto out_canclock;
-
-	/* setting up state */
-	cpriv->can.state = CAN_STATE_ERROR_ACTIVE;
-
-	/* enable interrupts */
-	ret = mcp25xxfd_int_enable(cpriv->priv, true);
-	if (ret)
-		goto out_canconfig;
-
-	/* switch to active mode */
-	printk(KERN_ALERT "%s7: mtu=%u CAN_MTU=%lu\n",
-	       __func__, net->mtu, CAN_MTU);
-	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
-					(net->mtu == CAN_MTU) ?
-					MCP25XXFD_CAN_CON_MODE_CAN2_0 :
-					MCP25XXFD_CAN_CON_MODE_MIXED);
-	if (ret)
-		goto out_int;
-
-	/* start the tx_queue */
-	mcp25xxfd_can_tx_queue_manage(cpriv,
-				      MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED);
-
-	return 0;
-
-out_int:
-	mcp25xxfd_int_enable(cpriv->priv, false);
-out_canconfig:
-	mcp25xxfd_can_fifo_release(cpriv);
-out_canclock:
-	mcp25xxfd_clock_stop(cpriv->priv, MCP25XXFD_CLK_USER_CAN);
-out_transceiver:
-	mcp25xxfd_base_power_enable(cpriv->transceiver, 0);
-out_irq:
-	free_irq(spi->irq, cpriv);
-	cpriv->irq.allocated = false;
-	cpriv->irq.enabled = false;
-out_candev:
-	close_candev(net);
-	return ret;
-}
-
-static void mcp25xxfd_can_shutdown(struct mcp25xxfd_can_priv *cpriv)
-{
-	/* switch us to CONFIG mode - this disables the controller */
-	mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
-				  MCP25XXFD_CAN_CON_MODE_CONFIG);
-}
-
-static int mcp25xxfd_can_stop(struct net_device *net)
-{
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-	struct mcp25xxfd_priv *priv = cpriv->priv;
-	struct spi_device *spi = priv->spi;
-
-	/* disable inerrupts on controller */
-	mcp25xxfd_int_enable(cpriv->priv, false);
-
-	/* stop transmit queue */
-	mcp25xxfd_can_tx_queue_manage(cpriv,
-				      MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED);
-
-	/* release fifos and debugfs */
-	mcp25xxfd_can_fifo_release(cpriv);
-
-	/* shutdown the can controller */
-	mcp25xxfd_can_shutdown(cpriv);
-
-	/* stop the clock */
-	mcp25xxfd_clock_stop(cpriv->priv, MCP25XXFD_CLK_USER_CAN);
-
-	/* and disable the transceiver */
-	mcp25xxfd_base_power_enable(cpriv->transceiver, 0);
-
-	/* disable interrupt on host */
-	free_irq(spi->irq, cpriv);
-	cpriv->irq.allocated = false;
-	cpriv->irq.enabled = false;
-
-	/* close the can_decice */
-	close_candev(net);
-
-	return 0;
-}
-
-static const struct net_device_ops mcp25xxfd_netdev_ops = {
-	.ndo_open = mcp25xxfd_can_open,
-	.ndo_stop = mcp25xxfd_can_stop,
-	.ndo_start_xmit = mcp25xxfd_can_tx_start_xmit,
-	.ndo_change_mtu = can_change_mtu,
-};
-
-/* probe and remove */
-int mcp25xxfd_can_setup(struct mcp25xxfd_priv *priv)
-{
-	struct spi_device *spi = priv->spi;
-	struct mcp25xxfd_can_priv *cpriv;
-	struct net_device *net;
-	struct regulator *transceiver;
-	int ret;
-
-	/* get transceiver power regulator*/
-	transceiver = devm_regulator_get_optional(&spi->dev,
-						  "xceiver");
-	if (PTR_ERR(transceiver) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-
-	/* allocate can device */
-	net = alloc_candev(sizeof(*cpriv), TX_ECHO_SKB_MAX);
-	if (!net)
-		return -ENOMEM;
-
-	/* and do some cross-asignments */
-	cpriv = netdev_priv(net);
-	cpriv->priv = priv;
-	priv->cpriv = cpriv;
-
-	/* setup network */
-	SET_NETDEV_DEV(net, &spi->dev);
-	net->netdev_ops = &mcp25xxfd_netdev_ops;
-	net->flags |= IFF_ECHO;
-
-	/* assign transceiver */
-	cpriv->transceiver = transceiver;
-
-	/* setup can */
-	cpriv->can.clock.freq = priv->clock_freq;
-	cpriv->can.bittiming_const =
-		&mcp25xxfd_can_nominal_bittiming_const;
-	cpriv->can.data_bittiming_const =
-		&mcp25xxfd_can_data_bittiming_const;
-	/* we are not setting bit-timing methods here as they get
-	 * called by the framework before open so the controller is
-	 * still in sleep mode, which does not help
-	 * things are configured in open instead
-	 */
-	cpriv->can.do_set_mode =
-		mcp25xxfd_can_do_set_mode;
-	cpriv->can.do_get_berr_counter =
-		mcp25xxfd_can_get_berr_counter;
-	cpriv->can.ctrlmode_supported =
-		CAN_CTRLMODE_FD |
-		CAN_CTRLMODE_FD_NON_ISO |
-		CAN_CTRLMODE_LOOPBACK |
-		CAN_CTRLMODE_LISTENONLY |
-		CAN_CTRLMODE_BERR_REPORTING |
-		CAN_CTRLMODE_ONE_SHOT;
-
-	ret = register_candev(net);
-	if (ret) {
-		dev_err(&spi->dev, "Failed to register can device\n");
-		goto out;
-	}
-
-	mcp25xxfd_can_debugfs_setup(cpriv);
-
-	return 0;
-out:
-	free_candev(net);
-	priv->cpriv = NULL;
-
-	return ret;
-}
-
-void mcp25xxfd_can_remove(struct mcp25xxfd_priv *priv)
-{
-	if (priv->cpriv) {
-		unregister_candev(priv->cpriv->can.dev);
-		free_candev(priv->cpriv->can.dev);
-		priv->cpriv = NULL;
-	}
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h
deleted file mode 100644
index b480220d4ccd..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_H
-#define __MCP25XXFD_CAN_H
-
-#include "mcp25xxfd_can_debugfs.h"
-#include "mcp25xxfd_can_priv.h"
-#include "mcp25xxfd_priv.h"
-#include "mcp25xxfd_regs.h"
-
-/* get the optimal controller target mode */
-static inline
-int mcp25xxfd_can_targetmode(struct mcp25xxfd_can_priv *cpriv)
-{
-	return (cpriv->can.dev->mtu == CAN_MTU) ?
-		MCP25XXFD_CAN_CON_MODE_CAN2_0 : MCP25XXFD_CAN_CON_MODE_MIXED;
-}
-
-static inline
-void mcp25xxfd_can_queue_frame(struct mcp25xxfd_can_priv *cpriv,
-			       s32 fifo, u16 ts, bool is_rx)
-{
-	int idx = cpriv->fifos.submit_queue_count;
-
-	cpriv->fifos.submit_queue[idx].fifo = fifo;
-	cpriv->fifos.submit_queue[idx].ts = ts;
-	cpriv->fifos.submit_queue[idx].is_rx = is_rx;
-
-	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.submit_queue_count);
-}
-
-/* get the current controller mode */
-int mcp25xxfd_can_get_mode(struct mcp25xxfd_priv *priv, u32 *reg);
-
-/* to put us to sleep fully we need the CAN controller to enter sleep mode */
-int mcp25xxfd_can_sleep_mode(struct mcp25xxfd_priv *priv);
-
-/* switch controller mode */
-int mcp25xxfd_can_switch_mode_no_wait(struct mcp25xxfd_priv *priv,
-				      u32 *reg, int mode);
-int mcp25xxfd_can_switch_mode(struct mcp25xxfd_priv *priv,
-			      u32 *reg, int mode);
-
-/* probe the can controller */
-int mcp25xxfd_can_probe(struct mcp25xxfd_priv *priv);
-
-/* setup and the can controller net interface */
-int mcp25xxfd_can_setup(struct mcp25xxfd_priv *priv);
-void mcp25xxfd_can_remove(struct mcp25xxfd_priv *priv);
-
-#endif /* __MCP25XXFD_CAN_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c
deleted file mode 100644
index 013a1a30963a..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.c
+++ /dev/null
@@ -1,236 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifdef CONFIG_DEBUG_FS
-
-#include <linux/dcache.h>
-#include <linux/debugfs.h>
-#include "mcp25xxfd_can_debugfs.h"
-#include "mcp25xxfd_can_priv.h"
-#include "mcp25xxfd_can_tx.h"
-
-static void mcp25xxfd_can_debugfs_regs(struct mcp25xxfd_can_priv *cpriv,
-				       struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("regs", root);
-
-	debugfs_create_x32("con",    0444, dir, &cpriv->regs.con);
-	debugfs_create_x32("tdc",    0444, dir, &cpriv->regs.tdc);
-	debugfs_create_x32("tscon",  0444, dir, &cpriv->regs.tscon);
-	debugfs_create_x32("tefcon", 0444, dir, &cpriv->regs.tscon);
-	debugfs_create_x32("nbtcfg", 0444, dir, &cpriv->regs.nbtcfg);
-	debugfs_create_x32("dbtcfg", 0444, dir, &cpriv->regs.dbtcfg);
-}
-
-static void mcp25xxfd_can_debugfs_status(struct mcp25xxfd_can_priv *cpriv,
-					 struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("status", root);
-
-	debugfs_create_x32("intf",    0444, dir, &cpriv->status.intf);
-	debugfs_create_x32("rx_if",   0444, dir, &cpriv->status.rxif);
-	debugfs_create_x32("tx_if",   0444, dir, &cpriv->status.txif);
-	debugfs_create_x32("rx_ovif", 0444, dir, &cpriv->status.rxovif);
-	debugfs_create_x32("tx_atif", 0444, dir, &cpriv->status.txatif);
-	debugfs_create_x32("tx_req",  0444, dir, &cpriv->status.txreq);
-	debugfs_create_x32("trec",    0444, dir, &cpriv->status.trec);
-}
-
-static void mcp25xxfd_can_debugfs_stats(struct mcp25xxfd_can_priv *cpriv,
-					struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("stats", root);
-	char name[32];
-	u64 *data;
-	int i;
-
-# define DEBUGFS_CREATE(name, var) debugfs_create_u64(name, 0444, dir, \
-						      &cpriv->stats.var)
-	DEBUGFS_CREATE("irq_calls",		 irq_calls);
-	DEBUGFS_CREATE("irq_loops",		 irq_loops);
-	DEBUGFS_CREATE("irq_thread_rescheduled", irq_thread_rescheduled);
-
-	DEBUGFS_CREATE("int_system_error",	 int_serr_count);
-	DEBUGFS_CREATE("int_system_error_tx",	 int_serr_tx_count);
-	DEBUGFS_CREATE("int_system_error_rx",	 int_serr_rx_count);
-	DEBUGFS_CREATE("int_mode_switch",	 int_mod_count);
-	DEBUGFS_CREATE("int_rx",		 int_rx_count);
-	DEBUGFS_CREATE("int_tx_attempt",	 int_txat_count);
-	DEBUGFS_CREATE("int_tef",		 int_tef_count);
-	DEBUGFS_CREATE("int_rx_overflow",	 int_rxov_count);
-	DEBUGFS_CREATE("int_ecc_error",		 int_ecc_count);
-	DEBUGFS_CREATE("int_rx_invalid_message", int_ivm_count);
-	DEBUGFS_CREATE("int_crcerror",		 int_cerr_count);
-
-	DEBUGFS_CREATE("tef_reads",		 tef_reads);
-	DEBUGFS_CREATE("tef_conservative_reads", tef_conservative_reads);
-	DEBUGFS_CREATE("tef_optimized_reads",	 tef_optimized_reads);
-	DEBUGFS_CREATE("tef_read_splits",	 tef_read_splits);
-
-	for (i = 0; i < MCP25XXFD_CAN_TEF_READ_BINS - 1; i++) {
-		snprintf(name, sizeof(name),
-			 "tef_optimized_reads_%i", i + 1);
-		data = &cpriv->stats.tef_optimized_read_sizes[i];
-		debugfs_create_u64(name, 0444, dir, data);
-	}
-	snprintf(name, sizeof(name), "tef_optimized_reads_%i+", i + 1);
-	debugfs_create_u64(name, 0444, dir,
-			   &cpriv->stats.tef_optimized_read_sizes[i]);
-
-	DEBUGFS_CREATE("tx_frames_fd",		 tx_fd_count);
-	DEBUGFS_CREATE("tx_frames_brs",		 tx_brs_count);
-
-	DEBUGFS_CREATE("rx_reads",		 rx_reads);
-	DEBUGFS_CREATE("rx_reads_prefetched_too_few",
-		       rx_reads_prefetched_too_few);
-	DEBUGFS_CREATE("rx_reads_prefetched_too_few_bytes",
-		       rx_reads_prefetched_too_few_bytes);
-	DEBUGFS_CREATE("rx_reads_prefetched_too_many",
-		       rx_reads_prefetched_too_many);
-	DEBUGFS_CREATE("rx_reads_prefetched_too_many_bytes",
-		       rx_reads_prefetched_too_many_bytes);
-	DEBUGFS_CREATE("rx_single_reads",	 rx_single_reads);
-	DEBUGFS_CREATE("rx_bulk_reads",		 rx_bulk_reads);
-
-	for (i = 0; i < MCP25XXFD_CAN_RX_BULK_READ_BINS - 1; i++) {
-		snprintf(name, sizeof(name), "rx_bulk_reads_%i", i + 1);
-		data = &cpriv->stats.rx_bulk_read_sizes[i];
-		debugfs_create_u64(name, 0444, dir, data);
-	}
-	snprintf(name, sizeof(name), "rx_bulk_reads_%i+", i + 1);
-	debugfs_create_u64(name, 0444, dir,
-			   &cpriv->stats.rx_bulk_read_sizes[i]);
-
-	if (cpriv->can.dev->mtu == CANFD_MTU)
-		debugfs_create_u32("rx_reads_prefetch_predicted_len", 0444,
-				   dir, &cpriv->rx_history.predicted_len);
-#undef DEBUGFS_CREATE
-}
-
-static void mcp25xxfd_can_debugfs_tef(struct mcp25xxfd_can_priv *cpriv,
-				      struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("tef", root);
-
-	debugfs_create_u32("count", 0444, dir, &cpriv->fifos.tef.count);
-	debugfs_create_u32("size",  0444, dir, &cpriv->fifos.tef.size);
-}
-
-static void mcp25xxfd_can_debugfs_fifo_info(struct mcp25xxfd_fifo_info *info,
-					    int index, struct dentry *root)
-{
-	struct dentry *dir;
-	char name[4];
-
-	snprintf(name, sizeof(name), "%02i", index);
-	dir = debugfs_create_dir(name, root);
-
-	debugfs_create_u32("is_rx",     0444, dir, &info->is_rx);
-	debugfs_create_x32("offset",    0444, dir, &info->offset);
-	debugfs_create_u32("priority",  0444, dir, &info->priority);
-
-	debugfs_create_u64("use_count", 0444, dir, &info->use_count);
-}
-
-static void mcp25xxfd_can_debugfs_fifos(struct mcp25xxfd_can_priv *cpriv,
-					struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("fifos", root);
-	int i;
-
-	/* now present all fifos - there is no fifo 0 */
-	for (i = 1; i < 32; i++)
-		mcp25xxfd_can_debugfs_fifo_info(&cpriv->fifos.info[i], i, dir);
-}
-
-static void mcp25xxfd_can_debugfs_rxtx_fifos(struct mcp25xxfd_fifo *d,
-					     struct dentry *root)
-{
-	int i, f;
-	char name[4];
-	char link[32];
-
-	debugfs_create_u32("count", 0444, root, &d->count);
-	debugfs_create_u32("size",  0444, root, &d->size);
-	debugfs_create_u32("start", 0444, root, &d->start);
-
-	for (f = d->start, i = 0; i < d->count; f++, i++) {
-		snprintf(name, sizeof(name), "%02i", i);
-		snprintf(link, sizeof(link), "../fifos/%02i", f);
-
-		debugfs_create_symlink(name, root, link);
-	}
-}
-
-static void mcp25xxfd_can_debugfs_rx_fifos(struct mcp25xxfd_can_priv *cpriv,
-					   struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("rx_fifos", root);
-
-	mcp25xxfd_can_debugfs_rxtx_fifos(&cpriv->fifos.rx, dir);
-}
-
-static void mcp25xxfd_can_debugfs_tx_fifos(struct mcp25xxfd_can_priv *cpriv,
-					   struct dentry *root)
-{
-	struct dentry *dir = debugfs_create_dir("tx_fifos", root);
-
-	mcp25xxfd_can_debugfs_rxtx_fifos(&cpriv->fifos.rx, dir);
-}
-
-static void mcp25xxfd_can_debugfs_tx_queue(struct mcp25xxfd_can_priv *cpriv,
-					   struct dentry *root)
-{
-	struct mcp25xxfd_tx_spi_message_queue *queue = cpriv->fifos.tx_queue;
-	struct dentry *dir;
-
-	if (!queue)
-		return;
-
-	dir = debugfs_create_dir("tx_queue", root);
-
-	debugfs_create_u32("state", 0444, dir, &queue->state);
-	debugfs_create_x32("fifos_idle", 0444, dir, &queue->idle);
-	debugfs_create_x32("fifos_in_fill_fifo_transfer",
-			   0444, dir, &queue->in_fill_fifo_transfer);
-	debugfs_create_x32("fifos_in_trigger_fifo_transfer",
-			   0444, dir, &queue->in_trigger_fifo_transfer);
-	debugfs_create_x32("fifos_in_can_transfer",
-			   0444, dir, &queue->in_can_transfer);
-	debugfs_create_x32("fifos_transferred",
-			   0444, dir, &queue->transferred);
-}
-
-void mcp25xxfd_can_debugfs_remove(struct mcp25xxfd_can_priv *cpriv)
-{
-	debugfs_remove_recursive(cpriv->debugfs_dir);
-	cpriv->debugfs_dir = NULL;
-}
-
-void mcp25xxfd_can_debugfs_setup(struct mcp25xxfd_can_priv *cpriv)
-{
-	struct dentry *root;
-
-	/* remove first as we get called during probe and also
-	 * when the can_device is configured/removed
-	 */
-	mcp25xxfd_can_debugfs_remove(cpriv);
-
-	root = debugfs_create_dir("can", cpriv->priv->debugfs_dir);
-	cpriv->debugfs_dir = root;
-
-	mcp25xxfd_can_debugfs_regs(cpriv, root);
-	mcp25xxfd_can_debugfs_stats(cpriv, root);
-	mcp25xxfd_can_debugfs_status(cpriv, root);
-	mcp25xxfd_can_debugfs_tef(cpriv, root);
-	mcp25xxfd_can_debugfs_fifos(cpriv, root);
-	mcp25xxfd_can_debugfs_rx_fifos(cpriv, root);
-	mcp25xxfd_can_debugfs_tx_fifos(cpriv, root);
-	mcp25xxfd_can_debugfs_tx_queue(cpriv, root);
-}
-
-#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h
deleted file mode 100644
index 7c6a255c9400..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_debugfs.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_DEBUGFS_H
-#define __MCP25XXFD_CAN_DEBUGFS_H
-
-#ifdef CONFIG_DEBUG_FS
-
-#include <linux/debugfs.h>
-#include "mcp25xxfd_can_priv.h"
-
-#define MCP25XXFD_DEBUGFS_INCR(counter) ((counter)++)
-#define MCP25XXFD_DEBUGFS_ADD(counter, val) ((counter) += (val))
-#define MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, counter)		\
-	(((cpriv)->stats.counter)++)
-#define MCP25XXFD_DEBUGFS_STATS_ADD(cpriv, counter, val)	\
-	(((cpriv)->stats.counter) += (val))
-
-void mcp25xxfd_can_debugfs_setup(struct mcp25xxfd_can_priv *cpriv);
-void mcp25xxfd_can_debugfs_remove(struct mcp25xxfd_can_priv *cpriv);
-
-#else /* CONFIG_DEBUG_FS */
-
-#define MCP25XXFD_DEBUGFS_INCR(counter)
-#define MCP25XXFD_DEBUGFS_ADD(counter, val)
-#define MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, counter)
-#define MCP25XXFD_DEBUGFS_STATS_ADD(cpriv, counter, val)
-
-static inline
-void mcp25xxfd_can_debugfs_setup(struct mcp25xxfd_can_priv *cpriv)
-{
-}
-
-static inline
-void mcp25xxfd_can_debugfs_remove(struct mcp25xxfd_can_priv *cpriv)
-{
-}
-
-#endif /* CONFIG_DEBUG_FS */
-#endif /* __MCP25XXFD_CAN_DEBUGFS_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c
deleted file mode 100644
index e17254af1d89..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.c
+++ /dev/null
@@ -1,352 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-/* here we define and configure the fifo layout */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_can_fifo.h"
-#include "mcp25xxfd_can_priv.h"
-#include "mcp25xxfd_can_tx.h"
-#include "mcp25xxfd_cmd.h"
-
-/* some controller parameters are currently not configurable via netlink
- * so we allow to control them via module parameters (that can changed
- * in /sys if needed) - theses are only needed during setup if the can_device
- */
-static unsigned int tx_fifos;
-module_param(tx_fifos, uint, 0664);
-MODULE_PARM_DESC(tx_fifos,
-		 "Number of tx-fifos to configure - recommended value is < 7\n");
-
-static bool three_shot;
-module_param(three_shot, bool, 0664);
-MODULE_PARM_DESC(three_shot, "Use 3 shots when one-shot is requested");
-
-static int mcp25xxfd_can_fifo_get_address(struct mcp25xxfd_can_priv *cpriv)
-{
-	int fifo, ret;
-
-	/* we need to move out of config mode to force address computation */
-	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
-					MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK);
-	if (ret)
-		return ret;
-
-	/* and get back into config mode */
-	ret = mcp25xxfd_can_switch_mode(cpriv->priv, &cpriv->regs.con,
-					MCP25XXFD_CAN_CON_MODE_CONFIG);
-	if (ret)
-		return ret;
-
-	/* read address and config back in */
-	for (fifo = 1; fifo < 32; fifo++) {
-		ret = mcp25xxfd_cmd_read(cpriv->priv->spi,
-					 MCP25XXFD_CAN_FIFOUA(fifo),
-					 &cpriv->fifos.info[fifo].offset);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_can_fifo_setup_config(struct mcp25xxfd_can_priv *cpriv,
-					   struct mcp25xxfd_fifo *desc,
-					   u32 flags, u32 flags_last)
-{
-	u32 val;
-	int i, p, f, c, ret;
-
-	/* now setup the fifos themselves */
-	for (i = 0, f = desc->start, c = desc->count, p = 31;
-	     c > 0; i++, f++, p--, c--) {
-		/* select the effective value */
-		val = (c > 1) ? flags : flags_last;
-
-		/* are we in tx mode */
-		if (flags & MCP25XXFD_CAN_FIFOCON_TXEN) {
-			cpriv->fifos.info[f].is_rx = false;
-			cpriv->fifos.info[f].priority = p;
-			val |= (p << MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT);
-		} else {
-			cpriv->fifos.info[f].is_rx = true;
-		}
-
-		/* write the config to the controller in one go */
-		ret = mcp25xxfd_cmd_write(cpriv->priv->spi,
-					  MCP25XXFD_CAN_FIFOCON(f), val);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_can_fifo_setup_tx(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 tx_flags = MCP25XXFD_CAN_FIFOCON_FRESET |     /* reset FIFO */
-		MCP25XXFD_CAN_FIFOCON_TXEN |              /* a tx FIFO */
-		MCP25XXFD_CAN_FIFOCON_TXATIE |            /* state in txatif */
-		(cpriv->fifos.payload_mode <<
-		 MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT) |    /* paylod size */
-		(0 << MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT); /* 1 FIFO deep */
-
-	/* handle oneshot/three-shot */
-	if (cpriv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
-		if (three_shot)
-			tx_flags |= MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT <<
-				MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT;
-		else
-			tx_flags |= MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT <<
-				MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT;
-	else
-		tx_flags |= MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED <<
-			MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT;
-
-	return mcp25xxfd_can_fifo_setup_config(cpriv, &cpriv->fifos.tx,
-					       tx_flags, tx_flags);
-}
-
-static int mcp25xxfd_can_fifo_setup_rx(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 rx_flags = MCP25XXFD_CAN_FIFOCON_FRESET |     /* reset FIFO */
-		MCP25XXFD_CAN_FIFOCON_RXTSEN |            /* RX timestamps */
-		MCP25XXFD_CAN_FIFOCON_TFERFFIE |          /* FIFO Full */
-		MCP25XXFD_CAN_FIFOCON_TFHRFHIE |          /* FIFO Half Full*/
-		MCP25XXFD_CAN_FIFOCON_TFNRFNIE |          /* FIFO not empty */
-		(cpriv->fifos.payload_mode <<
-		 MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT) |
-		(0 << MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT); /* 1 FIFO deep */
-	/* enable overflow int on last fifo */
-	u32 rx_flags_last = rx_flags | MCP25XXFD_CAN_FIFOCON_RXOVIE;
-
-	return mcp25xxfd_can_fifo_setup_config(cpriv, &cpriv->fifos.rx,
-					       rx_flags, rx_flags_last);
-}
-
-static int mcp25xxfd_can_fifo_setup_rxfilter(struct mcp25xxfd_can_priv *cpriv)
-{
-	u8 filter_con[32];
-	int c, f;
-
-	/* clear the filters and filter mappings for all filters */
-	memset(filter_con, 0, sizeof(filter_con));
-
-	/* and now set up the rx filters */
-	for (c = 0, f = cpriv->fifos.rx.start; c < cpriv->fifos.rx.count;
-	     c++, f++) {
-		/* set up filter config - we can use the mask of filter 0 */
-		filter_con[c] = MCP25XXFD_CAN_FIFOCON_FLTEN(0) |
-			(f << MCP25XXFD_CAN_FILCON_SHIFT(0));
-	}
-
-	/* and set up filter control */
-	return mcp25xxfd_cmd_write_regs(cpriv->priv->spi,
-					MCP25XXFD_CAN_FLTCON(0),
-					(u32 *)filter_con, sizeof(filter_con));
-}
-
-static int mcp25xxfd_can_fifo_compute(struct mcp25xxfd_can_priv *cpriv)
-{
-	int tef_memory_used, tx_memory_used, rx_memory_available;
-
-	/* default settings as per MTU/CANFD */
-	switch (cpriv->can.dev->mtu) {
-	case CAN_MTU:
-		/* mtu is 8 */
-		cpriv->fifos.payload_size = 8;
-		cpriv->fifos.payload_mode = MCP25XXFD_CAN_TXQCON_PLSIZE_8;
-
-		/* 6 tx fifos */
-		cpriv->fifos.tx.count = 6;
-
-		break;
-	case CANFD_MTU:
-		/* wish there was a way to have hw filters
-		 * that can separate based on length ...
-		 */
-		/* MTU is 64 */
-		cpriv->fifos.payload_size = 64;
-		cpriv->fifos.payload_mode = MCP25XXFD_CAN_TXQCON_PLSIZE_64;
-
-		/* 6 tx fifos */
-		cpriv->fifos.tx.count = 6;
-
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* compute effective sizes */
-	cpriv->fifos.tef.size = sizeof(struct mcp25xxfd_can_obj_tef);
-	cpriv->fifos.tx.size = sizeof(struct mcp25xxfd_can_obj_tx) +
-		cpriv->fifos.payload_size;
-	cpriv->fifos.rx.size = sizeof(struct mcp25xxfd_can_obj_rx) +
-		cpriv->fifos.payload_size;
-
-	/* if defined as a module parameter modify the number of tx_fifos */
-	if (tx_fifos) {
-		netdev_info(cpriv->can.dev,
-			    "Using %i tx-fifos as per module parameter\n",
-			    tx_fifos);
-		cpriv->fifos.tx.count = tx_fifos;
-		if (tx_fifos > 6)
-			netdev_info(cpriv->can.dev,
-				    "You may trigger a bug where during a spi transfer bit 7, 15, 23 or 31 of TXREQ may flip due to CAN bus activity or similar so the recommended value is < 7\n");
-	}
-
-	/* there can be at the most 30 tx fifos (TEF and at least 1 RX fifo */
-	if (cpriv->fifos.tx.count > 30) {
-		netdev_err(cpriv->can.dev,
-			   "There is an absolute maximum of 30 tx-fifos\n");
-		return -EINVAL;
-	}
-
-	/* set tef fifos to the number of tx fifos */
-	cpriv->fifos.tef.count = cpriv->fifos.tx.count;
-
-	/* compute size of the tx fifos and TEF */
-	tx_memory_used = cpriv->fifos.tx.count * cpriv->fifos.tx.size;
-	tef_memory_used = cpriv->fifos.tef.count * cpriv->fifos.tef.size;
-
-	/* calculate evailable memory for RX_fifos */
-	rx_memory_available = MCP25XXFD_SRAM_SIZE - tx_memory_used -
-		tef_memory_used;
-
-	/* we need at least one RX Frame */
-	if (rx_memory_available < cpriv->fifos.rx.size) {
-		netdev_err(cpriv->can.dev,
-			   "Configured %i tx-fifos exceeds available memory already\n",
-			   cpriv->fifos.tx.count);
-		return -EINVAL;
-	}
-
-	/* calculate possible amount of RX fifos */
-	cpriv->fifos.rx.count = rx_memory_available / cpriv->fifos.rx.size;
-
-	/* so now calculate effective number of rx-fifos
-	 * there are only 31 fifos available in total,
-	 * so we need to limit ourselves
-	 */
-	if (cpriv->fifos.rx.count + cpriv->fifos.tx.count > 31)
-		cpriv->fifos.rx.count = 31 - cpriv->fifos.tx.count;
-
-	/* define the layout now that we have gotten everything */
-	cpriv->fifos.tx.start = 1;
-	cpriv->fifos.rx.start = cpriv->fifos.tx.start + cpriv->fifos.tx.count;
-
-	return 0;
-}
-
-static int mcp25xxfd_can_fifo_clear_regs(struct mcp25xxfd_can_priv *cpriv,
-					 u32 start, u32 end)
-{
-	size_t len = end - start;
-	u8 *data = kzalloc(len, GFP_KERNEL);
-	int ret;
-
-	if (!data)
-		return -ENOMEM;
-
-	ret = mcp25xxfd_cmd_write_regs(cpriv->priv->spi,
-				       start, (u32 *)data, len);
-
-	kfree(data);
-
-	return ret;
-}
-
-static int mcp25xxfd_can_fifo_clear(struct mcp25xxfd_can_priv *cpriv)
-{
-	int ret;
-
-	memset(&cpriv->fifos.info, 0, sizeof(cpriv->fifos.info));
-	memset(&cpriv->fifos.tx, 0, sizeof(cpriv->fifos.tx));
-	memset(&cpriv->fifos.rx, 0, sizeof(cpriv->fifos.rx));
-
-	/* clear FIFO config */
-	ret = mcp25xxfd_can_fifo_clear_regs(cpriv, MCP25XXFD_CAN_FIFOCON(1),
-					    MCP25XXFD_CAN_FIFOCON(32));
-	if (ret)
-		return ret;
-
-	/* clear the filter mask - match any frame with every filter */
-	return mcp25xxfd_can_fifo_clear_regs(cpriv, MCP25XXFD_CAN_FLTCON(0),
-					     MCP25XXFD_CAN_FLTCON(32));
-}
-
-int mcp25xxfd_can_fifo_setup(struct mcp25xxfd_can_priv *cpriv)
-{
-	int ret;
-
-	/* clear fifo config */
-	ret = mcp25xxfd_can_fifo_clear(cpriv);
-	if (ret)
-		return ret;
-
-	/* compute fifos counts */
-	ret = mcp25xxfd_can_fifo_compute(cpriv);
-	if (ret)
-		return ret;
-
-	/* configure TEF */
-	if (cpriv->fifos.tef.count)
-		cpriv->regs.tefcon =
-			MCP25XXFD_CAN_TEFCON_FRESET |
-			MCP25XXFD_CAN_TEFCON_TEFNEIE |
-			MCP25XXFD_CAN_TEFCON_TEFTSEN |
-			((cpriv->fifos.tef.count - 1) <<
-			 MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT);
-	else
-		cpriv->regs.tefcon = 0;
-	ret = mcp25xxfd_cmd_write(cpriv->priv->spi, MCP25XXFD_CAN_TEFCON,
-				  cpriv->regs.tefcon);
-	if (ret)
-		return ret;
-
-	/* TXQueue disabled */
-	ret = mcp25xxfd_cmd_write(cpriv->priv->spi, MCP25XXFD_CAN_TXQCON, 0);
-	if (ret)
-		return ret;
-
-	/* configure FIFOS themselves */
-	ret = mcp25xxfd_can_fifo_setup_tx(cpriv);
-	if (ret)
-		return ret;
-	ret = mcp25xxfd_can_fifo_setup_rx(cpriv);
-	if (ret)
-		return ret;
-	ret = mcp25xxfd_can_fifo_setup_rxfilter(cpriv);
-	if (ret)
-		return ret;
-
-	/* get fifo addresses */
-	ret = mcp25xxfd_can_fifo_get_address(cpriv);
-	if (ret)
-		return ret;
-
-	/* setup tx_fifo_queue */
-	ret = mcp25xxfd_can_tx_queue_alloc(cpriv);
-	if (ret)
-		return ret;
-
-	/* add the can info to debugfs */
-	mcp25xxfd_can_debugfs_setup(cpriv);
-
-	return 0;
-}
-
-void mcp25xxfd_can_fifo_release(struct mcp25xxfd_can_priv *cpriv)
-{
-	mcp25xxfd_can_tx_queue_free(cpriv);
-	mcp25xxfd_can_fifo_clear(cpriv);
-	mcp25xxfd_can_debugfs_remove(cpriv);
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h
deleted file mode 100644
index ed2daa05220a..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_fifo.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_FIFO_H
-#define __MCP25XXFD_CAN_FIFO_H
-
-#include "mcp25xxfd_can_priv.h"
-
-int mcp25xxfd_can_fifo_setup(struct mcp25xxfd_can_priv *cpriv);
-void mcp25xxfd_can_fifo_release(struct mcp25xxfd_can_priv *cpriv);
-
-#endif /* __MCP25XXFD_CAN_FIFO_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h
deleted file mode 100644
index 00a6c6639bd5..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_id.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_IF_H
-#define __MCP25XXFD_CAN_IF_H
-
-#include <uapi/linux/can.h>
-
-#include "mcp25xxfd_can_id.h"
-#include "mcp25xxfd_regs.h"
-
-/* ideally these would be defined in uapi/linux/can.h */
-#define MCP25XXFD_CAN_EFF_SID_SHIFT	(CAN_EFF_ID_BITS - CAN_SFF_ID_BITS)
-#define MCP25XXFD_CAN_EFF_SID_BITS	CAN_SFF_ID_BITS
-#define MCP25XXFD_CAN_EFF_SID_MASK					\
-	GENMASK(MCP25XXFD_CAN_EFF_SID_SHIFT + MCP25XXFD_CAN_EFF_SID_BITS - 1, \
-		MCP25XXFD_CAN_EFF_SID_SHIFT)
-#define MCP25XXFD_CAN_EFF_EID_SHIFT	0
-#define MCP25XXFD_CAN_EFF_EID_BITS	MCP25XXFD_CAN_EFF_SID_SHIFT
-#define MCP25XXFD_CAN_EFF_EID_MASK					\
-	GENMASK(MCP25XXFD_CAN_EFF_EID_SHIFT + MCP25XXFD_CAN_EFF_EID_BITS - 1, \
-		MCP25XXFD_CAN_EFF_EID_SHIFT)
-
-static inline
-void mcp25xxfd_can_id_from_mcp25xxfd(u32 mcp_id, u32 mcp_flags, u32 *can_id)
-{
-	u32 sid = (mcp_id & MCP25XXFD_CAN_OBJ_ID_SID_MASK) >>
-		MCP25XXFD_CAN_OBJ_ID_SID_SHIFT;
-	u32 eid = (mcp_id & MCP25XXFD_CAN_OBJ_ID_EID_MASK) >>
-		MCP25XXFD_CAN_OBJ_ID_EID_SHIFT;
-
-	/* select normal or extended ids */
-	if (mcp_flags & MCP25XXFD_CAN_OBJ_FLAGS_IDE) {
-		*can_id = (eid << MCP25XXFD_CAN_EFF_EID_SHIFT) |
-			(sid << MCP25XXFD_CAN_EFF_SID_SHIFT) |
-			CAN_EFF_FLAG;
-	} else {
-		*can_id = sid << MCP25XXFD_CAN_EFF_EID_SHIFT;
-	}
-	/* handle rtr */
-	*can_id |= (mcp_flags & MCP25XXFD_CAN_OBJ_FLAGS_RTR) ? CAN_RTR_FLAG : 0;
-}
-
-static inline
-void mcp25xxfd_can_id_to_mcp25xxfd(u32 can_id, u32 *id, u32 *flags)
-{
-	/* depending on can_id flag compute extended or standard ids */
-	if (can_id & CAN_EFF_FLAG) {
-		int sid = (can_id & MCP25XXFD_CAN_EFF_SID_MASK) >>
-			MCP25XXFD_CAN_EFF_SID_SHIFT;
-		int eid = (can_id & MCP25XXFD_CAN_EFF_EID_MASK) >>
-			MCP25XXFD_CAN_EFF_EID_SHIFT;
-		*id = (eid << MCP25XXFD_CAN_OBJ_ID_EID_SHIFT) |
-			(sid << MCP25XXFD_CAN_OBJ_ID_SID_SHIFT);
-		*flags = MCP25XXFD_CAN_OBJ_FLAGS_IDE;
-	} else {
-		*id = can_id & CAN_SFF_MASK;
-		*flags = 0;
-	}
-
-	/* Handle RTR */
-	*flags |= (can_id & CAN_RTR_FLAG) ? MCP25XXFD_CAN_OBJ_FLAGS_RTR : 0;
-}
-
-#endif /* __MCP25XXFD_CAN_IF_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c
deleted file mode 100644
index 3625567ffa15..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.c
+++ /dev/null
@@ -1,734 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#include <linux/can/core.h>
-#include <linux/can/dev.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/irqreturn.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/net.h>
-#include <linux/netdevice.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/sort.h>
-
-#include "mcp25xxfd_regs.h"
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_can_debugfs.h"
-#include "mcp25xxfd_can_int.h"
-#include "mcp25xxfd_can_priv.h"
-#include "mcp25xxfd_can_rx.h"
-#include "mcp25xxfd_can_tx.h"
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_ecc.h"
-#include "mcp25xxfd_int.h"
-
-static unsigned int reschedule_int_thread_after = 4;
-module_param(reschedule_int_thread_after, uint, 0664);
-MODULE_PARM_DESC(reschedule_int_thread_after,
-		 "Reschedule the interrupt thread after this many loops\n");
-
-static void mcp25xxfd_can_int_send_error_skb(struct mcp25xxfd_can_priv *cpriv)
-{
-	struct net_device *net = cpriv->can.dev;
-	struct sk_buff *skb;
-	struct can_frame *frame;
-
-	/* allocate error frame */
-	skb = alloc_can_err_skb(net, &frame);
-	if (!skb) {
-		netdev_err(net, "cannot allocate error skb\n");
-		return;
-	}
-
-	/* setup can error frame data */
-	frame->can_id |= cpriv->error_frame.id;
-	memcpy(frame->data, cpriv->error_frame.data, sizeof(frame->data));
-
-	/* and submit it */
-	netif_receive_skb(skb);
-}
-
-static int mcp25xxfd_can_int_compare_obj_ts(const void *a, const void *b)
-{
-	s32 ats = ((struct mcp25xxfd_obj_ts *)a)->ts;
-	s32 bts = ((struct mcp25xxfd_obj_ts *)b)->ts;
-
-	if (ats < bts)
-		return -1;
-	if (ats > bts)
-		return 1;
-	return 0;
-}
-
-static int mcp25xxfd_can_int_submit_frames(struct mcp25xxfd_can_priv *cpriv)
-{
-	struct mcp25xxfd_obj_ts *queue = cpriv->fifos.submit_queue;
-	int count = cpriv->fifos.submit_queue_count;
-	int i, fifo;
-	int ret;
-
-	/* skip processing if the queue count is 0 */
-	if (count == 0)
-		goto out;
-
-	/* sort the fifos (rx and tx - actually TEF) by receive timestamp */
-	sort(queue, count, sizeof(*queue),
-	     mcp25xxfd_can_int_compare_obj_ts, NULL);
-
-	/* now submit the fifos  */
-	for (i = 0; i < count; i++) {
-		fifo = queue[i].fifo;
-		ret = (queue[i].is_rx) ?
-			mcp25xxfd_can_rx_submit_frame(cpriv, fifo) :
-			mcp25xxfd_can_tx_submit_frame(cpriv, fifo);
-		if (ret)
-			return ret;
-	}
-
-	/* if we have received or transmitted something
-	 * and the IVMIE is disabled, then enable it
-	 * this is mostly to avoid unnecessary interrupts during a
-	 * disconnected CAN BUS
-	 */
-	if (!(cpriv->status.intf | MCP25XXFD_CAN_INT_IVMIE)) {
-		cpriv->status.intf |= MCP25XXFD_CAN_INT_IVMIE;
-		ret = mcp25xxfd_cmd_write_mask(cpriv->priv->spi,
-					       MCP25XXFD_CAN_INT,
-					       cpriv->status.intf,
-					       MCP25XXFD_CAN_INT_IVMIE);
-		if (ret)
-			return ret;
-	}
-
-out:
-	/* enable tx_queue if necessary */
-	mcp25xxfd_can_tx_queue_restart(cpriv);
-
-	return 0;
-}
-
-static int mcp25xxfd_can_int_clear_int_flags(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 clearable_irq_active = cpriv->status.intf &
-		MCP25XXFD_CAN_INT_IF_CLEAR_MASK;
-	u32 clear_irq = cpriv->status.intf & (~MCP25XXFD_CAN_INT_IF_CLEAR_MASK);
-
-	/* if no clearable flags are set then skip the whole transfer */
-	if (!clearable_irq_active)
-		return 0;
-
-	return mcp25xxfd_cmd_write_mask(cpriv->priv->spi, MCP25XXFD_CAN_INT,
-					clear_irq, clearable_irq_active);
-}
-
-static
-int mcp25xxfd_can_int_handle_serrif_txmab(struct mcp25xxfd_can_priv *cpriv)
-{
-	int mode = mcp25xxfd_can_targetmode(cpriv);
-
-	cpriv->can.dev->stats.tx_fifo_errors++;
-	cpriv->can.dev->stats.tx_errors++;
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_serr_tx_count);
-
-	/* data7 contains custom mcp25xxfd error flags */
-	cpriv->error_frame.data[7] |= MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_TX;
-
-	/* and switch back into the correct mode */
-	return mcp25xxfd_can_switch_mode_no_wait(cpriv->priv,
-						 &cpriv->regs.con, mode);
-}
-
-static
-int mcp25xxfd_can_int_handle_serrif_rxmab(struct mcp25xxfd_can_priv *cpriv)
-{
-	cpriv->can.dev->stats.rx_dropped++;
-	cpriv->can.dev->stats.rx_errors++;
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_serr_rx_count);
-
-	/* data7 contains custom mcp25xxfd error flags */
-	cpriv->error_frame.data[7] |= MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_RX;
-
-	return 0;
-}
-
-static int mcp25xxfd_can_int_handle_serrif(struct mcp25xxfd_can_priv *cpriv)
-{
-	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_SERRIF))
-		return 0;
-
-	/* increment statistics counter now */
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_serr_count);
-
-	/* interrupt flags have been cleared already */
-
-	/* Errors here are:
-	 * * Bus Bandwidth Error: when a RX Message Assembly Buffer
-	 *   is still full when the next message has already arrived
-	 *   the recived message shall be ignored
-	 * * TX MAB Underflow: when a TX Message is invalid
-	 *   due to ECC errors or TXMAB underflow
-	 *   in this situatioon the system will transition to
-	 *   Restricted or Listen Only mode
-	 */
-
-	cpriv->error_frame.id |= CAN_ERR_CRTL;
-	cpriv->error_frame.data[1] |= CAN_ERR_CRTL_UNSPEC;
-
-	/* a mode change + invalid message would indicate
-	 * TX MAB Underflow
-	 */
-	if ((cpriv->status.intf & MCP25XXFD_CAN_INT_MODIF) &&
-	    (cpriv->status.intf & MCP25XXFD_CAN_INT_IVMIF)) {
-		return mcp25xxfd_can_int_handle_serrif_txmab(cpriv);
-	}
-
-	/* for RX there is only the RXIF an indicator
-	 * - surprizingly RX-MAB does not change mode or anything
-	 */
-	if (cpriv->status.intf & MCP25XXFD_CAN_INT_RXIF)
-		return mcp25xxfd_can_int_handle_serrif_rxmab(cpriv);
-
-	/* the final case */
-	dev_warn_ratelimited(&cpriv->priv->spi->dev,
-			     "unidentified system interrupt - intf =  %08x\n",
-			     cpriv->status.intf);
-
-	return 0;
-}
-
-static int mcp25xxfd_can_int_handle_modif(struct mcp25xxfd_can_priv *cpriv)
-{
-	struct spi_device *spi = cpriv->priv->spi;
-	int mode;
-	int ret;
-
-	/* Note that this irq does not get triggered in all situations
-	 * for example SERRIF will move to RESTICTED or LISTENONLY
-	 * but MODIF will not be raised!
-	 */
-
-	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_MODIF))
-		return 0;
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_mod_count);
-
-	/* get the current mode */
-	ret = mcp25xxfd_can_get_mode(cpriv->priv, &mode);
-	if (ret < 0)
-		return ret;
-	mode = ret;
-
-	/* switches to the same mode as before are ignored
-	 * - this typically happens if the driver is shortly
-	 *   switching to a different mode and then returning to the
-	 *   original mode
-	 */
-	if (mode == cpriv->mode)
-		return 0;
-
-	/* if we are restricted, then return to "normal" mode */
-	if (mode == MCP25XXFD_CAN_CON_MODE_RESTRICTED) {
-		cpriv->mode = mode;
-		mode = mcp25xxfd_can_targetmode(cpriv);
-		return mcp25xxfd_can_switch_mode_no_wait(cpriv->priv,
-							 &cpriv->regs.con,
-							 mode);
-	}
-
-	/* the controller itself will transition to sleep, so we ignore it */
-	if (mode == MCP25XXFD_CAN_CON_MODE_SLEEP) {
-		cpriv->mode = mode;
-		return 0;
-	}
-
-	/* these we need to handle correctly, so warn and give context */
-	dev_warn(&spi->dev,
-		 "Controller unexpectedly switched from mode %u to %u\n",
-		 cpriv->mode, mode);
-
-	/* assign the mode as current */
-	cpriv->mode = mode;
-
-	return 0;
-}
-
-static int mcp25xxfd_can_int_handle_eccif(struct mcp25xxfd_can_priv *cpriv)
-{
-	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_ECCIF))
-		return 0;
-
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_ecc_count);
-
-	/* and prepare ERROR FRAME */
-	cpriv->error_frame.id |= CAN_ERR_CRTL;
-	cpriv->error_frame.data[1] |= CAN_ERR_CRTL_UNSPEC;
-	/* data7 contains custom mcp25xxfd error flags */
-	cpriv->error_frame.data[7] |= MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_ECC;
-
-	/* delegate to interrupt cleaning */
-	return mcp25xxfd_ecc_clear_int(cpriv->priv);
-}
-
-static void mcp25xxfd_can_int_handle_ivmif_tx(struct mcp25xxfd_can_priv *cpriv,
-					      u32 *mask)
-{
-	/* check if it is really a known tx error */
-	if ((cpriv->bus.bdiag[1] &
-	     (MCP25XXFD_CAN_BDIAG1_DBIT1ERR |
-	      MCP25XXFD_CAN_BDIAG1_DBIT0ERR |
-	      MCP25XXFD_CAN_BDIAG1_NACKERR |
-	      MCP25XXFD_CAN_BDIAG1_NBIT1ERR |
-	      MCP25XXFD_CAN_BDIAG1_NBIT0ERR
-		     )) == 0)
-		return;
-
-	/* mark it as a protocol error */
-	cpriv->error_frame.id |= CAN_ERR_PROT;
-
-	/* and update statistics */
-	cpriv->can.dev->stats.tx_errors++;
-
-	/* and handle all the known cases */
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NACKERR) {
-		/* TX-Frame not acknowledged - connected to CAN-bus? */
-		*mask |= MCP25XXFD_CAN_BDIAG1_NACKERR;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_TX;
-		cpriv->can.dev->stats.tx_aborted_errors++;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NBIT1ERR) {
-		/* TX-Frame CAN-BUS Level is unexpectedly dominant */
-		*mask |= MCP25XXFD_CAN_BDIAG1_NBIT1ERR;
-		cpriv->can.dev->stats.tx_carrier_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT1;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NBIT0ERR) {
-		/* TX-Frame CAN-BUS Level is unexpectedly recessive */
-		*mask |= MCP25XXFD_CAN_BDIAG1_NBIT0ERR;
-		cpriv->can.dev->stats.tx_carrier_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT0;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DBIT1ERR) {
-		/* TX-Frame CAN-BUS Level is unexpectedly dominant
-		 * during data phase
-		 */
-		*mask |= MCP25XXFD_CAN_BDIAG1_DBIT1ERR;
-		cpriv->can.dev->stats.tx_carrier_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT1;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DBIT0ERR) {
-		/* TX-Frame CAN-BUS Level is unexpectedly recessive
-		 * during data phase
-		 */
-		*mask |= MCP25XXFD_CAN_BDIAG1_DBIT0ERR;
-		cpriv->can.dev->stats.tx_carrier_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_BIT0;
-	}
-}
-
-static void mcp25xxfd_can_int_handle_ivmif_rx(struct mcp25xxfd_can_priv *cpriv,
-					      u32 *mask)
-{
-	/* check if it is really a known tx error */
-	if ((cpriv->bus.bdiag[1] &
-	     (MCP25XXFD_CAN_BDIAG1_DCRCERR |
-	      MCP25XXFD_CAN_BDIAG1_DSTUFERR |
-	      MCP25XXFD_CAN_BDIAG1_DFORMERR |
-	      MCP25XXFD_CAN_BDIAG1_NCRCERR |
-	      MCP25XXFD_CAN_BDIAG1_NSTUFERR |
-	      MCP25XXFD_CAN_BDIAG1_NFORMERR
-		     )) == 0)
-		return;
-
-	/* mark it as a protocol error */
-	cpriv->error_frame.id |= CAN_ERR_PROT;
-
-	/* and update statistics */
-	cpriv->can.dev->stats.rx_errors++;
-
-	/* handle the cases */
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DCRCERR) {
-		/* RX-Frame with bad CRC during data phase */
-		*mask |= MCP25XXFD_CAN_BDIAG1_DCRCERR;
-		cpriv->can.dev->stats.rx_crc_errors++;
-		cpriv->error_frame.data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DSTUFERR) {
-		/* RX-Frame with bad stuffing during data phase */
-		*mask |= MCP25XXFD_CAN_BDIAG1_DSTUFERR;
-		cpriv->can.dev->stats.rx_frame_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_STUFF;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_DFORMERR) {
-		/* RX-Frame with bad format during data phase */
-		*mask |= MCP25XXFD_CAN_BDIAG1_DFORMERR;
-		cpriv->can.dev->stats.rx_frame_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_FORM;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NCRCERR) {
-		/* RX-Frame with bad CRC during data phase */
-		*mask |= MCP25XXFD_CAN_BDIAG1_NCRCERR;
-		cpriv->can.dev->stats.rx_crc_errors++;
-		cpriv->error_frame.data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NSTUFERR) {
-		/* RX-Frame with bad stuffing during data phase */
-		*mask |= MCP25XXFD_CAN_BDIAG1_NSTUFERR;
-		cpriv->can.dev->stats.rx_frame_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_STUFF;
-	}
-	if (cpriv->bus.bdiag[1] & MCP25XXFD_CAN_BDIAG1_NFORMERR) {
-		/* RX-Frame with bad format during data phase */
-		*mask |= MCP25XXFD_CAN_BDIAG1_NFORMERR;
-		cpriv->can.dev->stats.rx_frame_errors++;
-		cpriv->error_frame.data[2] |= CAN_ERR_PROT_FORM;
-	}
-}
-
-static int mcp25xxfd_can_int_handle_ivmif(struct mcp25xxfd_can_priv *cpriv)
-{
-	struct spi_device *spi = cpriv->priv->spi;
-	u32 mask, bdiag1;
-	int ret;
-
-	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_IVMIF))
-		return 0;
-
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_ivm_count);
-
-	/* if we have a systemerror as well,
-	 * then ignore it as they correlate
-	 */
-	if (cpriv->status.intf & MCP25XXFD_CAN_INT_SERRIF)
-		return 0;
-
-	/* read bus diagnostics */
-	ret = mcp25xxfd_cmd_read_regs(spi, MCP25XXFD_CAN_BDIAG0,
-				      cpriv->bus.bdiag,
-				      sizeof(cpriv->bus.bdiag));
-	if (ret)
-		return ret;
-
-	/* clear the masks of bits to clear */
-	mask = 0;
-
-	/* check rx and tx errors */
-	mcp25xxfd_can_int_handle_ivmif_tx(cpriv, &mask);
-	mcp25xxfd_can_int_handle_ivmif_rx(cpriv, &mask);
-
-	/* clear flags if we have bits masked */
-	if (!mask) {
-		/* the unsupported case, where we are not
-		 * clearing any registers
-		 */
-		dev_warn_once(&spi->dev,
-			      "found IVMIF situation not supported by driver - bdiag = [0x%08x, 0x%08x]",
-			      cpriv->bus.bdiag[0], cpriv->bus.bdiag[1]);
-		return -EINVAL;
-	}
-
-	/* clear the bits in bdiag1 */
-	bdiag1 = cpriv->bus.bdiag[1] & (~mask);
-	/* and write it */
-	ret = mcp25xxfd_cmd_write_mask(spi, MCP25XXFD_CAN_BDIAG1, bdiag1, mask);
-	if (ret)
-		return ret;
-
-	/* and clear the interrupt flag until we have received or transmited */
-	cpriv->status.intf &= ~(MCP25XXFD_CAN_INT_IVMIE);
-	return mcp25xxfd_cmd_write_mask(spi, MCP25XXFD_CAN_INT,
-					cpriv->status.intf,
-					MCP25XXFD_CAN_INT_IVMIE);
-}
-
-static int mcp25xxfd_can_int_handle_cerrif(struct mcp25xxfd_can_priv *cpriv)
-{
-	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_CERRIF))
-		return 0;
-
-	/* this interrupt exists primarilly to counter possible
-	 * bus off situations more detailed information
-	 * can be found and controlled in the TREC register
-	 */
-
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_cerr_count);
-
-	netdev_warn(cpriv->can.dev, "CAN Bus error experienced");
-
-	return 0;
-}
-
-static int mcp25xxfd_can_int_error_counters(struct mcp25xxfd_can_priv *cpriv)
-{
-	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_TXWARN) {
-		cpriv->bus.new_state = CAN_STATE_ERROR_WARNING;
-		cpriv->error_frame.id |= CAN_ERR_CRTL;
-		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_TX_WARNING;
-	}
-	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_RXWARN) {
-		cpriv->bus.new_state = CAN_STATE_ERROR_WARNING;
-		cpriv->error_frame.id |= CAN_ERR_CRTL;
-		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_RX_WARNING;
-	}
-	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_TXBP) {
-		cpriv->bus.new_state = CAN_STATE_ERROR_PASSIVE;
-		cpriv->error_frame.id |= CAN_ERR_CRTL;
-		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
-	}
-	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_RXBP) {
-		cpriv->bus.new_state = CAN_STATE_ERROR_PASSIVE;
-		cpriv->error_frame.id |= CAN_ERR_CRTL;
-		cpriv->error_frame.data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
-	}
-	if (cpriv->status.trec & MCP25XXFD_CAN_TREC_TXBO) {
-		cpriv->bus.new_state = CAN_STATE_BUS_OFF;
-		cpriv->error_frame.id |= CAN_ERR_BUSOFF;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_can_int_error_handling(struct mcp25xxfd_can_priv *cpriv)
-{
-	/* based on the last state state check the new state */
-	switch (cpriv->can.state) {
-	case CAN_STATE_ERROR_ACTIVE:
-		if (cpriv->bus.new_state >= CAN_STATE_ERROR_WARNING &&
-		    cpriv->bus.new_state <= CAN_STATE_BUS_OFF)
-			cpriv->can.can_stats.error_warning++;
-		/* fallthrough */
-	case CAN_STATE_ERROR_WARNING:
-		if (cpriv->bus.new_state >= CAN_STATE_ERROR_PASSIVE &&
-		    cpriv->bus.new_state <= CAN_STATE_BUS_OFF)
-			cpriv->can.can_stats.error_passive++;
-		break;
-	default:
-		break;
-	}
-	cpriv->can.state = cpriv->bus.new_state;
-
-	/* and send error packet */
-	if (cpriv->error_frame.id)
-		mcp25xxfd_can_int_send_error_skb(cpriv);
-
-	/* handle BUS OFF */
-	if (cpriv->can.state == CAN_STATE_BUS_OFF) {
-		if (cpriv->can.restart_ms == 0) {
-			cpriv->can.can_stats.bus_off++;
-			can_bus_off(cpriv->can.dev);
-		}
-	} else {
-		/* restart the tx queue if needed */
-		mcp25xxfd_can_tx_queue_restart(cpriv);
-	}
-
-	return 0;
-}
-
-
-static int mcp25xxfd_can_int_handle_status(struct mcp25xxfd_can_priv *cpriv)
-{
-	char *errfunc;
-	int ret;
-
-#define HANDLE_ERROR(name) if (ret) { errfunc = name; goto err; }
-
-	/* clear all the interrupts asap - we have them on file allready */
-	ret = mcp25xxfd_can_int_clear_int_flags(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_clear_int_flags");
-
-	/* set up new state and error frame for this loop */
-	cpriv->bus.new_state = cpriv->bus.state;
-	memset(&cpriv->error_frame, 0, sizeof(cpriv->error_frame));
-
-	/* setup the process queue by clearing the counter */
-	cpriv->fifos.submit_queue_count = 0;
-
-	/* handle interrupts */
-
-	/* system error interrupt needs to get handled first
-	 * to get us out of restricted mode
-	 */
-	ret = mcp25xxfd_can_int_handle_serrif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_handle_serrif");
-
-	/* mode change interrupt */
-	ret = mcp25xxfd_can_int_handle_modif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_handle_modif");
-
-	/* handle the rx */
-	ret = mcp25xxfd_can_rx_handle_int_rxif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_rx_handle_int_rxif");
-
-	/* handle aborted TX FIFOs */
-	ret = mcp25xxfd_can_tx_handle_int_txatif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_tx_handle_int_txatif");
-
-	/* handle the TEF */
-	ret = mcp25xxfd_can_tx_handle_int_tefif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_rx_handle_int_tefif");
-
-	/* handle error interrupt flags */
-	ret = mcp25xxfd_can_rx_handle_int_rxovif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_rx_handle_int_rxovif");
-
-	/* sram ECC error interrupt */
-	ret = mcp25xxfd_can_int_handle_eccif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_handle_eccif");
-
-	/* message format interrupt */
-	ret = mcp25xxfd_can_int_handle_ivmif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_handle_ivmif");
-
-	/* handle bus errors in more detail */
-	ret = mcp25xxfd_can_int_handle_cerrif(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_handle_cerrif");
-
-	/* error counter handling */
-	ret = mcp25xxfd_can_int_error_counters(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_error_counters");
-
-	/* error counter handling */
-	ret = mcp25xxfd_can_int_error_handling(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_error_handling");
-
-	/* and submit can frames to network stack */
-	ret = mcp25xxfd_can_int_submit_frames(cpriv);
-	HANDLE_ERROR("mcp25xxfd_can_int_submit_frames");
-
-	return 0;
-err:
-	netdev_err(cpriv->can.dev, "%s returned with error code %i\n",
-		   errfunc, ret);
-	return ret;
-}
-#undef HANDLE_ERROR
-
-irqreturn_t mcp25xxfd_can_int(int irq, void *dev_id)
-{
-	struct mcp25xxfd_can_priv *cpriv = dev_id;
-	int loops, ret;
-
-	/* count interrupt calls */
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, irq_calls);
-
-	/* loop forever unless we need to exit */
-	for (loops = 0; true; loops++) {
-		/* count irq loops */
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, irq_loops);
-
-		/* read interrupt status flags in bulk */
-		ret = mcp25xxfd_cmd_read_regs(cpriv->priv->spi,
-					      MCP25XXFD_CAN_INT,
-					      &cpriv->status.intf,
-					      sizeof(cpriv->status));
-		switch (ret) {
-		case 0: /* no errors, so process */
-			break;
-		case -EILSEQ: /* a crc error, so run the loop again */
-			continue;
-		default: /* all other error cases */
-			netdev_err(cpriv->can.dev,
-				   "reading can registers returned with error code %i\n",
-				   ret);
-			goto fail;
-		}
-
-		/* only act if the IE mask configured has active IF bits
-		 * otherwise the Interrupt line should be deasserted already
-		 * so we can exit the loop
-		 */
-		if (((cpriv->status.intf >> MCP25XXFD_CAN_INT_IE_SHIFT) &
-		       cpriv->status.intf) == 0)
-			break;
-
-		/* handle the interrupts for real */
-		ret = mcp25xxfd_can_int_handle_status(cpriv);
-		switch (ret) {
-		case 0: /* no errors, so process */
-		case -EILSEQ: /* a crc error, so run the loop again */
-			break;
-		default: /* all other error cases */
-			goto fail;
-		}
-
-		/* allow voluntarily rescheduling every so often to avoid
-		 * long CS lows at the end of a transfer on low power CPUs
-		 * avoiding SERR happening
-		 */
-		if (loops % reschedule_int_thread_after == 0) {
-			MCP25XXFD_DEBUGFS_STATS_INCR(cpriv,
-						     irq_thread_rescheduled);
-			cond_resched();
-		}
-	}
-
-	return IRQ_HANDLED;
-
-fail:
- 	netdev_err(cpriv->can.dev,
-		   "experienced unexpected error %i in interrupt handler - disabling interrupts\n",
- 		   ret);
-	/* note that if we experienced an spi error,
-	 * then this would produce another error
-	 */
-	mcp25xxfd_int_enable(cpriv->priv, false);
-
-	/* we could also put the driver in bus-off mode */
-
-	return IRQ_HANDLED;
-}
-
-int mcp25xxfd_can_int_clear(struct mcp25xxfd_priv *priv)
-{
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CAN_INT, 0,
-					MCP25XXFD_CAN_INT_IF_MASK);
-}
-
-int mcp25xxfd_can_int_enable(struct mcp25xxfd_priv *priv, bool enable)
-{
-	struct mcp25xxfd_can_priv *cpriv = priv->cpriv;
-	const u32 mask = MCP25XXFD_CAN_INT_TEFIE |
-		MCP25XXFD_CAN_INT_RXIE |
-		MCP25XXFD_CAN_INT_MODIE |
-		MCP25XXFD_CAN_INT_SERRIE |
-		MCP25XXFD_CAN_INT_IVMIE |
-		MCP25XXFD_CAN_INT_CERRIE |
-		MCP25XXFD_CAN_INT_RXOVIE |
-		MCP25XXFD_CAN_INT_ECCIE;
-	u32 value = cpriv ? cpriv->status.intf : 0;
-	int ret;
-
-	/* apply mask and */
-	value &= ~(MCP25XXFD_CAN_INT_IE_MASK);
-	if (enable)
-		value |= mask;
-
-	/* and write to int register */
-	ret = mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_CAN_INT,
-				       value, mask);
-	if (ret)
-		return ret;
-	if (!cpriv)
-		return 0;
-
-	cpriv->status.intf = value;
-
-	/* enable/disable interrupt handler */
-	if (cpriv->irq.allocated) {
-		if (enable && !cpriv->irq.enabled)
-			enable_irq(cpriv->priv->spi->irq);
-		if (!enable && cpriv->irq.enabled)
-			disable_irq(cpriv->priv->spi->irq);
-		cpriv->irq.enabled = enable;
-	} else {
-		cpriv->irq.enabled = false;
-	}
-
-	return 0;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h
deleted file mode 100644
index cc2ad992c307..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_int.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_CAN_INT_H
-#define __MCP25XXFD_CAN_INT_H
-
-#include "mcp25xxfd_priv.h"
-
-int mcp25xxfd_can_int_clear(struct mcp25xxfd_priv *priv);
-int mcp25xxfd_can_int_enable(struct mcp25xxfd_priv *priv, bool enable);
-
-irqreturn_t mcp25xxfd_can_int(int irq, void *dev_id);
-
-#endif /* __MCP25XXFD_CAN_INT_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h
deleted file mode 100644
index eeb9c88c7e97..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_priv.h
+++ /dev/null
@@ -1,203 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_PRIV_H
-#define __MCP25XXFD_CAN_PRIV_H
-
-#include <linux/can/dev.h>
-#include <linux/dcache.h>
-
-#include "mcp25xxfd_priv.h"
-
-#define TX_ECHO_SKB_MAX	32
-
-/* information on each fifo type */
-struct mcp25xxfd_fifo {
-	u32 count;
-	u32 start;
-	u32 size;
-#ifdef CONFIG_DEBUG_FS
-	u64 dlc_usage[16];
-	u64 fd_count;
-#endif /* CONFIG_DEBUG_FS */
-};
-
-/* used for sorting incoming messages */
-struct mcp25xxfd_obj_ts {
-	s32 ts; /* using signed to handle rollover correctly when sorting */
-	u16 fifo;
-	s16 is_rx;
-};
-
-/* general info on each fifo */
-struct mcp25xxfd_fifo_info {
-	u32 is_rx;
-	u32 offset;
-	u32 priority;
-#ifdef CONFIG_DEBUG_FS
-	u64 use_count;
-#endif /* CONFIG_DEBUG_FS */
-};
-
-struct mcp25xxfd_can_priv {
-	/* can_priv has to be the first one to be usable with alloc_candev
-	 * which expects struct can_priv to be right at the start of the
-	 * priv structure
-	 */
-	struct can_priv can;
-	struct mcp25xxfd_priv *priv;
-	struct regulator *transceiver;
-
-	/* the can mode currently active */
-	int mode;
-
-	/* interrupt state */
-	struct {
-		int enabled;
-		int allocated;
-	} irq;
-
-	/* can config registers */
-	struct {
-		u32 con;
-		u32 tdc;
-		u32 tscon;
-		u32 tefcon;
-		u32 nbtcfg;
-		u32 dbtcfg;
-	} regs;
-
-	/* can status registers (mostly) - read in one go
-	 * bdiag0 and bdiag1 are optional, but when
-	 * berr counters are requested on a regular basis
-	 * during high CAN-bus load this would trigger the fact
-	 * that spi_sync would get queued for execution in the
-	 * spi thread and the spi handler would not get
-	 * called inline in the interrupt thread without any
-	 * context switches or wakeups...
-	 */
-	struct {
-		u32 intf;
-		/* ASSERT(CAN_INT + 4 == CAN_RXIF) */
-		u32 rxif;
-		/* ASSERT(CAN_RXIF + 4 == CAN_TXIF) */
-		u32 txif;
-		/* ASSERT(CAN_TXIF + 4 == CAN_RXOVIF) */
-		u32 rxovif;
-		/* ASSERT(CAN_RXOVIF + 4 == CAN_TXATIF) */
-		u32 txatif;
-		/* ASSERT(CAN_TXATIF + 4 == CAN_TXREQ) */
-		u32 txreq;
-		/* ASSERT(CAN_TXREQ + 4 == CAN_TREC) */
-		u32 trec;
-	} status;
-
-	/* information of fifo setup */
-	struct {
-		/* define payload size and mode */
-		u32 payload_size;
-		u32 payload_mode;
-
-		/* infos on fifo layout */
-
-		/* TEF */
-		struct {
-			u32 count;
-			u32 size;
-			u32 index;
-		} tef;
-
-		/* info on each fifo */
-		struct mcp25xxfd_fifo_info info[32];
-
-		/* extra info on rx/tx fifo groups */
-		struct mcp25xxfd_fifo tx;
-		struct mcp25xxfd_fifo rx;
-
-		/* queue of can frames that need to get submitted
-		 * to the network stack during an interrupt loop in one go
-		 * (this gets sorted by timestamp before submission
-		 * and contains both rx frames as well tx frames that have
-		 * gone over the CAN bus successfully
-		 */
-		struct mcp25xxfd_obj_ts submit_queue[32];
-		int  submit_queue_count;
-
-		/* the tx queue of spi messages */
-		struct mcp25xxfd_tx_spi_message_queue *tx_queue;
-	} fifos;
-
-	/* statistics exposed via debugfs */
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs_dir;
-
-	struct {
-		u64 irq_calls;
-		u64 irq_loops;
-		u64 irq_thread_rescheduled;
-
-		u64 int_serr_count;
-		u64 int_serr_rx_count;
-		u64 int_serr_tx_count;
-		u64 int_mod_count;
-		u64 int_rx_count;
-		u64 int_txat_count;
-		u64 int_tef_count;
-		u64 int_rxov_count;
-		u64 int_ecc_count;
-		u64 int_ivm_count;
-		u64 int_cerr_count;
-
-		u64 tx_fd_count;
-		u64 tx_brs_count;
-
-		u64 tef_reads;
-		u64 tef_read_splits;
-		u64 tef_conservative_reads;
-		u64 tef_optimized_reads;
-#define MCP25XXFD_CAN_TEF_READ_BINS 8
-		u64 tef_optimized_read_sizes[MCP25XXFD_CAN_TEF_READ_BINS];
-
-		u64 rx_reads;
-		u64 rx_reads_prefetched_too_few;
-		u64 rx_reads_prefetched_too_few_bytes;
-		u64 rx_reads_prefetched_too_many;
-		u64 rx_reads_prefetched_too_many_bytes;
-		u64 rx_single_reads;
-		u64 rx_bulk_reads;
-#define MCP25XXFD_CAN_RX_BULK_READ_BINS 8
-		u64 rx_bulk_read_sizes[MCP25XXFD_CAN_RX_BULK_READ_BINS];
-	} stats;
-#endif /* CONFIG_DEBUG_FS */
-
-	/* history of rx-dlc */
-	struct {
-#define MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE 32
-		u8 dlc[MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE];
-		u8 brs[MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE];
-		u8 index;
-		u32 predicted_len;
-	} rx_history;
-
-	/* bus state */
-	struct {
-		u32 state;
-		u32 new_state;
-		u32 bdiag[2];
-	} bus;
-
-	/* can error messages */
-	struct {
-		u32 id;
-		u8  data[8];
-	} error_frame;
-
-	/* a copy of mcp25xxfd-sram in ram */
-	u8 sram[MCP25XXFD_SRAM_SIZE];
-};
-
-#endif /* __MCP25XXFD_CAN_PRIV_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c
deleted file mode 100644
index 0e3334f83f57..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.c
+++ /dev/null
@@ -1,521 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- *
- * Based on Microchip MCP251x CAN controller driver written by
- * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
- */
-
-#include <linux/can/core.h>
-#include <linux/can/dev.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <linux/slab.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_can_debugfs.h"
-#include "mcp25xxfd_can_id.h"
-#include "mcp25xxfd_can_priv.h"
-#include "mcp25xxfd_can_rx.h"
-
-/* module parameters */
-static unsigned int rx_prefetch_bytes = -1;
-module_param(rx_prefetch_bytes, uint, 0664);
-MODULE_PARM_DESC(rx_prefetch_bytes,
-		 "number of bytes to blindly prefetch when reading a rx-fifo");
-
-static struct sk_buff *
-mcp25xxfd_can_rx_submit_normal_frame(struct mcp25xxfd_can_priv *cpriv,
-				     u32 id, u32 dlc, u8 **data)
-{
-	struct can_frame *frame;
-	struct sk_buff *skb;
-
-	/* allocate frame */
-	skb = alloc_can_skb(cpriv->can.dev, &frame);
-	if (!skb)
-		return NULL;
-
-	/* set id, dlc and flags */
-	frame->can_id = id;
-	frame->can_dlc = dlc;
-
-	/* and set the pointer to data */
-	*data = frame->data;
-
-	return skb;
-}
-
-/* it is almost identical except for the type of the frame... */
-static struct sk_buff *
-mcp25xxfd_can_rx_submit_fd_frame(struct mcp25xxfd_can_priv *cpriv,
-				 u32 id, u32 flags, u32 len, u8 **data)
-{
-	struct canfd_frame *frame;
-	struct sk_buff *skb;
-
-	/* allocate frame */
-	skb = alloc_canfd_skb(cpriv->can.dev, &frame);
-	if (!skb)
-		return NULL;
-
-	/* set id, dlc and flags */
-	frame->can_id = id;
-	frame->len = len;
-	frame->flags |= flags;
-
-	/* and set the pointer to data */
-	*data = frame->data;
-
-	return skb;
-}
-
-int mcp25xxfd_can_rx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo)
-{
-	struct net_device *net = cpriv->can.dev;
-	int addr = cpriv->fifos.info[fifo].offset;
-	struct mcp25xxfd_can_obj_rx *rx =
-		(struct mcp25xxfd_can_obj_rx *)(cpriv->sram + addr);
-	u8 *data = NULL;
-	struct sk_buff *skb;
-	u32 id, dlc, len, flags;
-
-	/* compute the can_id */
-	mcp25xxfd_can_id_from_mcp25xxfd(rx->id, rx->flags, &id);
-
-	/* and dlc */
-	dlc = (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK) >>
-		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
-	len = can_dlc2len(dlc);
-
-	/* update stats */
-	net->stats.rx_packets++;
-	net->stats.rx_bytes += len;
-	cpriv->fifos.rx.dlc_usage[dlc]++;
-	if (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_FDF)
-		MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.rx.fd_count);
-
-	/* add to rx_history */
-	cpriv->rx_history.dlc[cpriv->rx_history.index] = dlc;
-	cpriv->rx_history.brs[cpriv->rx_history.index] =
-		(rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_BRS) ? CANFD_BRS : 0;
-	cpriv->rx_history.index++;
-	if (cpriv->rx_history.index >= MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE)
-		cpriv->rx_history.index = 0;
-
-	/* allocate the skb buffer */
-	if (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_FDF) {
-		flags = 0;
-		flags |= (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_BRS) ?
-			CANFD_BRS : 0;
-		flags |= (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_ESI) ?
-			CANFD_ESI : 0;
-		skb = mcp25xxfd_can_rx_submit_fd_frame(cpriv, id, flags,
-						       len, &data);
-	} else {
-		skb = mcp25xxfd_can_rx_submit_normal_frame(cpriv, id,
-							   len, &data);
-	}
-	if (!skb) {
-		netdev_err(net, "cannot allocate RX skb\n");
-		net->stats.rx_dropped++;
-		return -ENOMEM;
-	}
-
-	/* copy the payload data */
-	memcpy(data, rx->data, len);
-
-	/* and submit the frame */
-	netif_rx_ni(skb);
-
-	return 0;
-}
-
-static int mcp25xxfd_can_rx_read_frame(struct mcp25xxfd_can_priv *cpriv,
-				       int fifo, int prefetch_bytes, bool read)
-{
-	struct spi_device *spi = cpriv->priv->spi;
-	struct net_device *net = cpriv->can.dev;
-	int addr = cpriv->fifos.info[fifo].offset;
-	struct mcp25xxfd_can_obj_rx *rx =
-		(struct mcp25xxfd_can_obj_rx *)(cpriv->sram + addr);
-	int dlc;
-	int len, ret;
-
-	/* we read the header plus prefetch_bytes */
-	if (read) {
-		cpriv->stats.rx_single_reads++;
-		ret = mcp25xxfd_cmd_readn(spi, MCP25XXFD_SRAM_ADDR(addr),
-					  rx, sizeof(*rx) + prefetch_bytes);
-		if (ret)
-			return ret;
-	}
-
-	/* transpose the headers to CPU format */
-	rx->id = le32_to_cpu(*(__le32 *)&rx->id);
-	rx->flags = le32_to_cpu(*(__le32 *)&rx->flags);
-	rx->ts = le32_to_cpu(*(__le32 *)&rx->ts);
-
-	/* compute len */
-	dlc = (rx->flags & MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK) >>
-		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
-	len = can_dlc2len(min_t(int, dlc, (net->mtu == CANFD_MTU) ? 15 : 8));
-
-	/* read the remaining data for canfd frames */
-	if (read && len > prefetch_bytes) {
-		/* update stats */
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv,
-					     rx_reads_prefetched_too_few);
-		MCP25XXFD_DEBUGFS_STATS_ADD(cpriv,
-					    rx_reads_prefetched_too_few_bytes,
-					    len - prefetch_bytes);
-		/* here the extra portion reading data after prefetch */
-		ret = mcp25xxfd_cmd_readn(spi,
-					  MCP25XXFD_SRAM_ADDR(addr) +
-					  sizeof(*rx) + prefetch_bytes,
-					  &rx->data[prefetch_bytes],
-					  len - prefetch_bytes);
-		if (ret)
-			return ret;
-	}
-
-	/* update stats */
-	cpriv->stats.rx_reads++;
-	if (len < prefetch_bytes) {
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv,
-					     rx_reads_prefetched_too_many);
-		MCP25XXFD_DEBUGFS_STATS_ADD(cpriv,
-					    rx_reads_prefetched_too_many,
-					    prefetch_bytes - len);
-	}
-
-	/* clear the rest of the buffer - just to be safe */
-	memset(rx->data + len, 0, ((net->mtu == CANFD_MTU) ? 64 : 8) - len);
-
-	/* increment the statistics counter */
-	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.info[fifo].use_count);
-
-	/* add the fifo to the process queues */
-	mcp25xxfd_can_queue_frame(cpriv, fifo, rx->ts, true);
-
-	/* and clear the interrupt flag for that fifo */
-	return mcp25xxfd_cmd_write_mask(spi, MCP25XXFD_CAN_FIFOCON(fifo),
-					MCP25XXFD_CAN_FIFOCON_FRESET,
-					MCP25XXFD_CAN_FIFOCON_FRESET);
-}
-
-static int mcp25xxfd_can_read_rx_frame_bulk(struct mcp25xxfd_can_priv *cpriv,
-					    int fstart,
-					    int fend)
-{
-	struct net_device *net = cpriv->can.dev;
-	int count = abs(fend - fstart) + 1;
-	int flowest = min_t(int, fstart, fend);
-	int addr = cpriv->fifos.info[flowest].offset;
-	struct mcp25xxfd_can_obj_rx *rx =
-		(struct mcp25xxfd_can_obj_rx *)(cpriv->sram + addr);
-	int len = (sizeof(*rx) + ((net->mtu == CANFD_MTU) ? 64 : 8)) * count;
-	int fifo, i, ret;
-
-	/* update stats */
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, rx_bulk_reads);
-	i = min_t(int, MCP25XXFD_CAN_RX_BULK_READ_BINS - 1, count - 1);
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, rx_bulk_read_sizes[i]);
-
-	/* we read the header plus read_min data bytes */
-	ret = mcp25xxfd_cmd_readn(cpriv->priv->spi, MCP25XXFD_SRAM_ADDR(addr),
-				  rx, len);
-	if (ret)
-		return ret;
-
-	/* now process all of them - no need to read... */
-	for (fifo = fstart; count > 0; fifo ++, count--) {
-		ret = mcp25xxfd_can_rx_read_frame(cpriv, fifo, 8, false);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/* predict dlc size based on historic behaviour */
-static int mcp25xxfd_can_rx_predict_prefetch(struct mcp25xxfd_can_priv *cpriv)
-{
-	int dlc, i, top;
-	u8 histo[16];
-
-	/* if we have a prfecth set then use that one */
-	if (rx_prefetch_bytes != -1)
-		return min_t(int, rx_prefetch_bytes,
-			     (cpriv->can.dev->mtu == CANFD_MTU) ? 64 : 8);
-
-	/* memset */
-	memset(histo, 0, sizeof(histo));
-
-	/* for all others compute the histogram */
-	for (i = 0; i < MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE; i++)
-		histo[cpriv->rx_history.dlc[i]]++;
-
-	/* and now find the highest fit */
-	for (i = (cpriv->can.dev->mtu == CANFD_MTU) ? 15 : 8, dlc = 8, top = 0;
-	      i >= 0; i--) {
-		if (top < histo[i]) {
-			top = histo[i];
-			dlc = i;
-		}
-	}
-
-	/* compute length from dlc */
-	cpriv->rx_history.predicted_len = can_dlc2len(dlc);
-
-	/* return the predicted length */
-	return cpriv->rx_history.predicted_len;
-}
-
-/* at least in can2.0 mode we can read multiple RX-fifos in one go
- * in case they are ajactent to each other and thus we can reduce
- * the number of spi messages produced and this improves spi-bus
- * usage efficiency.
- * In canFD mode this may also be possible, but would need some
- * statistics to decide if it is worth reading a full 64 bytes
- * in one go.
- * But those statistics can get used to predict how many bytes
- * to read together with the can header (which is fixed to 8 at
- * this very moment.
- *
- * notes on the rational here:
- * * Reading just the CAN header info takes:
- *   * bytes read
- *     *  2 bytes command+address
- *     * 12 bytes data (id, flags, timestamp)
- *   * so that is at the very least 112 SCK (= 14 byte * 8 SCK/1 byte)
- *     - on a Raspberry pi 3 for such short requests actually
- *       126 SCK (=14 byte * 9 SCK/1 byte)
- *   * some SPI framework overhead which is observed to be 5-10 us
- *     on a raspberry pi 3 (time between SCK and stop SCK start)
- *   * with an effective 17.85 MHz SPI clock on a RPI it takes in total:
- *     it takes 12us = 6us + 6us
- * * now reading 8 bytes of CAN data (can2.0) takes:
- *   * bytes read
- *     *  2 bytes command+address
- *     *  8 bytes data
- *   * so that is at the very least 80 SCK (= 10 byte * 8 SCK/1 byte)
- *     - on a Raspberry pi 3 for such short requests actually
- *       90 SCK (= 10 byte * 9 SCK/1 byte)
- *   * some SPI framework overhead which is observed to be 5-10 us
- *     on a raspberry pi 3 (time between SCK and stop SCK start)
- *   * with an effective 17.85 MHz SPI clock on a RPI it takes in total:
- *     it takes 11us = 5.0us + 6us
- * * now reading CAN header plus 8 bytes of CAN data (can2.0) takes:
- *   * bytes read
- *     *  2 bytes command+address
- *     * 20 bytes data
- *   * so that is at the very least 176 SCK (= 22 byte * 8 SCK/1 byte)
- *     - on a Raspberry pi 3 for such short requests actually
- *       198 SCK (= 22 byte * 9 SCK/1 byte)
- *   * some SPI framework overhead which is observed to be 5-10 us
- *     on a raspberry pi 3 (time between SCK and stop SCK start)
- *   * with an effective 17.85 MHz SPI clock on a RPI it takes in total:
- *     it takes 17.1us = 11.1us + 6us
- *   * this is faster than the 2 individual SPI transfers for header
- *     and data which is in total 23us
- *     * this is even true for the case where we only have a single
- *       data byte (DLC=1) - the time here is 19.5us on a RPI3
- *     * the only time where we are less efficient is for the DLC=0 case.
- *       but the assumption here is that this is a rare case
- * To put it into perspective here the full table for a RPI3:
- * LE 2m  pr0 pr1 pr2 pr3 pr4 pr5  pr6  pr7  pr8 pr12 pr16 pr20 pr24 pr32 pr48
- *                                                                         pr64
- *  0  7.1 7.1
- *  1 14.6    7.6 8.1 8.6 9.1 9.6 10.1 10.6 11.1 13.1
- *  2 15.1        8.1 8.6 9.1 9.6 10.1 10.6 11.1 13.1
- *  3 15.6            8.6 9.1 9.6 10.1 10.6 11.1 13.1 15.1
- *  4 16.1                9.1 9.6 10.1 10.6 11.1 13.1 15.1
- *  5 16.6                    9.6 10.1 10.6 11.1 13.1 15.1
- *  6 17.1                        10.1 10.6 11.1 13.1 15.1
- *  7 17.6                             10.6 11.1 13.1 15.1 17.1
- *  8 18.1                                  11.1 13.1 15.1 17.1
- * 12 20.1                                       13.1 15.1 17.1 19.2
- * 16 22.1                                            15.1 17.1 19.2
- * 20 24.1                                                 17.1 19.2 23.2
- * 24 26.2                                                      19.2 23.2
- * 32 30.2                                                           23.2
- * 48 38.3                                                                31.3
- * 64 46.3                                                                 39.3
- * (Parameters: SPI Clock=17.8MHz, SCK/byte=9, overhead=6us)
- * Legend:
- *   LE = length,
- *   2m    = 2 SPI messages (header+data - except for LEN=0, only header)
- *  prX/pX = prefecth length times (only shown when < 2m and Len >= Prefetch)
- *
- * The diagonal schows the "optimal" time when the size of the Can frame would
- * be known ahead of time - i.e if it would be possible to define RX reception
- * filters based on can DLC values
- *
- * So for any Can frame except for LEN=0 the prefetch data solution is
- * better for prefetch of data=12 for CanFD.
- *
- * Here another table showing the optimal prefetch limits for SPI speeds
- * vs overhead_us at 8 or 9 SCLK/byte
- *
- * MHZ  2us@8   2us@9   4us@8   4us@9   6us@8   6us@9   8us@8   8us@9
- * 10.0 8b***   8b***   8b      8b*     12b**   8b*     12b     12b*
- * 12.5 8b**    8b***   12b***  8b      12b     12b*    16b*    16b**
- * 15.0 8b**    8b**    12b**   12b***  16b**   12b     20b**   16b
- * 17.5 8b*     8b*     12b*    12b**   16b     16b**   20b     20b**
- * 20.0 8b      8b*     16b***  12b*    20b**   16b     24b*    20b
- * (a * signifies not a full match, but for any length > count(*))
- *
- * So 8 bytes prefetch seems to be a very good tradeoff for can frame
- * except for DLC/LEN=0 frames.
- * The question here is mainly: how many frames do we have with DLC=0
- * vs all others.
- *
- * With some statistics of recent CAN frames this may be set dynamically
- * in the future.
- *
- * For this to work efficiently we would also need an estimate on
- * the SPI framework overhead, which is a function of the spi-bus-driver
- * implementation details, CPU type and speed as well as system load.
- * Also the effective SPI-clock speed is needed as well as the
- * number of spi clock cycles it takes for a single byte to get transferred
- * The bcm283x SOC for example pauses the SPI clock one cycle after
- * every byte it sends unless the data is fed to the controller by DMA.
- * (but for short transfers DMA mapping is very expensive and not worth
- * the effort. PIO and - in some situations - polling is used instead to
- * reduce the number of interrupts and the need for thread scheduling as
- * much as possible)
- *
- * This also means that for can2.0 only configured interfaces
- * reading multiple rx fifos is a realistic option of optimization
- */
-
-static int mcp25xxfd_can_rx_read_single_frames(struct mcp25xxfd_can_priv *cpriv,
-					       int prefetch)
-{
-	int i, f, ret;
-
-	/* loop all frames */
-	for (i = 0, f = cpriv->fifos.rx.start; i < cpriv->fifos.rx.count;
-	     i++, f++) {
-		if (cpriv->status.rxif & BIT(f)) {
-			/* read the frame */
-			ret = mcp25xxfd_can_rx_read_frame(cpriv, f,
-							  prefetch, true);
-			if (ret)
-				return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_can_rx_read_bulk_frames(struct mcp25xxfd_can_priv *cpriv)
-{
-	int i, start, end;
-	int ret;
-
-	/* iterate over fifos trying to find fifos next to each other */
-	for (i = 0, start = cpriv->fifos.rx.start, end = start;
-	     i < cpriv->fifos.rx.count; i++, end++, start = end) {
-		/* if bit is not set then continue */
-		if (!(cpriv->status.rxif & BIT(start)))
-			continue;
-		/* find the last fifo with a bit set in sequence */
-		for (end = start; cpriv->status.rxif & BIT(end + 1); end++)
-			;
-		/* and now read those fifos in bulk */
-		ret = mcp25xxfd_can_read_rx_frame_bulk(cpriv, start, end);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_can_rx_read_fd_frames(struct mcp25xxfd_can_priv *cpriv)
-{
-	int i, count_dlc15, count_brs, prefetch;
-
-	/* get a prediction on prefetch */
-	prefetch = mcp25xxfd_can_rx_predict_prefetch(cpriv);
-
-	/* if the prefetch is < 64 then just read single */
-	if (prefetch < 64)
-		return mcp25xxfd_can_rx_read_single_frames(cpriv, prefetch);
-
-	/* check if we have mostly brs frames of those DLC=15 frames */
-	for (i = 0, count_brs = 0, count_dlc15 = 0;
-	     i < MCP25XXFD_CAN_RX_DLC_HISTORY_SIZE; i++)
-		if (cpriv->rx_history.dlc[i] == 15) {
-			count_dlc15++;
-			if (cpriv->rx_history.brs[i])
-				count_brs++;
-		}
-
-	/* if we have at least 33% brs frames then run bulk */
-	if (count_brs * 3 >= count_dlc15)
-		return mcp25xxfd_can_rx_read_bulk_frames(cpriv);
-	else
-		return mcp25xxfd_can_rx_read_single_frames(cpriv, prefetch);
-}
-
-static int mcp25xxfd_can_rx_read_frames(struct mcp25xxfd_can_priv *cpriv)
-{
-	if (cpriv->can.dev->mtu == CANFD_MTU)
-		return mcp25xxfd_can_rx_read_fd_frames(cpriv);
-	else
-		return mcp25xxfd_can_rx_read_bulk_frames(cpriv);
-}
-
-int mcp25xxfd_can_rx_handle_int_rxif(struct mcp25xxfd_can_priv *cpriv)
-{
-	if (!cpriv->status.rxif)
-		return 0;
-
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_rx_count);
-
-	/* read all the fifos */
-	return mcp25xxfd_can_rx_read_frames(cpriv);
-}
-
-int mcp25xxfd_can_rx_handle_int_rxovif(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 mask = MCP25XXFD_CAN_FIFOSTA_RXOVIF;
-	int ret, i, reg;
-
-	if (!cpriv->status.rxovif)
-		return 0;
-
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_rxov_count);
-
-	/* clear all fifos that have an overflow bit set */
-	for (i = 0; i < 32; i++) {
-		if (cpriv->status.rxovif & BIT(i)) {
-			/* clear fifo status */
-			reg = MCP25XXFD_CAN_FIFOSTA(i);
-			ret = mcp25xxfd_cmd_write_mask(cpriv->priv->spi,
-						       reg, 0, mask);
-			if (ret)
-				return ret;
-
-			/* update statistics */
-			cpriv->can.dev->stats.rx_over_errors++;
-			cpriv->can.dev->stats.rx_errors++;
-
-			/* and prepare ERROR FRAME */
-			cpriv->error_frame.id |= CAN_ERR_CRTL;
-			cpriv->error_frame.data[1] |=
-				CAN_ERR_CRTL_RX_OVERFLOW;
-		}
-	}
-
-	return 0;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h
deleted file mode 100644
index 71953e2f3615..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_rx.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_RX_H
-#define __MCP25XXFD_CAN_RX_H
-
-#include "mcp25xxfd_priv.h"
-
-int mcp25xxfd_can_rx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo);
-
-int mcp25xxfd_can_rx_handle_int_rxif(struct mcp25xxfd_can_priv *cpriv);
-int mcp25xxfd_can_rx_handle_int_rxovif(struct mcp25xxfd_can_priv *cpriv);
-
-#endif /* __MCP25XXFD_CAN_RX_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c
deleted file mode 100644
index 50252d530725..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.c
+++ /dev/null
@@ -1,795 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- *
- * Based on Microchip MCP251x CAN controller driver written by
- * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
- */
-
-#include <linux/can/core.h>
-#include <linux/can/dev.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/netdevice.h>
-#include <linux/slab.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_can_id.h"
-#include "mcp25xxfd_can_tx.h"
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_regs.h"
-
-/* mostly bit manipulations to move between stages */
-static struct mcp25xxfd_tx_spi_message *
-mcp25xxfd_can_tx_queue_first_spi_message(struct mcp25xxfd_tx_spi_message_queue *
-					 queue, u32 *bitmap)
-{
-	u32 first = ffs(*bitmap);
-
-	if (!first)
-		return NULL;
-
-	return queue->fifo2message[first - 1];
-}
-
-static void mcp25xxfd_can_tx_queue_remove_spi_message(u32 *bitmap, int fifo)
-{
-	*bitmap &= ~BIT(fifo);
-}
-
-static void mcp25xxfd_can_tx_queue_add_spi_message(u32 *bitmap, int fifo)
-{
-	*bitmap |= BIT(fifo);
-}
-
-static void mcp25xxfd_can_tx_queue_move_spi_message(u32 *src, u32 *dest,
-						    int fifo)
-{
-	mcp25xxfd_can_tx_queue_remove_spi_message(src, fifo);
-	mcp25xxfd_can_tx_queue_add_spi_message(dest, fifo);
-}
-
-static void mcp25xxfd_can_tx_spi_message_fill_fifo_complete(void *context)
-{
-	struct mcp25xxfd_tx_spi_message *msg = context;
-	struct mcp25xxfd_can_priv *cpriv = msg->cpriv;
-	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
-	unsigned long flags;
-
-	/* reset transfer length to without data (DLC = 0) */
-	msg->fill_fifo.xfer.len = sizeof(msg->fill_fifo.data.cmd) +
-		sizeof(msg->fill_fifo.data.header);
-
-	/* we need to hold this lock to protect us from
-	 * concurrent access by start_xmit
-	 */
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* move to in_trigger_fifo_transfer */
-	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_fill_fifo_transfer,
-						&q->in_trigger_fifo_transfer,
-						msg->fifo);
-
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-}
-
-static void mcp25xxfd_can_tx_spi_message_trigger_fifo_complete(void *context)
-{
-	struct mcp25xxfd_tx_spi_message *msg = context;
-	struct mcp25xxfd_can_priv *cpriv = msg->cpriv;
-	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
-	unsigned long flags;
-
-	/* we need to hold this lock to protect us from
-	 * concurrent access by the interrupt thread
-	 */
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* move to can_transfer */
-	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_trigger_fifo_transfer,
-						&q->in_can_transfer,
-						msg->fifo);
-
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-}
-
-static
-void mcp25xxfd_can_tx_message_init(struct mcp25xxfd_can_priv *cpriv,
-				   struct mcp25xxfd_tx_spi_message *msg,
-				   int fifo)
-{
-	const u32 trigger = MCP25XXFD_CAN_FIFOCON_TXREQ |
-		MCP25XXFD_CAN_FIFOCON_UINC;
-	const int first_byte = mcp25xxfd_cmd_first_byte(trigger);
-	u32 addr;
-
-	/* and initialize the structure */
-	msg->cpriv = cpriv;
-	msg->fifo = fifo;
-
-	/* init fill_fifo */
-	spi_message_init(&msg->fill_fifo.msg);
-	msg->fill_fifo.msg.complete =
-		mcp25xxfd_can_tx_spi_message_fill_fifo_complete;
-	msg->fill_fifo.msg.context = msg;
-
-	msg->fill_fifo.xfer.speed_hz = cpriv->priv->spi_use_speed_hz;
-	msg->fill_fifo.xfer.tx_buf = msg->fill_fifo.data.cmd;
-	msg->fill_fifo.xfer.len = sizeof(msg->fill_fifo.data.cmd) +
-		sizeof(msg->fill_fifo.data.header);
-	spi_message_add_tail(&msg->fill_fifo.xfer, &msg->fill_fifo.msg);
-
-	addr = MCP25XXFD_SRAM_ADDR(cpriv->fifos.info[fifo].offset);
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE, addr,
-			   msg->fill_fifo.data.cmd);
-
-	/* init trigger_fifo */
-	spi_message_init(&msg->trigger_fifo.msg);
-	msg->trigger_fifo.msg.complete =
-		mcp25xxfd_can_tx_spi_message_trigger_fifo_complete;
-	msg->trigger_fifo.msg.context = msg;
-
-	msg->trigger_fifo.xfer.speed_hz = cpriv->priv->spi_use_speed_hz;
-	msg->trigger_fifo.xfer.tx_buf = msg->trigger_fifo.data.cmd;
-	msg->trigger_fifo.xfer.len = sizeof(msg->trigger_fifo.data.cmd) +
-		sizeof(msg->trigger_fifo.data.data);
-	spi_message_add_tail(&msg->trigger_fifo.xfer, &msg->trigger_fifo.msg);
-
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE,
-			   MCP25XXFD_CAN_FIFOCON(fifo) + first_byte,
-			   msg->trigger_fifo.data.cmd);
-	msg->trigger_fifo.data.data = trigger >> (8 * first_byte);
-
-	/* and add to idle tx transfers */
-	mcp25xxfd_can_tx_queue_add_spi_message(&cpriv->fifos.tx_queue->idle,
-					       fifo);
-}
-
-static
-void mcp25xxfd_can_tx_queue_manage_nolock(struct mcp25xxfd_can_priv *cpriv,
-					  int state)
-{
-	struct net_device *net = cpriv->can.dev;
-
-	/* skip early */
-	if (state == cpriv->fifos.tx_queue->state)
-		return;
-
-	/* start/stop netif_queue if necessary */
-	switch (cpriv->fifos.tx_queue->state) {
-	case MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE:
-		switch (state) {
-		case MCP25XXFD_CAN_TX_QUEUE_STATE_RESTART:
-		case MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED:
-			netif_wake_queue(net);
-			cpriv->fifos.tx_queue->state =
-				MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED;
-			break;
-		}
-		break;
-	case MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED:
-		switch (state) {
-		case MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED:
-			netif_wake_queue(net);
-			cpriv->fifos.tx_queue->state = state;
-			break;
-		}
-		break;
-	case MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED:
-		switch (state) {
-		case MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE:
-		case MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED:
-			netif_stop_queue(net);
-			cpriv->fifos.tx_queue->state = state;
-			break;
-		}
-		break;
-	default:
-		WARN(true, "Unsupported tx_queue state: %i\n",
-		     cpriv->fifos.tx_queue->state);
-		break;
-	}
-}
-
-void mcp25xxfd_can_tx_queue_manage(struct mcp25xxfd_can_priv *cpriv, int state)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-
-	mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
-
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-}
-
-void mcp25xxfd_can_tx_queue_restart(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 state = MCP25XXFD_CAN_TX_QUEUE_STATE_RESTART;
-	unsigned long flags;
-	u32 mask;
-
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* only move if there is nothing pending or idle */
-	mask = cpriv->fifos.tx_queue->idle |
-		cpriv->fifos.tx_queue->in_fill_fifo_transfer |
-		cpriv->fifos.tx_queue->in_trigger_fifo_transfer |
-		cpriv->fifos.tx_queue->in_can_transfer;
-	if (mask)
-		goto out;
-
-	/* move all items from transferred to idle */
-	cpriv->fifos.tx_queue->idle |= cpriv->fifos.tx_queue->transferred;
-	cpriv->fifos.tx_queue->transferred = 0;
-
-	/* and enable queue */
-	mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
-out:
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-}
-
-static
-int mcp25xxfd_can_tx_tef_read(struct mcp25xxfd_can_priv *cpriv,
-			      int start, int count)
-{
-	u32 tef_offset = start * cpriv->fifos.tef.size;
-	struct mcp25xxfd_can_obj_tef *tef =
-		(struct mcp25xxfd_can_obj_tef *)(cpriv->sram + tef_offset);
-	int last, read, ret;
-
-	/* compute how many we can read in one go */
-	last = start + count;
-	read = (last > cpriv->fifos.tef.count) ?
-		(cpriv->fifos.tef.count - start) :
-		count;
-
-	/* and read it */
-	ret = mcp25xxfd_cmd_read_regs(cpriv->priv->spi,
-				      MCP25XXFD_SRAM_ADDR(tef_offset),
-				      &tef->id, sizeof(*tef) * read);
-	if (ret)
-		return ret;
-
-	/* and read a second part on wrap */
-	if (read != count) {
-		/* update stats */
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_read_splits);
-		/* compute the addresses  */
-		read = count - read;
-		tef = (struct mcp25xxfd_can_obj_tef *)(cpriv->sram);
-		/* and read again */
-		ret = mcp25xxfd_cmd_read_regs(cpriv->priv->spi,
-					      MCP25XXFD_SRAM_ADDR(0),
-					      &tef->id,
-					      sizeof(*tef) * read);
-	}
-
-	return ret;
-}
-
-static
-int mcp25xxfd_can_tx_handle_int_tefif_fifo(struct mcp25xxfd_can_priv *cpriv,
-					   bool read_data)
-{
-	u32 tef_offset = cpriv->fifos.tef.index * cpriv->fifos.tef.size;
-	struct mcp25xxfd_can_obj_tef *tef =
-		(struct mcp25xxfd_can_obj_tef *)(cpriv->sram + tef_offset);
-	int fifo, ret;
-	unsigned long flags;
-
-	/* read the next TEF entry to get the transmit timestamp and fifo */
-	if (read_data) {
-		ret = mcp25xxfd_can_tx_tef_read(cpriv,
-						cpriv->fifos.tef.index, 1);
-		if (ret)
-			return ret;
-	}
-
-	/* get the fifo from tef */
-	fifo = (tef->flags & MCP25XXFD_CAN_OBJ_FLAGS_SEQ_MASK) >>
-		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT;
-
-	/* check that the fifo is valid */
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-	if ((cpriv->fifos.tx_queue->in_can_transfer & BIT(fifo)) == 0)
-		netdev_err(cpriv->can.dev,
-			   "tefif: fifo %i not pending - tef data: id: %08x flags: %08x, ts: %08x - this may be a problem with spi signal quality- try reducing spi-clock speed if this can get reproduced",
-			   fifo, tef->id, tef->flags, tef->ts);
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* update stats */
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_reads);
-
-	/* now we can schedule the fifo for echo submission */
-	mcp25xxfd_can_queue_frame(cpriv, fifo, tef->ts, false);
-
-	/* increment the tef index with wraparround */
-	cpriv->fifos.tef.index++;
-	if (cpriv->fifos.tef.index >= cpriv->fifos.tef.count)
-		cpriv->fifos.tef.index = 0;
-
-	/* finally just increment the TEF pointer */
-	return mcp25xxfd_cmd_write_mask(cpriv->priv->spi, MCP25XXFD_CAN_TEFCON,
-					MCP25XXFD_CAN_TEFCON_UINC,
-					MCP25XXFD_CAN_TEFCON_UINC);
-}
-
-/* reading TEF entries can be made even more efficient by reading
- * multiple TEF entries in one go.
- * Under the assumption that we have count(TEF) >= count(TX_FIFO)
- * we can even release TEFs early (before we read them)
- * (and potentially restarting the transmit-queue early aswell)
- */
-
-static int
-mcp25xxfd_can_tx_handle_int_tefif_conservative(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 tefsta;
-	int ret;
-
-	/* read the TEF status */
-	ret = mcp25xxfd_cmd_read_mask(cpriv->priv->spi, MCP25XXFD_CAN_TEFSTA,
-				      &tefsta, MCP25XXFD_CAN_TEFSTA_TEFNEIF);
-	if (ret)
-		return ret;
-
-	/* read the tef in an inefficient loop */
-	while (tefsta & MCP25XXFD_CAN_TEFSTA_TEFNEIF) {
-		/* read one tef */
-		ret = mcp25xxfd_can_tx_handle_int_tefif_fifo(cpriv, true);
-		if (ret)
-			return ret;
-
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_conservative_reads);
-
-		/* read the TEF status */
-		ret = mcp25xxfd_cmd_read_mask(cpriv->priv->spi,
-					      MCP25XXFD_CAN_TEFSTA, &tefsta,
-					      MCP25XXFD_CAN_TEFSTA_TEFNEIF);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int
-mcp25xxfd_can_tx_handle_int_tefif_optimized(struct mcp25xxfd_can_priv *cpriv,
-					    u32 finished)
-{
-	int i, fifo, count, ret;
-
-	/* count the number of fifos that have terminated */
-	for (i = 0, fifo = cpriv->fifos.tx.start, count = 0;
-	     i < cpriv->fifos.tx.count; i++, fifo++)
-		if (finished & BIT(fifo))
-			count++;
-
-	/* read them in one go if possible
-	 * we also assume that we have count(TEF) >= count(TX-FIFOS)
-	 * this may require 2 reads when we wrap arround
-	 * (that is unless count(TEF) == count(TX-FIFOS))
-	 */
-	ret = mcp25xxfd_can_tx_tef_read(cpriv, cpriv->fifos.tef.index, count);
-	if (ret)
-		return ret;
-
-	/* update stats */
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_optimized_reads);
-	i = min_t(int, MCP25XXFD_CAN_TEF_READ_BINS - 1, count - 1);
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tef_optimized_read_sizes[i]);
-
-	/* now iterate those */
-	for (i = 0, fifo = cpriv->fifos.tx.start; i < cpriv->fifos.tx.count;
-	     i++, fifo++) {
-		if (finished & BIT(fifo)) {
-			ret = mcp25xxfd_can_tx_handle_int_tefif_fifo(cpriv,
-								     false);
-			if (ret)
-				return ret;
-		}
-	}
-
-	return 0;
-}
-
-int mcp25xxfd_can_tx_handle_int_tefif(struct mcp25xxfd_can_priv *cpriv)
-{
-	unsigned long flags;
-	u32 finished;
-
-	if (!(cpriv->status.intf & MCP25XXFD_CAN_INT_TEFIF))
-		return 0;
-
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_tef_count);
-
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* compute finished fifos and clear them immediately */
-	finished = (cpriv->fifos.tx_queue->in_can_transfer ^
-		    cpriv->status.txreq) &
-		cpriv->fifos.tx_queue->in_can_transfer;
-
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* run in optimized mode if possible */
-	if (finished)
-		return mcp25xxfd_can_tx_handle_int_tefif_optimized(cpriv,
-								   finished);
-	/* otherwise play it safe */
-	netdev_warn(cpriv->can.dev,
-		    "Something is wrong - we got a TEF interrupt but we were not able to detect a finished fifo\n");
-	return mcp25xxfd_can_tx_handle_int_tefif_conservative(cpriv);
-}
-
-static
-void mcp25xxfd_can_tx_fill_fifo_common(struct mcp25xxfd_can_priv *cpriv,
-				       struct mcp25xxfd_tx_spi_message *smsg,
-				       struct mcp25xxfd_can_obj_tx *tx,
-				       int dlc, u8 *data)
-{
-	int len = can_dlc2len(dlc);
-
-	/* update statistics */
-	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.tx.dlc_usage[dlc]);
-	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.info[smsg->fifo].use_count);
-
-	/* add fifo number as seq */
-	tx->flags |= smsg->fifo << MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT;
-
-	/* copy data to tx->data for future reference */
-	memcpy(tx->data, data, len);
-
-	/* transform header to controller format */
-	mcp25xxfd_cmd_convert_from_cpu(&tx->id, sizeof(*tx) / sizeof(u32));
-
-	/* copy header + data to final location - we are not aligned */
-	memcpy(smsg->fill_fifo.data.header, &tx->id, sizeof(*tx) + len);
-
-	/* transfers to sram should be a multiple of 4 and be zero padded */
-	for (; len & 3; len++)
-		*(smsg->fill_fifo.data.header + sizeof(*tx) + len) = 0;
-
-	/* convert it back to CPU format */
-	mcp25xxfd_cmd_convert_to_cpu(&tx->id, sizeof(*tx) / sizeof(u32));
-
-	/* set up size of transfer */
-	smsg->fill_fifo.xfer.len = sizeof(smsg->fill_fifo.data.cmd) +
-		sizeof(smsg->fill_fifo.data.header) + len;
-}
-
-static
-void mcp25xxfd_can_tx_fill_fifo_fd(struct mcp25xxfd_can_priv *cpriv,
-				   struct canfd_frame *frame,
-				   struct mcp25xxfd_tx_spi_message *smsg,
-				   struct mcp25xxfd_can_obj_tx *tx)
-{
-	int dlc = can_len2dlc(frame->len);
-
-	/* update some statistics */
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_fd_count);
-
-	/* compute can id */
-	mcp25xxfd_can_id_to_mcp25xxfd(frame->can_id, &tx->id, &tx->flags);
-
-	/* setup flags */
-	tx->flags |= dlc << MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
-	tx->flags |= (frame->can_id & CAN_EFF_FLAG) ?
-		MCP25XXFD_CAN_OBJ_FLAGS_IDE : 0;
-	tx->flags |= (frame->can_id & CAN_RTR_FLAG) ?
-		MCP25XXFD_CAN_OBJ_FLAGS_RTR : 0;
-	if (frame->flags & CANFD_BRS) {
-		tx->flags |= MCP25XXFD_CAN_OBJ_FLAGS_BRS;
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_brs_count);
-	}
-	tx->flags |= (frame->flags & CANFD_ESI) ?
-		MCP25XXFD_CAN_OBJ_FLAGS_ESI : 0;
-	tx->flags |= MCP25XXFD_CAN_OBJ_FLAGS_FDF;
-
-	/* and do common processing */
-	mcp25xxfd_can_tx_fill_fifo_common(cpriv, smsg, tx, dlc, frame->data);
-}
-
-static
-void mcp25xxfd_can_tx_fill_fifo(struct mcp25xxfd_can_priv *cpriv,
-				struct can_frame *frame,
-				struct mcp25xxfd_tx_spi_message *smsg,
-				struct mcp25xxfd_can_obj_tx *tx)
-{
-	/* set frame to valid dlc */
-	if (frame->can_dlc > 8)
-		frame->can_dlc = 8;
-
-	/* compute can id */
-	mcp25xxfd_can_id_to_mcp25xxfd(frame->can_id, &tx->id, &tx->flags);
-
-	/* setup flags */
-	tx->flags |= frame->can_dlc << MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
-	tx->flags |= (frame->can_id & CAN_EFF_FLAG) ?
-		MCP25XXFD_CAN_OBJ_FLAGS_IDE : 0;
-	tx->flags |= (frame->can_id & CAN_RTR_FLAG) ?
-		MCP25XXFD_CAN_OBJ_FLAGS_RTR : 0;
-
-	/* and do common processing */
-	mcp25xxfd_can_tx_fill_fifo_common(cpriv, smsg, tx, frame->can_dlc,
-					  frame->data);
-}
-
-static struct mcp25xxfd_tx_spi_message *
-mcp25xxfd_can_tx_queue_get_next_fifo(struct mcp25xxfd_can_priv *cpriv)
-{
-	u32 state = MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE;
-	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
-	struct mcp25xxfd_tx_spi_message *smsg;
-	unsigned long flags;
-
-	/* we need to hold this lock to protect us against
-	 * concurrent modifications of cpriv->fifos.tx_queue->idle
-	 * in the interrupt thread
-	 */
-	spin_lock_irqsave(&q->lock, flags);
-
-	/* get the first entry from idle */
-	smsg = mcp25xxfd_can_tx_queue_first_spi_message(q, &q->idle);
-	if (!smsg)
-		goto out_busy;
-
-	/* and move the fifo to next stage */
-	mcp25xxfd_can_tx_queue_move_spi_message(&q->idle,
-						&q->in_fill_fifo_transfer,
-						smsg->fifo);
-
-	/* if queue is empty then stop the network queue immediately */
-	if (!q->idle)
-		mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
-out_busy:
-	spin_unlock_irqrestore(&q->lock, flags);
-
-	return smsg;
-}
-
-/* submit the can message to the can-bus */
-netdev_tx_t mcp25xxfd_can_tx_start_xmit(struct sk_buff *skb,
-					struct net_device *net)
-{
-	u32 state = MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED;
-	struct mcp25xxfd_can_priv *cpriv = netdev_priv(net);
-	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
-	struct mcp25xxfd_priv *priv = cpriv->priv;
-	struct spi_device *spi = priv->spi;
-	struct mcp25xxfd_tx_spi_message *smsg;
-	struct mcp25xxfd_can_obj_tx *tx;
-	unsigned long flags;
-	int ret;
-
-	/* invalid skb we can ignore */
-	if (can_dropped_invalid_skb(net, skb))
-		return NETDEV_TX_OK;
-
-	/* acquire lock on spi so that we are are not risking
-	 * some reordering of spi messages when we are running
-	 * start_xmit in multiple threads (on multiple cores)
-	 */
-	spin_lock_irqsave(&q->spi_lock, flags);
-
-	/* get the fifo message structure to process now */
-	smsg = mcp25xxfd_can_tx_queue_get_next_fifo(cpriv);
-	if (!smsg)
-		goto out_busy;
-
-	/* compute the fifo in sram */
-	tx = (struct mcp25xxfd_can_obj_tx *)
-		(cpriv->sram + cpriv->fifos.info[smsg->fifo].offset);
-
-	/* fill in message from skb->data depending on can2.0 or canfd */
-	if (can_is_canfd_skb(skb))
-		mcp25xxfd_can_tx_fill_fifo_fd(cpriv,
-					      (struct canfd_frame *)skb->data,
-					      smsg, tx);
-	else
-		mcp25xxfd_can_tx_fill_fifo(cpriv,
-					   (struct can_frame *)skb->data,
-					   smsg, tx);
-
-	/* submit the two messages asyncronously
-	 * the reason why we separate transfers into two spi_messages is:
-	 *  * because the spi framework (currently) does add a 10us delay
-	 *    between 2 spi_transfers in a single spi_message when
-	 *    change_cs is set - 2 consecutive spi messages show a shorter
-	 *    cs disable phase increasing bus utilization
-	 *    (code reduction with a fix in spi core would be aprox.50 lines)
-	 *  * this allows the interrupt handler to start spi messages earlier
-	 *    so reducing latencies a bit and to allow for better concurrency
-	 *  * this separation - in the future - may get used to fill fifos
-	 *    early and reduce the delay on "rollover"
-	 */
-	ret = spi_async(spi, &smsg->fill_fifo.msg);
-	if (ret)
-		goto out_async_failed;
-	ret = spi_async(spi, &smsg->trigger_fifo.msg);
-	if (ret)
-		goto out_async_failed;
-
-	/* unlock the spi bus */
-	spin_unlock_irqrestore(&q->spi_lock, flags);
-
-	/* keep it for reference until the message really got transmitted */
-	can_put_echo_skb(skb, net, smsg->fifo);
-
-	return NETDEV_TX_OK;
-out_async_failed:
-	netdev_err(net, "spi_async submission of fifo %i failed - %i\n",
-		   smsg->fifo, ret);
-
-out_busy:
-	/* stop the queue */
-	mcp25xxfd_can_tx_queue_manage_nolock(cpriv, state);
-
-	spin_unlock_irqrestore(&q->spi_lock, flags);
-
-	return NETDEV_TX_BUSY;
-}
-
-/* submit the fifo back to the network stack */
-int mcp25xxfd_can_tx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo)
-{
-	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
-	struct mcp25xxfd_can_obj_tx *tx = (struct mcp25xxfd_can_obj_tx *)
-		(cpriv->sram + cpriv->fifos.info[fifo].offset);
-	int dlc = (tx->flags & MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK) >>
-		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT;
-	unsigned long flags;
-
-	/* update counters */
-	cpriv->can.dev->stats.tx_packets++;
-	cpriv->can.dev->stats.tx_bytes += can_dlc2len(dlc);
-	MCP25XXFD_DEBUGFS_INCR(cpriv->fifos.tx.dlc_usage[dlc]);
-	if (tx->flags & MCP25XXFD_CAN_OBJ_FLAGS_FDF)
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_fd_count);
-	if (tx->flags & MCP25XXFD_CAN_OBJ_FLAGS_BRS)
-		MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, tx_brs_count);
-
-	spin_lock_irqsave(&cpriv->fifos.tx_queue->lock, flags);
-
-	/* release the echo buffer */
-	can_get_echo_skb(cpriv->can.dev, fifo);
-
-	/* move from in_can_transfer to transferred */
-	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_can_transfer,
-						&q->transferred, fifo);
-
-	spin_unlock_irqrestore(&cpriv->fifos.tx_queue->lock, flags);
-
-	return 0;
-}
-
-/* interrupt handler */
-static
-int mcp25xxfd_can_tx_handle_int_txatif_fifo(struct mcp25xxfd_can_priv *cpriv,
-					    int fifo)
-{
-	struct mcp25xxfd_tx_spi_message_queue *q = cpriv->fifos.tx_queue;
-	u32 val;
-	unsigned long flags;
-	int ret;
-
-	/* read fifo status */
-	ret = mcp25xxfd_cmd_read(cpriv->priv->spi,
-				 MCP25XXFD_CAN_FIFOSTA(fifo), &val);
-	if (ret)
-		return ret;
-
-	/* clear the relevant interrupt flags */
-	ret = mcp25xxfd_cmd_write_mask(cpriv->priv->spi,
-				       MCP25XXFD_CAN_FIFOSTA(fifo), 0,
-				       MCP25XXFD_CAN_FIFOSTA_TXABT |
-				       MCP25XXFD_CAN_FIFOSTA_TXLARB |
-				       MCP25XXFD_CAN_FIFOSTA_TXERR |
-				       MCP25XXFD_CAN_FIFOSTA_TXATIF);
-	if (ret)
-		return ret;
-
-	spin_lock_irqsave(&q->lock, flags);
-	/* for specific cases we probably could trigger a retransmit
-	 * instead of an abort.
-	 */
-
-	/* and we release it from the echo_skb buffer
-	 * NOTE: this is one place where packet delivery will not
-	 * be ordered, as we do not have any timing information
-	 * when this occurred
-	 */
-	can_get_echo_skb(cpriv->can.dev, fifo);
-
-	mcp25xxfd_can_tx_queue_move_spi_message(&q->in_can_transfer,
-						&q->transferred, fifo);
-
-	spin_unlock_irqrestore(&q->lock, flags);
-
-	/* but we need to run a bit of cleanup */
-	cpriv->status.txif &= ~BIT(fifo);
-	cpriv->can.dev->stats.tx_aborted_errors++;
-
-	/* handle all the known cases accordingly - ignoring FIFO full */
-	val &= MCP25XXFD_CAN_FIFOSTA_TXABT |
-		MCP25XXFD_CAN_FIFOSTA_TXLARB |
-		MCP25XXFD_CAN_FIFOSTA_TXERR;
-	switch (val) {
-	case MCP25XXFD_CAN_FIFOSTA_TXERR:
-		/* this indicates a possible bus error */
-		break;
-	default:
-		dev_warn_ratelimited(&cpriv->priv->spi->dev,
-				     "Unknown TX-Fifo abort condition: %08x - stopping tx-queue\n",
-				     val);
-		break;
-	}
-
-	return 0;
-}
-
-int mcp25xxfd_can_tx_handle_int_txatif(struct mcp25xxfd_can_priv *cpriv)
-{
-	int i, f, ret;
-
-	/* if txatif is unset, then there are no
-	 * can frames that have been transmitted
-	 * and need to get reingested into the network stack
-	 */
-	if (!cpriv->status.txatif)
-		return 0;
-	MCP25XXFD_DEBUGFS_STATS_INCR(cpriv, int_txat_count);
-
-	/* process all the fifos with that flag set */
-	for (i = 0, f = cpriv->fifos.tx.start; i < cpriv->fifos.tx.count;
-	     i++, f++) {
-		if (cpriv->status.txatif & BIT(f)) {
-			ret = mcp25xxfd_can_tx_handle_int_txatif_fifo(cpriv, f);
-			if (ret)
-				return ret;
-		}
-	}
-
-	return 0;
-}
-
-int mcp25xxfd_can_tx_queue_alloc(struct mcp25xxfd_can_priv *cpriv)
-{
-	struct mcp25xxfd_tx_spi_message *msg;
-	size_t size = sizeof(struct mcp25xxfd_tx_spi_message_queue) +
-		cpriv->fifos.tx.count * sizeof(*msg);
-	int i, f;
-
-	/* allocate the fifos as an array */
-	cpriv->fifos.tx_queue = kzalloc(size, GFP_KERNEL);
-	if (!cpriv->fifos.tx_queue)
-		return -ENOMEM;
-
-	/* initialize the tx_queue structure */
-	spin_lock_init(&cpriv->fifos.tx_queue->lock);
-	spin_lock_init(&cpriv->fifos.tx_queue->spi_lock);
-
-	/* initialize the individual spi_message structures */
-	for (i = 0, f = cpriv->fifos.tx.start; i < cpriv->fifos.tx.count;
-	     i++, f++) {
-		msg = &cpriv->fifos.tx_queue->message[i];
-		cpriv->fifos.tx_queue->fifo2message[f] = msg;
-		mcp25xxfd_can_tx_message_init(cpriv, msg, f);
-	}
-
-	return 0;
-}
-
-void mcp25xxfd_can_tx_queue_free(struct mcp25xxfd_can_priv *cpriv)
-{
-	/* eventually we may need to wait here
-	 * for all transfers to have finished
-	 */
-
-	kfree(cpriv->fifos.tx_queue);
-	cpriv->fifos.tx_queue = NULL;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h
deleted file mode 100644
index 1947b3420d58..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_can_tx.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CAN_TX_H
-#define __MCP25XXFD_CAN_TX_H
-
-#include <linux/spinlock.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_can_priv.h"
-
-/* structure of a spi message that is prepared and can get submitted quickly */
-struct mcp25xxfd_tx_spi_message {
-	/* the network device this is related to */
-	struct mcp25xxfd_can_priv *cpriv;
-	/* the fifo this fills */
-	u32 fifo;
-	/* the xfer to fill in the fifo data */
-	struct {
-		struct spi_message msg;
-		struct spi_transfer xfer;
-		struct {
-			u8 cmd[2];
-			u8 header[sizeof(struct mcp25xxfd_can_obj_tx)];
-			u8 data[64];
-		} data;
-	} fill_fifo;
-	/* the xfer to enable transmission on the can bus */
-	struct {
-		struct spi_message msg;
-		struct spi_transfer xfer;
-		struct {
-			u8 cmd[2];
-			u8 data;
-		} data;
-	} trigger_fifo;
-};
-
-struct mcp25xxfd_tx_spi_message_queue {
-	/* spinlock protecting the bitmaps
-	 * as well as state and the skb_echo_* functions
-	 */
-	spinlock_t lock;
-	/* bitmap of which fifo is in which stage */
-	u32 idle;
-	u32 in_fill_fifo_transfer;
-	u32 in_trigger_fifo_transfer;
-	u32 in_can_transfer;
-	u32 transferred;
-
-	/* the queue state as seen per controller */
-	int state;
-#define MCP25XXFD_CAN_TX_QUEUE_STATE_STOPPED 0
-#define MCP25XXFD_CAN_TX_QUEUE_STATE_STARTED 1
-#define MCP25XXFD_CAN_TX_QUEUE_STATE_RUNABLE 2
-#define MCP25XXFD_CAN_TX_QUEUE_STATE_RESTART 3
-
-	/* spinlock protecting spi submission order */
-	spinlock_t spi_lock;
-
-	/* map each fifo to a mcp25xxfd_tx_spi_message */
-	struct mcp25xxfd_tx_spi_message *fifo2message[32];
-
-	/* the individual messages */
-	struct mcp25xxfd_tx_spi_message message[];
-};
-
-int mcp25xxfd_can_tx_submit_frame(struct mcp25xxfd_can_priv *cpriv, int fifo);
-void mcp25xxfd_can_tx_queue_restart(struct mcp25xxfd_can_priv *cpriv);
-
-int mcp25xxfd_can_tx_handle_int_txatif(struct mcp25xxfd_can_priv *cpriv);
-int mcp25xxfd_can_tx_handle_int_tefif(struct mcp25xxfd_can_priv *cpriv);
-
-netdev_tx_t mcp25xxfd_can_tx_start_xmit(struct sk_buff *skb,
-					struct net_device *net);
-
-void mcp25xxfd_can_tx_queue_manage(struct mcp25xxfd_can_priv *cpriv, int state);
-
-int mcp25xxfd_can_tx_queue_alloc(struct mcp25xxfd_can_priv *cpriv);
-void mcp25xxfd_can_tx_queue_free(struct mcp25xxfd_can_priv *cpriv);
-
-#endif /* __MCP25XXFD_CAN_TX_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c
deleted file mode 100644
index 03ba25276aa4..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.c
+++ /dev/null
@@ -1,491 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-/* Known hardware issues and workarounds in this driver:
- *
- * * There is one situation where the controller will require a full POR
- *   (total power off) to recover from a bad Clock configuration.
- *   This happens when the wrong clock is configured in the device tree
- *   (say 4MHz are configured, while 40MHz is the actual clock frequency
- *   of the HW).
- *   In such a situation the driver tries to enable the PLL, which will
- *   never synchronize and the controller becomes unresponsive to further
- *   spi requests until a full POR.
- *
- *   Mitigation:
- *     none as of now
- *
- *   Possible implementation of a mitigation/sanity check:
- *     during initialization:
- *       * try to identify the HW at 1MHz:
- *         on success:
- *           * controller is identified
- *         on failure:
- *           * controller is absent - fail
- *       * force controller clock to run with disabled PLL
- *       * try to identify the HW at 2MHz:
- *         on success:
- *           * controller clock is >= 4 MHz
- *           * this may be 4MHz
- *         on failure:
- *           * controller clock is < 4 MHz
- *       * try to identify the HW at 2.5MHz:
- *         on success:
- *           * controller clock is >= 5 MHz
- *           * this may not be 4MHz
- *         on failure:
- *           * controller clock is 4 MHz
- *           * enable PLL
- *           * exit successfully (or run last test for verification purposes)
- *       * try to identify the HW at <dt-clock/2> MHz:
- *         on success:
- *           * controller clock is >= <dt-clock/2> MHz
- *              (it could be higher though)
- *         on failure:
- *           * the controller is not running at the
- *             clock rate configured in the DT
- *           * if PLL is enabled warn about requirements of POR
- *           * fail
- *
- *   Side-effects:
- *     * longer initialization time
- *
- *   Possible issues with mitigation:
- *     * possibly miss-identification because the SPI block may work
- *       "somewhat" at frequencies > < clock / 2 + delta f>
- *       this may be especially true for the situation where we test if
- *       2.5MHz SPI-Clock works.
- *     * also SPI HW-clock dividers may do a round down to fixed frequencies
- *       which is not properly reported and may result in false positives
- *       because a frequency lower than expected is used.
- *
- *   This is the reason why only simple testing is enabled at the risk of
- *   the need for a POR.
- */
-
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/jiffies.h>
-#include <linux/kernel.h>
-#include <linux/mutex.h>
-#include <linux/of.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_can.h"
-#include "mcp25xxfd_clock.h"
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_priv.h"
-
-/* the PLL may take some time to synchronize - use 1 second as timeout */
-#define MCP25XXFD_OSC_POLLING_JIFFIES	(HZ)
-
-static u32 _mcp25xxfd_clkout_mask(struct mcp25xxfd_priv *priv)
-{
-	u32 val = 0;
-
-	if (priv->config.clock_div2)
-		val |= MCP25XXFD_OSC_SCLKDIV;
-
-	switch (priv->config.clock_odiv) {
-	case 0:
-		break;
-	case 1:
-		val |= MCP25XXFD_OSC_CLKODIV_1 << MCP25XXFD_OSC_CLKODIV_SHIFT;
-		break;
-	case 2:
-		val |= MCP25XXFD_OSC_CLKODIV_2 << MCP25XXFD_OSC_CLKODIV_SHIFT;
-		break;
-	case 4:
-		val |= MCP25XXFD_OSC_CLKODIV_4 << MCP25XXFD_OSC_CLKODIV_SHIFT;
-		break;
-	case 10:
-		val |= MCP25XXFD_OSC_CLKODIV_10 << MCP25XXFD_OSC_CLKODIV_SHIFT;
-		break;
-	default:
-		/* this should never happen but is error-handled
-		 * by the dt-parsing
-		 */
-		break;
-	}
-
-	return val;
-}
-
-static int _mcp25xxfd_waitfor_osc(struct mcp25xxfd_priv *priv,
-				  u32 waitfor, u32 mask)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* wait for synced pll/osc/sclk */
-	timeout = jiffies + MCP25XXFD_OSC_POLLING_JIFFIES;
-	while (time_before_eq(jiffies, timeout)) {
-		ret = mcp25xxfd_cmd_read(priv->spi, MCP25XXFD_OSC,
-					 &priv->regs.osc);
-		if (ret)
-			return ret;
-		/* check for expected bits to be set/unset */
-		if ((priv->regs.osc & mask) == waitfor)
-			return 0;
-	}
-
-	return -ETIMEDOUT;
-}
-
-static int _mcp25xxfd_clock_configure_osc(struct mcp25xxfd_priv *priv,
-					  u32 value, u32 waitfor, u32 mask)
-{
-	int ret;
-
-	/* write the osc value to the controller - waking it if necessary */
-	ret = mcp25xxfd_cmd_write(priv->spi, MCP25XXFD_OSC, value);
-	if (ret)
-		return ret;
-
-	/* wait for the clock to stabelize */
-	ret = _mcp25xxfd_waitfor_osc(priv, waitfor, mask);
-
-	/* on timeout try again setting the register */
-	if (ret == -ETIMEDOUT) {
-		/* write the clock to the controller */
-		ret = mcp25xxfd_cmd_write(priv->spi, MCP25XXFD_OSC, value);
-		if (ret)
-			return ret;
-
-		/* wait for the clock to stabelize */
-		ret = _mcp25xxfd_waitfor_osc(priv, waitfor, mask);
-	}
-
-	/* handle timeout special - report the fact */
-	if (ret == -ETIMEDOUT)
-		dev_err(&priv->spi->dev,
-			"Clock did not switch within the timeout period\n");
-
-	return ret;
-}
-
-static int _mcp25xxfd_clock_start(struct mcp25xxfd_priv *priv)
-{
-	u32 value = _mcp25xxfd_clkout_mask(priv);
-	u32 waitfor = MCP25XXFD_OSC_OSCRDY;
-	u32 mask = waitfor | MCP25XXFD_OSC_OSCDIS | MCP25XXFD_OSC_PLLRDY |
-		MCP25XXFD_OSC_PLLEN;
-
-	/* enable PLL as well - set expectations */
-	if (priv->config.clock_pll) {
-		value   |= MCP25XXFD_OSC_PLLEN;
-		waitfor |= MCP25XXFD_OSC_PLLRDY | MCP25XXFD_OSC_PLLEN;
-	}
-
-	/* set the oscilator now */
-	return _mcp25xxfd_clock_configure_osc(priv, value, waitfor, mask);
-}
-
-static int _mcp25xxfd_clock_stop(struct mcp25xxfd_priv *priv)
-{
-	u32 value = _mcp25xxfd_clkout_mask(priv);
-	u32 waitfor = 0;
-	u32 mask = MCP25XXFD_OSC_OSCDIS | MCP25XXFD_OSC_PLLRDY |
-		MCP25XXFD_OSC_PLLEN;
-	int ret;
-
-	ret = _mcp25xxfd_clock_configure_osc(priv, value, waitfor, mask);
-	if (ret)
-		return ret;
-
-	/* finally switch the controller mode to sleep
-	 * by this time the controller should be in config mode already
-	 * this way we wake to config mode again
-	 */
-	return mcp25xxfd_can_sleep_mode(priv);
-}
-
-int mcp25xxfd_clock_start(struct mcp25xxfd_priv *priv, int requestor_mask)
-{
-	int ret = 0;
-
-	/* without a clock there is nothing we can do... */
-	if (IS_ERR(priv->clk))
-		return PTR_ERR(priv->clk);
-
-	mutex_lock(&priv->clk_user_lock);
-
-	/* if clock is already started, then skip */
-	if (priv->clk_user_mask & requestor_mask)
-		goto out;
-
-	/* enable the clock on the host side*/
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
-		goto out;
-
-	/* enable the clock on the controller side */
-	ret = _mcp25xxfd_clock_start(priv);
-	if (ret)
-		goto out;
-
-	/* mark the clock for the specific component as started */
-	priv->clk_user_mask |= requestor_mask;
-
-	/* and now we use the normal spi speed */
-	priv->spi_use_speed_hz = priv->spi_normal_speed_hz;
-
-out:
-	mutex_unlock(&priv->clk_user_lock);
-
-	return ret;
-}
-
-int mcp25xxfd_clock_stop(struct mcp25xxfd_priv *priv, int requestor_mask)
-{
-	int ret;
-
-	/* without a clock there is nothing we can do... */
-	if (IS_ERR(priv->clk))
-		return PTR_ERR(priv->clk);
-
-	mutex_lock(&priv->clk_user_lock);
-
-	/* if the mask is empty then skip, as the clock is stopped */
-	if (!priv->clk_user_mask)
-		goto out;
-
-	/* clear the clock mask */
-	priv->clk_user_mask &= ~requestor_mask;
-
-	/* if the mask is not empty then skip, as the clock is needed */
-	if (priv->clk_user_mask)
-		goto out;
-
-	/* and now we use the setup spi speed */
-	priv->spi_use_speed_hz = priv->spi_setup_speed_hz;
-
-	/* stop the clock on the controller */
-	ret = _mcp25xxfd_clock_stop(priv);
-
-	/* and we stop the clock on the host*/
-	if (!IS_ERR(priv->clk))
-		clk_disable_unprepare(priv->clk);
-out:
-	mutex_unlock(&priv->clk_user_lock);
-
-	return 0;
-}
-
-static int _mcp25xxfd_clock_probe(struct mcp25xxfd_priv *priv)
-{
-	int ret;
-
-	/* Wait for oscillator startup timer after power up */
-	mdelay(MCP25XXFD_OST_DELAY_MS);
-
-	/* send a "blind" reset, hoping we are in Config mode */
-	mcp25xxfd_cmd_reset(priv->spi);
-
-	/* Wait for oscillator startup again */
-	mdelay(MCP25XXFD_OST_DELAY_MS);
-
-	/* check clock register that the clock is ready or disabled */
-	ret = mcp25xxfd_cmd_read_regs(priv->spi, MCP25XXFD_OSC |
-				      MCP25XXFD_ADDRESS_WITH_CRC,
-				      &priv->regs.osc,4);
-	if (ret == -EILSEQ)
-		dev_err(&priv->spi->dev,
-			"CRC read of clock register resulted in a bad CRC mismatch - hw not found\n");
-
-	if (ret)
-		return ret;
-
-	/* there can only be one... */
-	switch (priv->regs.osc &
-		(MCP25XXFD_OSC_OSCRDY | MCP25XXFD_OSC_OSCDIS)) {
-	case MCP25XXFD_OSC_OSCRDY: /* either the clock is ready */
-		break;
-	case MCP25XXFD_OSC_OSCDIS: /* or the clock is disabled */
-		break;
-	default:
-		/* otherwise there is no valid device (or in strange state)
-		 *
-		 * if PLL is enabled but not ready, then there may be
-		 * something "fishy"
-		 * this happened during driver development
-		 * (enabling pll, when when on wrong clock), so best warn
-		 * about such a possibility
-		 */
-		if ((priv->regs.osc &
-		     (MCP25XXFD_OSC_PLLEN | MCP25XXFD_OSC_PLLRDY))
-		    == MCP25XXFD_OSC_PLLEN)
-			dev_err(&priv->spi->dev,
-				"mcp25xxfd may be in a strange state - a power disconnect may be required\n");
-
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-int mcp25xxfd_clock_probe(struct mcp25xxfd_priv *priv)
-{
-	int ret;
-
-	/* this will also enable the MCP25XXFD_CLK_USER_CAN clock */
-	ret = _mcp25xxfd_clock_probe(priv);
-
-	/* on error retry a second time */
-	if (ret == -ENODEV) {
-		ret = _mcp25xxfd_clock_probe(priv);
-		if (!ret)
-			dev_info(&priv->spi->dev,
-				 "found device only during retry\n");
-	}
-	if (ret) {
-		if (ret == -ENODEV)
-			dev_err(&priv->spi->dev,
-				"Cannot initialize MCP%x. Wrong wiring? (oscilator register reads as %08x)\n",
-				priv->model, priv->regs.osc);
-	}
-
-	return ret;
-}
-
-void mcp25xxfd_clock_release(struct mcp25xxfd_priv *priv)
-{
-	if (!IS_ERR_OR_NULL(priv->clk))
-		clk_disable_unprepare(priv->clk);
-}
-
-#ifdef CONFIG_OF_DYNAMIC
-static int mcp25xxfd_clock_of_parse(struct mcp25xxfd_priv *priv)
-{
-	struct spi_device *spi = priv->spi;
-	const struct device_node *np = spi->dev.of_node;
-	u32 val;
-	int ret;
-
-	priv->config.clock_div2 = false;
-	priv->config.clock_div2 =
-		of_property_read_bool(np, "microchip,clock-div2");
-
-	priv->config.clock_odiv = 10;
-	ret = of_property_read_u32_index(np, "microchip,clock-out-div",
-					 0, &val);
-	if (!ret) {
-		switch (val) {
-		case 0:
-		case 1:
-		case 2:
-		case 4:
-		case 10:
-			priv->config.clock_odiv = val;
-			break;
-		default:
-			dev_err(&spi->dev,
-				"Invalid value in device tree for microchip,clock_out_div: %u - valid values: 0, 1, 2, 4, 10\n",
-				val);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-#else
-static int mcp25xxfd_clock_of_parse(struct mcp25xxfd_priv *priv)
-{
-	return 0;
-}
-#endif
-
-int mcp25xxfd_clock_init(struct mcp25xxfd_priv *priv)
-{
-	struct spi_device *spi = priv->spi;
-	struct clk *clk;
-	int ret, freq;
-
-	mutex_init(&priv->clk_user_lock);
-
-	priv->config.clock_div2 = false;
-	priv->config.clock_odiv = 10;
-
-	ret = mcp25xxfd_clock_of_parse(priv);
-	if (ret)
-		return ret;
-
-	/* get clock */
-	clk = devm_clk_get(&spi->dev, NULL);
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-
-	freq = clk_get_rate(clk);
-	if (freq < MCP25XXFD_MIN_CLOCK_FREQUENCY ||
-	    freq > MCP25XXFD_MAX_CLOCK_FREQUENCY) {
-		dev_err(&spi->dev,
-			"Clock frequency %i is not in range [%i:%i]\n",
-			freq,
-			MCP25XXFD_MIN_CLOCK_FREQUENCY,
-			MCP25XXFD_MAX_CLOCK_FREQUENCY);
-		return -ERANGE;
-	}
-
-	/* enable the clock and mark as enabled */
-	ret = clk_prepare_enable(clk);
-	if (ret)
-		return ret;
-	priv->clk = clk;
-
-	/* if we have a clock that is <= 4MHz, enable the pll */
-	priv->config.clock_pll =
-		(freq <= MCP25XXFD_AUTO_PLL_MAX_CLOCK_FREQUENCY);
-
-	/* decide on the effective clock rate */
-	priv->clock_freq = freq;
-	if (priv->config.clock_pll)
-		priv->clock_freq *= MCP25XXFD_PLL_MULTIPLIER;
-	if (priv->config.clock_div2)
-		priv->clock_freq /= MCP25XXFD_SCLK_DIVIDER;
-
-	/* calculate the clock frequencies to use
-	 *
-	 * setup clock speed is at most 1/4 the input clock speed
-	 * the reason for the factor of 4 is that there is
-	 * a clock divider in the controller that MAY be enabled in some
-	 * circumstances so we may find a controller with that enabled
-	 * during probe phase
-	 */
-	priv->spi_setup_speed_hz = freq / 4;
-
-	/* normal operation clock speeds */
-	priv->spi_normal_speed_hz = priv->clock_freq / 2;
-	if (priv->config.clock_div2) {
-		priv->spi_setup_speed_hz /= MCP25XXFD_SCLK_DIVIDER;
-		priv->spi_normal_speed_hz /= MCP25XXFD_SCLK_DIVIDER;
-	}
-
-	/* set limit on speed */
-	if (spi->max_speed_hz) {
-		priv->spi_setup_speed_hz = min_t(int,
-						 priv->spi_setup_speed_hz,
-						 spi->max_speed_hz);
-		priv->spi_normal_speed_hz = min_t(int,
-						  priv->spi_normal_speed_hz,
-						  spi->max_speed_hz);
-	}
-
-	/* use setup speed by default
-	 * - this is switched when clock is enabled/disabled
-	 */
-	priv->spi_use_speed_hz = priv->spi_setup_speed_hz;
-
-	return 0;
-}
-
-void mcp25xxfd_clock_fake_sleep(struct mcp25xxfd_priv *priv)
-{
-	priv->regs.osc &= ~(MCP25XXFD_OSC_OSCRDY |
-			    MCP25XXFD_OSC_PLLRDY |
-			    MCP25XXFD_OSC_SCLKRDY);
-	priv->regs.osc |= MCP25XXFD_OSC_OSCDIS;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h
deleted file mode 100644
index 049e95cfa9ad..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_clock.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CLOCK_H
-#define __MCP25XXFD_CLOCK_H
-
-#include "mcp25xxfd_priv.h"
-
-#define MCP25XXFD_CLK_USER_CAN BIT(0)
-#define MCP25XXFD_CLK_USER_GPIO0 BIT(1)
-#define MCP25XXFD_CLK_USER_GPIO1 BIT(2)
-#define MCP25XXFD_CLK_USER_CLKOUT BIT(3)
-
-/* shared (internal) clock control */
-int mcp25xxfd_clock_init(struct mcp25xxfd_priv *priv);
-int mcp25xxfd_clock_probe(struct mcp25xxfd_priv *priv);
-void mcp25xxfd_clock_release(struct mcp25xxfd_priv *priv);
-
-int mcp25xxfd_clock_stop(struct mcp25xxfd_priv *priv, int requestor_mask);
-int mcp25xxfd_clock_start(struct mcp25xxfd_priv *priv, int requestor_mask);
-
-void mcp25xxfd_clock_fake_sleep(struct mcp25xxfd_priv *priv);
-
-#endif /* __MCP25XXFD_CLOCK_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c
deleted file mode 100644
index 6d895613111e..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.c
+++ /dev/null
@@ -1,401 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_crc.h"
-#include "mcp25xxfd_priv.h"
-
-/* module parameter */
-static bool use_spi_crc;
-module_param(use_spi_crc, bool, 0664);
-MODULE_PARM_DESC(use_spi_crc, "Use SPI CRC instruction\n");
-
-/* SPI helper */
-
-/* wrapper arround spi_sync, that sets speed_hz */
-static int mcp25xxfd_cmd_sync_transfer(struct spi_device *spi,
-				       struct spi_transfer *xfer,
-				       unsigned int xfers)
-{
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	int i;
-
-	for (i = 0; i < xfers; i++)
-		xfer[i].speed_hz = priv->spi_use_speed_hz;
-
-	return spi_sync_transfer(spi, xfer, xfers);
-}
-
-/* simple spi_write wrapper with speed_hz
- * WARINING: tx_buf needs to be on heap!
- */
-static int mcp25xxfd_cmd_sync_write(struct spi_device *spi,
-				    const void *tx_buf,
-				    unsigned int tx_len)
-{
-	struct spi_transfer xfer;
-
-	memset(&xfer, 0, sizeof(xfer));
-	xfer.tx_buf = tx_buf;
-	xfer.len = tx_len;
-
-	return mcp25xxfd_cmd_sync_transfer(spi, &xfer, 1);
-}
-
-/* alloc buffer */
-static int mcp25xxfd_cmd_alloc_buf(struct spi_device *spi,
-				   size_t len,
-				   u8 **tx, u8 **rx)
-{
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-
-	/* allocate from heap in case the size is to big
-	 * or the preallocated buffer is already used (i.e locked)
-	 */
-	if (len > sizeof(priv->spi_tx) ||
-	    !mutex_trylock(&priv->spi_rxtx_lock)) {
-		/* allocate tx+rx in one allocation if rx is requested */
-		*tx = kzalloc(rx ? 2 * len : len, GFP_KERNEL);
-		if (!*tx)
-			return -ENOMEM;
-		if (rx)
-			*rx = *tx + len;
-	} else {
-		/* use the preallocated buffers instead */
-		*tx = priv->spi_tx;
-		memset(priv->spi_tx, 0, sizeof(priv->spi_tx));
-		if (rx) {
-			*rx = priv->spi_rx;
-			memset(priv->spi_rx, 0, sizeof(priv->spi_rx));
-		}
-	}
-
-	return 0;
-}
-
-static void mcp25xxfd_cmd_release_buf(struct spi_device *spi, u8 *tx, u8 *rx)
-{
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-
-	if (tx == priv->spi_tx)
-		mutex_unlock(&priv->spi_rxtx_lock);
-	else
-		kfree(tx);
-}
-
-/* an optimization of spi_write_then_read that merges the transfers
- * this also makes sure that the data is ALWAYS on heap
- */
-static int mcp25xxfd_cmd_write_then_read(struct spi_device *spi,
-					 const void *tx_buf,
-					 unsigned int tx_len,
-					 void *rx_buf,
-					 unsigned int rx_len,
-					 void *crc_buf)
-{
-	int crc_len = crc_buf ? 2 : 0;
-	struct spi_transfer xfer[2];
-	u8 *spi_tx, *spi_rx;
-	int xfers;
-	int ret;
-
-	/* get pointer to buffers */
-	ret = mcp25xxfd_cmd_alloc_buf(spi, tx_len + rx_len + crc_len,
-				      &spi_tx, &spi_rx);
-	if (ret)
-		return ret;
-
-	/* clear the xfers */
-	memset(xfer, 0, sizeof(xfer));
-
-	/* special handling for half-duplex */
-	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX) {
-		xfers = 2;
-		xfer[0].tx_buf = spi_tx;
-		xfer[0].len = tx_len;
-		/* the offset for rx_buf needs to get aligned */
-		xfer[1].rx_buf = spi_rx + tx_len;
-		xfer[1].len = rx_len + crc_len;
-	} else {
-		xfers = 1;
-		xfer[0].len = tx_len + rx_len + crc_len;
-		xfer[0].tx_buf = spi_tx;
-		xfer[0].rx_buf = spi_rx;
-	}
-
-	/* copy data - especially to avoid buffers from stack */
-	memcpy(spi_tx, tx_buf, tx_len);
-
-	/* do the transfer */
-	ret = mcp25xxfd_cmd_sync_transfer(spi, xfer, xfers);
-	if (ret)
-		goto out;
-
-	/* copy result back */
-	memcpy(rx_buf, xfer[0].rx_buf + tx_len, rx_len);
-	if (crc_buf)
-		memcpy(crc_buf, xfer[0].rx_buf + tx_len + rx_len, crc_len);
-
-out:
-	mcp25xxfd_cmd_release_buf(spi, spi_tx, spi_rx);
-
-	return ret;
-}
-
-static int mcp25xxfd_cmd_write_then_write(struct spi_device *spi,
-					  const void *tx_buf,
-					  unsigned int tx_len,
-					  const void *tx2_buf,
-					  unsigned int tx2_len)
-{
-	struct spi_transfer xfer;
-	u8 *spi_tx;
-	int ret;
-
-	/* get pointer to buffers */
-	ret = mcp25xxfd_cmd_alloc_buf(spi, tx_len + tx2_len, &spi_tx, NULL);
-	if (ret)
-		return ret;
-
-	/* setup xfer */
-	memset(&xfer, 0, sizeof(xfer));
-	xfer.len = tx_len + tx2_len;
-	xfer.tx_buf = spi_tx;
-
-	/* copy data to correct location in buffer */
-	memcpy(spi_tx, tx_buf, tx_len);
-	memcpy(spi_tx + tx_len, tx2_buf, tx2_len);
-
-	/* run the transfer */
-	ret = mcp25xxfd_cmd_sync_transfer(spi, &xfer, 1);
-
-	mcp25xxfd_cmd_release_buf(spi, spi_tx, NULL);
-
-	return ret;
-}
-
-/* mcp25xxfd spi command/protocol helper */
-
-/* read multiple bytes, transform some registers */
-int mcp25xxfd_cmd_readn(struct spi_device *spi, u32 reg,
-			void *data, int n)
-{
-	u8 cmd[2];
-	int ret;
-
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_READ, reg, cmd);
-
-	ret = mcp25xxfd_cmd_write_then_read(spi, &cmd, 2, data, n, NULL);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static u16 _mcp25xxfd_cmd_compute_crc(u8 *cmd, u8 *data, int n)
-{
-	u16 crc = 0xffff;
-
-	crc = mcp25xxfd_crc(crc, cmd, 3);
-	crc = mcp25xxfd_crc(crc, data, n);
-
-	return crc;
-}
-
-static int _mcp25xxfd_cmd_readn_crc(struct spi_device *spi, u32 reg,
-				    void *data, int n)
-{
-	u8 cmd[3], crcd[2];
-	u16 crcc, crcr;
-	int ret;
-
-	/* prepare command */
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_READ_CRC, reg, cmd);
-	/* count depends on word (=RAM) or byte access (Registers) */
-	if (reg < MCP25XXFD_SRAM_ADDR(0) ||
-	    reg >= MCP25XXFD_SRAM_ADDR(MCP25XXFD_SRAM_SIZE))
-		cmd[2] = n;
-	else
-		cmd[2] = n / 4;
-
-	/* now read for real */
-	ret = mcp25xxfd_cmd_write_then_read(spi, &cmd, 3, data, n, crcd);
-	if (ret)
-		return ret;
-
-	/* the received crc */
-	crcr = (crcd[0] << 8) + crcd[1];
-
-	/* compute the crc */
-	crcc = _mcp25xxfd_cmd_compute_crc(cmd, data, n);
-
-	/* if it matches, then return */
-	if (crcc == crcr)
-		return 0;
-
-	/* here possibly handle crc variants with a single bit7 flips */
-
-	/* return with error and rate limited */
-	dev_err_ratelimited(&spi->dev,
-			    "CRC read error: computed: %04x received: %04x - data: %*ph %*ph%s\n",
-			    crcc, crcr, 3, cmd, min_t(int, 64, n), data,
-			    (n > 64) ? "..." : "");
-	return -EILSEQ;
-}
-
-static int mcp25xxfd_cmd_readn_crc(struct spi_device *spi, u32 reg,
-				   void *data, int n)
-{
-	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
-	int ret;
-
-	for (; n > 0; n -= 254, reg += 254, data += 254) {
-#if defined(CONFIG_DEBUG_FS)
-		priv->stats.spi_crc_read++;
-		if (n > 254)
-			priv->stats.spi_crc_read_split++;
-#endif
-		ret = _mcp25xxfd_cmd_readn_crc(spi, reg, data, n);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-/* read a register, but we are only interrested in a few bytes */
-int mcp25xxfd_cmd_read_mask(struct spi_device *spi, u32 reg,
-			    u32 *data, u32 mask)
-{
-	int first_byte, last_byte, len_byte;
-	int ret;
-
-	/* check that at least one bit is set */
-	if (!mask)
-		return -EINVAL;
-
-	/* calculate first and last byte used */
-	first_byte = mcp25xxfd_cmd_first_byte(mask);
-	last_byte = mcp25xxfd_cmd_last_byte(mask);
-	len_byte = last_byte - first_byte + 1;
-
-	mcp25xxfd_cmd_convert_from_cpu(data, 1);
-
-	/* do a partial read */
-	ret = mcp25xxfd_cmd_readn(spi, reg + first_byte,
-				  ((void *)data + first_byte), len_byte);
-	if (ret)
-		return ret;
-
-	mcp25xxfd_cmd_convert_to_cpu(data, 1);
-
-	return 0;
-}
-
-int mcp25xxfd_cmd_writen(struct spi_device *spi, u32 reg,
-			 void *data, int n)
-{
-	u8 cmd[2];
-	int ret;
-
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE, reg, cmd);
-
-	ret = mcp25xxfd_cmd_write_then_write(spi, &cmd, 2, data, n);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/* read a register, but we are only interrested in a few bytes */
-int mcp25xxfd_cmd_write_mask(struct spi_device *spi, u32 reg,
-			     u32 data, u32 mask)
-{
-	int first_byte, last_byte, len_byte;
-	u8 cmd[2];
-
-	/* check that at least one bit is set */
-	if (!mask)
-		return -EINVAL;
-
-	/* calculate first and last byte used */
-	first_byte = mcp25xxfd_cmd_first_byte(mask);
-	last_byte = mcp25xxfd_cmd_last_byte(mask);
-	len_byte = last_byte - first_byte + 1;
-
-	/* prepare buffer */
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_WRITE,
-			   reg + first_byte, cmd);
-
-	mcp25xxfd_cmd_convert_from_cpu(&data, 1);
-
-	return mcp25xxfd_cmd_write_then_write(spi,
-					      cmd, sizeof(cmd),
-					      ((void *)&data + first_byte),
-					      len_byte);
-}
-
-int mcp25xxfd_cmd_write_regs(struct spi_device *spi, u32 reg,
-			     u32 *data, u32 bytes)
-{
-	int ret;
-
-	/* first transpose to controller format */
-	mcp25xxfd_cmd_convert_from_cpu(data, bytes / sizeof(bytes));
-
-	/* now write it */
-	ret = mcp25xxfd_cmd_writen(spi, reg, data, bytes);
-
-	/* and convert it back to cpu format even if it fails */
-	mcp25xxfd_cmd_convert_to_cpu(data, bytes / sizeof(bytes));
-
-	return ret;
-}
-
-int mcp25xxfd_cmd_read_regs(struct spi_device *spi, u32 reg,
-			    u32 *data, u32 bytes)
-{
-	int ret;
-
-	/* read it using crc */
-	if ((use_spi_crc) || (reg & MCP25XXFD_ADDRESS_WITH_CRC))
-		ret = mcp25xxfd_cmd_readn_crc(spi,
-					      reg & MCP25XXFD_ADDRESS_MASK,
-					      data, bytes);
-	else
-		ret = mcp25xxfd_cmd_readn(spi, reg, data, bytes);
-
-	/* and convert it to cpu format */
-	mcp25xxfd_cmd_convert_to_cpu((u32 *)data, bytes / sizeof(bytes));
-
-	return ret;
-}
-
-int mcp25xxfd_cmd_reset(struct spi_device *spi)
-{
-	u8 *cmd;
-	int ret;
-
-	/* allocate 2 bytes on heap, as we use sync_write */
-	cmd = kzalloc(2, GFP_KERNEL);
-	if (!cmd)
-		return -ENOMEM;
-
-	mcp25xxfd_cmd_calc(MCP25XXFD_INSTRUCTION_RESET, 0, cmd);
-
-	/* write the reset command */
-	ret = mcp25xxfd_cmd_sync_write(spi, cmd, 2);
-
-	kfree(cmd);
-
-	return ret;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h
deleted file mode 100644
index 595b85294452..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_cmd.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_CMD_H
-#define __MCP25XXFD_CMD_H
-
-#include <linux/byteorder/generic.h>
-#include <linux/spi/spi.h>
-
-/* SPI commands */
-#define MCP25XXFD_INSTRUCTION_RESET		0x0000
-#define MCP25XXFD_INSTRUCTION_READ		0x3000
-#define MCP25XXFD_INSTRUCTION_WRITE		0x2000
-#define MCP25XXFD_INSTRUCTION_READ_CRC		0xB000
-#define MCP25XXFD_INSTRUCTION_WRITE_CRC		0xA000
-#define MCP25XXFD_INSTRUCTION_WRITE_SAVE	0xC000
-
-#define MCP25XXFD_ADDRESS_MASK			0x0fff
-/* a bit to use CRC commands if possible */
-#define MCP25XXFD_ADDRESS_WITH_CRC		BIT(31)
-
-static inline void mcp25xxfd_cmd_convert_to_cpu(u32 *data, int n)
-{
-	le32_to_cpu_array(data, n);
-}
-
-static inline void mcp25xxfd_cmd_convert_from_cpu(u32 *data, int n)
-{
-	cpu_to_le32_array(data, n);
-}
-
-static inline void mcp25xxfd_cmd_calc(u16 cmd, u16 addr, u8 *data)
-{
-	cmd = cmd | (addr & MCP25XXFD_ADDRESS_MASK);
-
-	data[0] = (cmd >> 8) & 0xff;
-	data[1] = (cmd >> 0) & 0xff;
-}
-
-static inline int mcp25xxfd_cmd_first_byte(u32 mask)
-{
-	return (mask & 0x0000ffff) ?
-		((mask & 0x000000ff) ? 0 : 1) :
-		((mask & 0x00ff0000) ? 2 : 3);
-}
-
-static inline int mcp25xxfd_cmd_last_byte(u32 mask)
-{
-	return (mask & 0xffff0000) ?
-		((mask & 0xff000000) ? 3 : 2) :
-		((mask & 0x0000ff00) ? 1 : 0);
-}
-
-int mcp25xxfd_cmd_readn(struct spi_device *spi, u32 reg,
-			void *data, int n);
-int mcp25xxfd_cmd_read_mask(struct spi_device *spi, u32 reg,
-			    u32 *data, u32 mask);
-static inline int mcp25xxfd_cmd_read(struct spi_device *spi, u32 reg,
-				     u32 *data)
-{
-	return mcp25xxfd_cmd_read_mask(spi, reg, data, -1);
-}
-
-int mcp25xxfd_cmd_read_regs(struct spi_device *spi, u32 reg,
-			    u32 *data, u32 bytes);
-
-int mcp25xxfd_cmd_writen(struct spi_device *spi, u32 reg,
-			 void *data, int n);
-int mcp25xxfd_cmd_write_mask(struct spi_device *spi, u32 reg,
-			     u32 data, u32 mask);
-static inline int mcp25xxfd_cmd_write(struct spi_device *spi, u32 reg,
-				      u32 data)
-{
-	return mcp25xxfd_cmd_write_mask(spi, reg, data, -1);
-}
-
-int mcp25xxfd_cmd_write_regs(struct spi_device *spi, u32 reg,
-			     u32 *data, u32 bytes);
-
-int mcp25xxfd_cmd_reset(struct spi_device *spi);
-
-#endif /* __MCP25XXFD_CMD_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h
deleted file mode 100644
index 25db96b0b9c9..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_crc.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_CRC_H
-#define __MCP25XXFD_CRC_H
-
-#include "mcp25xxfd_priv.h"
-
-int mcp25xxfd_crc_enable_int(struct mcp25xxfd_priv *priv, bool enable);
-int mcp25xxfd_crc_clear_int(struct mcp25xxfd_priv *priv);
-
-u16 mcp25xxfd_crc(u16 crc, u8 const *buffer, size_t len);
-
-#endif /* __MCP25XXFD_CRC_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c
deleted file mode 100644
index 303bcba27919..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.c
+++ /dev/null
@@ -1,116 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifdef CONFIG_DEBUG_FS
-
-#include <linux/debugfs.h>
-#include <linux/kernel.h>
-#include <linux/seq_file.h>
-
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_debugfs.h"
-#include "mcp25xxfd_priv.h"
-
-static int mcp25xxfd_debugfs_dump_regs_range(struct seq_file *file,
-					     u32 start, u32 end)
-{
-	struct spi_device *spi = file->private;
-	u32 data[32];
-	int bytes = end - start + sizeof(*data);
-	int i, l, count, ret;
-
-	for (count =  bytes / sizeof(*data); count > 0; count -= 32) {
-		/* read up to 32 registers in one go */
-		l = min(count, 32);
-		ret = mcp25xxfd_cmd_read_regs(spi, start,
-					      data, l * sizeof(*data));
-		if (ret)
-			return ret;
-		/* dump those read registers */
-		for (i = 0; i < l; i++, start += sizeof(*data))
-			seq_printf(file, "Reg 0x%03x = 0x%08x\n",
-				   start, data[i]);
-	}
-
-	return 0;
-}
-
-static int mcp25xxfd_debugfs_dump_regs(struct seq_file *file, void *offset)
-{
-	return mcp25xxfd_debugfs_dump_regs_range(file, MCP25XXFD_OSC,
-						 MCP25XXFD_DEVID);
-}
-
-static int mcp25xxfd_debugfs_dump_can_regs(struct seq_file *file,
-					   void *offset)
-{
-	return mcp25xxfd_debugfs_dump_regs_range(file, MCP25XXFD_CAN_CON,
-						 MCP25XXFD_CAN_TXQUA);
-}
-
-static int mcp25xxfd_debugfs_dump_can_all_regs(struct seq_file *file,
-					       void *offset)
-{
-	return mcp25xxfd_debugfs_dump_regs_range(file, MCP25XXFD_CAN_CON,
-						 MCP25XXFD_CAN_FLTMASK(31));
-}
-
-static void mcp25xxfd_debugfs_mod_setup(struct mcp25xxfd_priv *priv)
-{
-	struct dentry *root, *regs;
-
-	/* the base directory */
-	priv->debugfs_dir = debugfs_create_dir(priv->device_name, NULL);
-	root = priv->debugfs_dir;
-
-	/* expose some parameters related to clocks */
-	debugfs_create_u32("spi_setup_speed_hz", 0644, root,
-			   &priv->spi_setup_speed_hz);
-	debugfs_create_u32("spi_normal_speed_hz", 0644, root,
-			   &priv->spi_normal_speed_hz);
-	debugfs_create_u32("spi_use_speed_hz", 0644, root,
-			   &priv->spi_use_speed_hz);
-	debugfs_create_u32("clk_user_mask", 0444, root, &priv->clk_user_mask);
-
-	/* some statistics */
-	debugfs_create_u64("spi_crc_read", 0444, root,
-			   &priv->stats.spi_crc_read);
-	debugfs_create_u64("spi_crc_read_split", 0444, root,
-			   &priv->stats.spi_crc_read_split);
-
-	/* expose the system registers */
-	priv->debugfs_regs_dir = debugfs_create_dir("regs", root);
-	regs = priv->debugfs_regs_dir;
-	debugfs_create_x32("osc", 0444, regs, &priv->regs.osc);
-	debugfs_create_x32("iocon", 0444, regs, &priv->regs.iocon);
-	debugfs_create_x32("crc", 0444, regs, &priv->regs.crc);
-	debugfs_create_x32("ecccon", 0444, regs, &priv->regs.ecccon);
-
-	/* dump the controller registers themselves */
-	debugfs_create_devm_seqfile(&priv->spi->dev, "regs_live_dump",
-				    root, mcp25xxfd_debugfs_dump_regs);
-	/* and the essential can registers */
-	debugfs_create_devm_seqfile(&priv->spi->dev, "can_regs_live_dump",
-				    root, mcp25xxfd_debugfs_dump_can_regs);
-	/* and the complete can registers */
-	debugfs_create_devm_seqfile(&priv->spi->dev,
-				    "can_regs_all_live_dump", root,
-				    mcp25xxfd_debugfs_dump_can_all_regs);
-}
-
-void mcp25xxfd_debugfs_setup(struct mcp25xxfd_priv *priv)
-{
-	mcp25xxfd_debugfs_mod_setup(priv);
-}
-
-void mcp25xxfd_debugfs_remove(struct mcp25xxfd_priv *priv)
-{
-	debugfs_remove_recursive(priv->debugfs_dir);
-	priv->debugfs_dir = NULL;
-}
-
-#endif /* CONFIG_DEBUG_FS */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h
deleted file mode 100644
index 800672442ffb..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_debugfs.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_DEBUGFS_H
-#define __MCP25XXFD_DEBUGFS_H
-
-#include "mcp25xxfd_priv.h"
-
-#ifdef CONFIG_DEBUG_FS
-
-void mcp25xxfd_debugfs_setup(struct mcp25xxfd_priv *priv);
-void mcp25xxfd_debugfs_remove(struct mcp25xxfd_priv *priv);
-
-#else
-
-static inline void mcp25xxfd_debugfs_setup(struct mcp25xxfd_priv *priv)
-{
-	return 0;
-}
-
-static inline void mcp25xxfd_debugfs_remove(struct mcp25xxfd_priv *priv)
-{
-}
-
-#endif /* CONFIG_DEBUG_FS */
-#endif /* __MCP25XXFD_DEBUGFS_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c
deleted file mode 100644
index 526f345d0a17..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.c
+++ /dev/null
@@ -1,75 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#include <linux/kernel.h>
-#include <linux/spi/spi.h>
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_ecc.h"
-#include "mcp25xxfd_priv.h"
-#include "mcp25xxfd_regs.h"
-
-int mcp25xxfd_ecc_clear_int(struct mcp25xxfd_priv *priv)
-{
-	u32 val, addr;
-	int ret;
-
-	/* first report the error address */
-	ret = mcp25xxfd_cmd_read(priv->spi, MCP25XXFD_ECCSTAT, &val);
-	if (ret)
-		return ret;
-
-	/* if no flags are set then nothing to do */
-	if (!(val & (MCP25XXFD_ECCSTAT_SECIF | MCP25XXFD_ECCSTAT_DEDIF)))
-		return 0;
-
-	addr = (val & MCP25XXFD_ECCSTAT_ERRADDR_MASK) >>
-		MCP25XXFD_ECCSTAT_ERRADDR_SHIFT;
-
-	dev_err_ratelimited(&priv->spi->dev, "ECC %s bit error at %03x\n",
-			    (val & MCP25XXFD_ECCSTAT_DEDIF) ?
-			    "double" : "single",
-			    addr);
-
-	/* and clear the error */
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_ECCSTAT, 0,
-					MCP25XXFD_ECCSTAT_SECIF |
-					MCP25XXFD_ECCSTAT_DEDIF);
-}
-
-int mcp25xxfd_ecc_enable_int(struct mcp25xxfd_priv *priv, bool enable)
-{
-	u32 mask = MCP25XXFD_ECCCON_SECIE | MCP25XXFD_ECCCON_DEDIE;
-
-	priv->regs.ecccon &= ~mask;
-	priv->regs.ecccon |= MCP25XXFD_ECCCON_ECCEN | (enable ? mask : 0);
-
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_ECCCON,
-					priv->regs.ecccon,
-					MCP25XXFD_ECCCON_ECCEN | mask);
-}
-
-int mcp25xxfd_ecc_enable(struct mcp25xxfd_priv *priv)
-{
-	u8 buffer[256];
-	int i, ret;
-
-	/* set up RAM ECC - enable interrupts sets it as well */
-	ret = mcp25xxfd_ecc_enable_int(priv, false);
-	if (ret)
-		return ret;
-
-	/* and clear SRAM so that no reads fails from now on */
-	memset(buffer, 0, sizeof(buffer));
-	for (i = 0; i < MCP25XXFD_SRAM_SIZE; i += sizeof(buffer)) {
-		ret = mcp25xxfd_cmd_writen(priv->spi, MCP25XXFD_SRAM_ADDR(i),
-					   buffer, sizeof(buffer));
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h
deleted file mode 100644
index 117f58c65a46..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_ecc.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_ECC_H
-#define __MCP25XXFD_ECC_H
-
-#include "mcp25xxfd_priv.h"
-
-int mcp25xxfd_ecc_clear_int(struct mcp25xxfd_priv *priv);
-int mcp25xxfd_ecc_enable_int(struct mcp25xxfd_priv *priv, bool enable);
-int mcp25xxfd_ecc_enable(struct mcp25xxfd_priv *priv);
-
-#endif /* __MCP25XXFD_ECC_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c
deleted file mode 100644
index 60dc9f98d892..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.c
+++ /dev/null
@@ -1,255 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- *
- * Based on Microchip MCP251x CAN controller driver written by
- * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
- */
-
-#include <linux/gpio/driver.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-
-#include "mcp25xxfd_clock.h"
-#include "mcp25xxfd_cmd.h"
-#include "mcp25xxfd_gpio.h"
-#include "mcp25xxfd_priv.h"
-
-/* GPIO component */
-#ifdef CONFIG_GPIOLIB
-
-enum mcp25xxfd_gpio_pins {
-	MCP25XXFD_GPIO_GPIO0 = 0,
-	MCP25XXFD_GPIO_GPIO1 = 1,
-};
-
-static int mcp25xxfd_gpio_request(struct gpio_chip *chip,
-				  unsigned int offset)
-{
-	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
-	int clock_requestor = offset ?
-		MCP25XXFD_CLK_USER_GPIO1 : MCP25XXFD_CLK_USER_GPIO0;
-
-	/* only handle gpio 0/1 */
-	if (offset > 1)
-		return -EINVAL;
-
-	/* if we have XSTANDBY enabled then gpio0 is not available either */
-	if (priv->config.gpio0_xstandby && offset == 0)
-		return -EINVAL;
-
-	mcp25xxfd_clock_start(priv, clock_requestor);
-
-	return 0;
-}
-
-static void mcp25xxfd_gpio_free(struct gpio_chip *chip,
-				unsigned int offset)
-{
-	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
-	int clock_requestor = offset ?
-		MCP25XXFD_CLK_USER_GPIO1 : MCP25XXFD_CLK_USER_GPIO0;
-
-	/* only handle gpio 0/1 */
-	if (offset > 1)
-		return;
-
-	mcp25xxfd_clock_stop(priv, clock_requestor);
-}
-
-static int mcp25xxfd_gpio_get(struct gpio_chip *chip, unsigned int offset)
-{
-	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
-	u32 mask = (offset) ? MCP25XXFD_IOCON_GPIO1 : MCP25XXFD_IOCON_GPIO0;
-	int ret;
-
-	/* only handle gpio 0/1 */
-	if (offset > 1)
-		return -EINVAL;
-
-	/* read the relevant gpio Latch */
-	ret = mcp25xxfd_cmd_read_mask(priv->spi, MCP25XXFD_IOCON,
-				      &priv->regs.iocon, mask);
-	if (ret)
-		return ret;
-
-	/* return the match */
-	return priv->regs.iocon & mask;
-}
-
-static void mcp25xxfd_gpio_set(struct gpio_chip *chip, unsigned int offset,
-			       int value)
-{
-	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
-	u32 mask = (offset) ? MCP25XXFD_IOCON_LAT1 : MCP25XXFD_IOCON_LAT0;
-
-	/* only handle gpio 0/1 */
-	if (offset > 1)
-		return;
-
-	/* update in memory representation with the corresponding value */
-	if (value)
-		priv->regs.iocon |= mask;
-	else
-		priv->regs.iocon &= ~mask;
-
-	mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_IOCON,
-				 priv->regs.iocon, mask);
-}
-
-static int mcp25xxfd_gpio_direction_input(struct gpio_chip *chip,
-					  unsigned int offset)
-{
-	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
-	u32 mask_tri = (offset) ?
-		MCP25XXFD_IOCON_TRIS1 : MCP25XXFD_IOCON_TRIS0;
-	u32 mask_stby = (offset) ?
-		0 : MCP25XXFD_IOCON_XSTBYEN;
-	u32 mask_pm = (offset) ?
-		MCP25XXFD_IOCON_PM1 : MCP25XXFD_IOCON_PM0;
-
-	/* only handle gpio 0/1 */
-	if (offset > 1)
-		return -EINVAL;
-
-	/* set the mask */
-	priv->regs.iocon |= mask_tri | mask_pm;
-
-	/* clear stby */
-	priv->regs.iocon &= ~mask_stby;
-
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_IOCON,
-					priv->regs.iocon,
-					mask_tri | mask_stby | mask_pm);
-}
-
-static int mcp25xxfd_gpio_direction_output(struct gpio_chip *chip,
-					   unsigned int offset, int value)
-{
-	struct mcp25xxfd_priv *priv = gpiochip_get_data(chip);
-	u32 mask_tri = (offset) ?
-		MCP25XXFD_IOCON_TRIS1 : MCP25XXFD_IOCON_TRIS0;
-	u32 mask_lat = (offset) ?
-		MCP25XXFD_IOCON_LAT1 : MCP25XXFD_IOCON_LAT0;
-	u32 mask_pm = (offset) ?
-		MCP25XXFD_IOCON_PM1 : MCP25XXFD_IOCON_PM0;
-	u32 mask_stby = (offset) ?
-		0 : MCP25XXFD_IOCON_XSTBYEN;
-
-	/* only handle gpio 0/1 */
-	if (offset > 1)
-		return -EINVAL;
-
-	/* clear the tristate bit and also clear stby */
-	priv->regs.iocon &= ~(mask_tri | mask_stby);
-
-	/* set GPIO mode */
-	priv->regs.iocon |= mask_pm;
-
-	/* set the value */
-	if (value)
-		priv->regs.iocon |= mask_lat;
-	else
-		priv->regs.iocon &= ~mask_lat;
-
-	return mcp25xxfd_cmd_write_mask(priv->spi, MCP25XXFD_IOCON,
-					priv->regs.iocon,
-					mask_tri | mask_lat |
-					mask_pm | mask_stby);
-}
-
-#ifdef CONFIG_OF_DYNAMIC
-static void mcp25xxfd_gpio_read_of(struct mcp25xxfd_priv *priv)
-{
-	const struct device_node *np = priv->spi->dev.of_node;
-
-	priv->config.gpio_open_drain =
-		of_property_read_bool(np, "microchip,gpio-open-drain");
-	priv->config.gpio0_xstandby =
-		of_property_read_bool(np, "microchip,gpio0-xstandby");
-}
-#else
-static void mcp25xxfd_gpio_read_of(struct mcp25xxfd_priv *priv)
-{
-	priv->config.gpio_open_drain = false;
-	priv->config.gpio0_xstandby = false;
-}
-#endif
-
-static int mcp25xxfd_gpio_setup_regs(struct mcp25xxfd_priv *priv)
-{
-	/* handle open-drain */
-	if (priv->config.gpio_open_drain) {
-		priv->regs.iocon |= MCP25XXFD_IOCON_INTOD;
-	} else {
-		priv->regs.iocon &= ~MCP25XXFD_IOCON_INTOD;
-	}
-
-	/* handle xstandby */
-	if (priv->config.gpio0_xstandby) {
-		priv->regs.iocon &= ~(MCP25XXFD_IOCON_TRIS0 |
-				      MCP25XXFD_IOCON_GPIO0);
-		priv->regs.iocon |= MCP25XXFD_IOCON_XSTBYEN;
-	} else {
-		priv->regs.iocon &= ~(MCP25XXFD_IOCON_XSTBYEN);
-	}
-
-	/* update the iocon register */
-	return mcp25xxfd_cmd_write_regs(priv->spi, MCP25XXFD_IOCON,
-					&priv->regs.iocon, sizeof(u32));
-}
-
-static int mcp25xxfd_gpio_setup_gpiochip(struct mcp25xxfd_priv *priv)
-{
-	struct gpio_chip *gpio = &priv->gpio;
-
-	/* gpiochip only handles GPIO0 and GPIO1 */
-	gpio->owner                = THIS_MODULE;
-	gpio->parent               = &priv->spi->dev;
-	gpio->label                = dev_name(&priv->spi->dev);
-	gpio->direction_input      = mcp25xxfd_gpio_direction_input;
-	gpio->get                  = mcp25xxfd_gpio_get;
-	gpio->direction_output     = mcp25xxfd_gpio_direction_output;
-	gpio->set                  = mcp25xxfd_gpio_set;
-	gpio->request              = mcp25xxfd_gpio_request;
-	gpio->free                 = mcp25xxfd_gpio_free;
-	gpio->base                 = -1;
-	gpio->ngpio                = 2;
-	gpio->can_sleep            = 1;
-
-	return gpiochip_add_data(gpio, priv);
-}
-
-int mcp25xxfd_gpio_setup(struct mcp25xxfd_priv *priv)
-{
-	int ret;
-
-	/* setting up defaults */
-	priv->config.gpio0_xstandby = false;
-
-	mcp25xxfd_gpio_read_of(priv);
-	ret = mcp25xxfd_gpio_setup_regs(priv);
-	if (ret)
-		return ret;
-
-	return mcp25xxfd_gpio_setup_gpiochip(priv);
-}
-
-void mcp25xxfd_gpio_remove(struct mcp25xxfd_priv *priv)
-{
-	gpiochip_remove(&priv->gpio);
-}
-
-#else
-int mcp25xxfd_gpio_setup(struct mcp25xxfd_priv *priv)
-{
-	return 0;
-}
-
-void mcp25xxfd_gpio_remove(struct mcp25xxfd_priv *priv)
-{
-}
-#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h
deleted file mode 100644
index 46740e8abc45..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_gpio.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_GPIO_H
-#define __MCP25XXFD_GPIO_H
-
-#include "mcp25xxfd_priv.h"
-
-/* gpiolib support */
-int mcp25xxfd_gpio_setup(struct mcp25xxfd_priv *priv);
-void mcp25xxfd_gpio_remove(struct mcp25xxfd_priv *priv);
-
-#endif /* __MCP25XXFD_GPIO_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c
deleted file mode 100644
index cca9c996b542..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.c
+++ /dev/null
@@ -1,73 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#include <linux/kernel.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_can_int.h"
-#include "mcp25xxfd_crc.h"
-#include "mcp25xxfd_ecc.h"
-#include "mcp25xxfd_int.h"
-#include "mcp25xxfd_priv.h"
-
-int mcp25xxfd_int_clear(struct mcp25xxfd_priv *priv)
-{
-	int ret;
-
-	ret = mcp25xxfd_ecc_clear_int(priv);
-	if (ret)
-		return ret;
-	ret = mcp25xxfd_crc_clear_int(priv);
-	if (ret)
-		return ret;
-	ret = mcp25xxfd_can_int_clear(priv);
-
-	return ret;
-}
-
-int mcp25xxfd_int_enable(struct mcp25xxfd_priv *priv, bool enable)
-{
-	/* error handling only on enable for this function */
-	int ret = 0;
-
-	/* if we enable clear interrupt flags first */
-	if (enable) {
-		ret = mcp25xxfd_int_clear(priv);
-		if (ret)
-			goto out;
-	}
-
-	ret = mcp25xxfd_crc_enable_int(priv, enable);
-	if (ret)
-		goto out;
-
-	ret = mcp25xxfd_ecc_enable(priv);
-	if (ret)
-		goto out_crc;
-
-	ret = mcp25xxfd_ecc_enable_int(priv, enable);
-	if (ret)
-		goto out_crc;
-
-	ret = mcp25xxfd_can_int_enable(priv, enable);
-	if (ret)
-		goto out_ecc;
-
-	/* if we disable interrupts clear interrupt flags last */
-	if (!enable)
-		mcp25xxfd_int_clear(priv);
-
-	return 0;
-
-out_ecc:
-	mcp25xxfd_ecc_enable_int(priv, false);
-
-out_crc:
-	mcp25xxfd_crc_enable_int(priv, false);
-out:
-	return ret;
-}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h
deleted file mode 100644
index 4daf0182d1af..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_int.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_INT_H
-#define __MCP25XXFD_INT_H
-
-#include "mcp25xxfd_priv.h"
-
-int mcp25xxfd_int_clear(struct mcp25xxfd_priv *priv);
-int mcp25xxfd_int_enable(struct mcp25xxfd_priv *priv, bool enable);
-
-#endif /* __MCP25XXFD_INT_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h
deleted file mode 100644
index 89bd39779b28..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_priv.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-#ifndef __MCP25XXFD_PRIV_H
-#define __MCP25XXFD_PRIV_H
-
-#include <linux/clk.h>
-#include <linux/debugfs.h>
-#include <linux/gpio/driver.h>
-#include <linux/mutex.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-
-#include "mcp25xxfd_regs.h"
-
-/* some defines for the driver */
-#define DEVICE_NAME "mcp25xxfd"
-
-enum mcp25xxfd_model {
-	CAN_MCP2517FD	= 0x2517,
-	CAN_MCP2518FD	= 0x2518,
-};
-
-struct mcp25xxfd_can_priv;
-struct mcp25xxfd_priv {
-	struct spi_device *spi;
-	struct clk *clk;
-	struct gpio_chip gpio;
-	struct mcp25xxfd_can_priv *cpriv;
-
-	/* the actual model of the mcp25xxfd */
-	enum mcp25xxfd_model model;
-
-	/* full device name used for debugfs ant interrupts */
-	char device_name[32];
-
-	/* everything clock related */
-	int clock_freq;
-	struct {
-		/* clock configuration */
-		int clock_pll;
-		int clock_div2;
-		int clock_odiv;
-		/* gpio related */
-		bool gpio_open_drain;
-		bool gpio0_xstandby;
-	} config;
-
-	/* lock for enabling/disabling the clock */
-	struct mutex clk_user_lock;
-	u32 clk_user_mask;
-	u32 clk_sleep_mask;
-
-	/* power related */
-	struct regulator *power;
-
-	/* the distinct spi_speeds to use for spi communication */
-	u32 spi_setup_speed_hz;
-	u32 spi_normal_speed_hz;
-	u32 spi_use_speed_hz;
-
-	/* spi-tx/rx buffers for efficient transfers
-	 * used during setup and irq
-	 */
-	struct mutex spi_rxtx_lock; /* protects use of spi_tx/rx */
-	u8 spi_tx[MCP25XXFD_SRAM_SIZE];
-	u8 spi_rx[MCP25XXFD_SRAM_SIZE];
-
-	/* configuration registers */
-	struct {
-		u32 osc;
-		u32 iocon;
-		u32 crc;
-		u32 ecccon;
-	} regs;
-
-	/* debugfs related */
-#if defined(CONFIG_DEBUG_FS)
-	struct dentry *debugfs_dir;
-	struct dentry *debugfs_regs_dir;
-	struct {
-		u64 spi_crc_read;
-		u64 spi_crc_read_split;
-	} stats;
-#endif
-};
-
-#endif /* __MCP25XXFD_PRIV_H */
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h
deleted file mode 100644
index f8495e0325c2..000000000000
--- a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd_regs.h
+++ /dev/null
@@ -1,681 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/* CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
- *
- * Copyright 2019 Martin Sperl <kernel@martin.sperl.org>
- */
-
-#ifndef __MCP25XXFD_REGS_H
-#define __MCP25XXFD_REGS_H
-
-#include <linux/bitops.h>
-
-/* some constants derived from the datasheets */
-#define MCP25XXFD_OST_DELAY_MS		3
-#define MCP25XXFD_MIN_CLOCK_FREQUENCY	1000000
-#define MCP25XXFD_MAX_CLOCK_FREQUENCY	40000000
-#define MCP25XXFD_PLL_MULTIPLIER	10
-#define MCP25XXFD_AUTO_PLL_MAX_CLOCK_FREQUENCY				\
-	(MCP25XXFD_MAX_CLOCK_FREQUENCY / MCP25XXFD_PLL_MULTIPLIER)
-#define MCP25XXFD_SCLK_DIVIDER		2
-
-/* GPIO, clock, ecc related register definitions of Controller itself */
-#define MCP25XXFD_SFR_BASE(x)			(0xE00 + (x))
-#define MCP25XXFD_OSC				MCP25XXFD_SFR_BASE(0x00)
-#  define MCP25XXFD_OSC_PLLEN			BIT(0)
-#  define MCP25XXFD_OSC_OSCDIS			BIT(2)
-#  define MCP25XXFD_OSC_SCLKDIV			BIT(4)
-#  define MCP25XXFD_OSC_CLKODIV_BITS		2
-#  define MCP25XXFD_OSC_CLKODIV_SHIFT		5
-#  define MCP25XXFD_OSC_CLKODIV_MASK					\
-	GENMASK(MCP25XXFD_OSC_CLKODIV_SHIFT				\
-		+ MCP25XXFD_OSC_CLKODIV_BITS - 1,			\
-		MCP25XXFD_OSC_CLKODIV_SHIFT)
-#  define MCP25XXFD_OSC_CLKODIV_10		3
-#  define MCP25XXFD_OSC_CLKODIV_4		2
-#  define MCP25XXFD_OSC_CLKODIV_2		1
-#  define MCP25XXFD_OSC_CLKODIV_1		0
-#  define MCP25XXFD_OSC_PLLRDY			BIT(8)
-#  define MCP25XXFD_OSC_OSCRDY			BIT(10)
-#  define MCP25XXFD_OSC_SCLKRDY			BIT(12)
-#define MCP25XXFD_IOCON				MCP25XXFD_SFR_BASE(0x04)
-#  define MCP25XXFD_IOCON_TRIS0			BIT(0)
-#  define MCP25XXFD_IOCON_TRIS1			BIT(1)
-#  define MCP25XXFD_IOCON_XSTBYEN		BIT(6)
-#  define MCP25XXFD_IOCON_LAT0			BIT(8)
-#  define MCP25XXFD_IOCON_LAT1			BIT(9)
-#  define MCP25XXFD_IOCON_GPIO0			BIT(16)
-#  define MCP25XXFD_IOCON_GPIO1			BIT(17)
-#  define MCP25XXFD_IOCON_PM0			BIT(24)
-#  define MCP25XXFD_IOCON_PM1			BIT(25)
-#  define MCP25XXFD_IOCON_TXCANOD		BIT(28)
-#  define MCP25XXFD_IOCON_SOF			BIT(29)
-#  define MCP25XXFD_IOCON_INTOD			BIT(30)
-#define MCP25XXFD_CRC				MCP25XXFD_SFR_BASE(0x08)
-#  define MCP25XXFD_CRC_MASK			GENMASK(15, 0)
-#  define MCP25XXFD_CRC_CRCERRIE		BIT(16)
-#  define MCP25XXFD_CRC_FERRIE			BIT(17)
-#  define MCP25XXFD_CRC_CRCERRIF		BIT(24)
-#  define MCP25XXFD_CRC_FERRIF			BIT(25)
-#define MCP25XXFD_ECCCON			MCP25XXFD_SFR_BASE(0x0C)
-#  define MCP25XXFD_ECCCON_ECCEN		BIT(0)
-#  define MCP25XXFD_ECCCON_SECIE		BIT(1)
-#  define MCP25XXFD_ECCCON_DEDIE		BIT(2)
-#  define MCP25XXFD_ECCCON_PARITY_BITS		6
-#  define MCP25XXFD_ECCCON_PARITY_SHIFT		8
-#  define MCP25XXFD_ECCCON_PARITY_MASK					\
-	GENMASK(MCP25XXFD_ECCCON_PARITY_SHIFT				\
-		+ MCP25XXFD_ECCCON_PARITY_BITS - 1,			\
-		MCP25XXFD_ECCCON_PARITY_SHIFT)
-#define MCP25XXFD_ECCSTAT			MCP25XXFD_SFR_BASE(0x10)
-#  define MCP25XXFD_ECCSTAT_SECIF		BIT(1)
-#  define MCP25XXFD_ECCSTAT_DEDIF		BIT(2)
-#  define MCP25XXFD_ECCSTAT_ERRADDR_SHIFT	8
-#  define MCP25XXFD_ECCSTAT_ERRADDR_MASK				\
-	GENMASK(MCP25XXFD_ECCSTAT_ERRADDR_SHIFT + 11,			\
-		MCP25XXFD_ECCSTAT_ERRADDR_SHIFT)
-
-#define MCP25XXFD_DEVID				MCP25XXFD_SFR_BASE(0x14)
-#  define MCP25XXFD_DEVID_REV_BITS		4
-#  define MCP25XXFD_DEVID_REV_SHIFT		0
-#  define MCP25XXFD_DEVID_REV_MASK					\
-	GENMASK(MCP25XXFD_DEVID_REV_SHIFT +				\
-		MCP25XXFD_DEVID_REV_BITS - 1,				\
-		MCP25XXFD_DEVID_REV_SHIFT)
-#  define MCP25XXFD_DEVID_ID_BITS		4
-#  define MCP25XXFD_DEVID_ID_SHIFT		4
-#  define MCP25XXFD_DEVID_ID_MASK					\
-	GENMASK(MCP25XXFD_DEVID_ID_SHIFT +				\
-		MCP25XXFD_DEVID_ID_BITS - 1,				\
-		MCP25XXFD_DEVID_ID_SHIFT)
-
-/* CAN related register definitions of Controller CAN block */
-#define MCP25XXFD_CAN_SFR_BASE(x)		(0x000 + (x))
-#define MCP25XXFD_CAN_CON						\
-	MCP25XXFD_CAN_SFR_BASE(0x00)
-#  define MCP25XXFD_CAN_CON_DNCNT_BITS		5
-#  define MCP25XXFD_CAN_CON_DNCNT_SHIFT		0
-#  define MCP25XXFD_CAN_CON_DNCNT_MASK					\
-	GENMASK(MCP25XXFD_CAN_CON_DNCNT_SHIFT +				\
-		MCP25XXFD_CAN_CON_DNCNT_BITS - 1,			\
-		MCP25XXFD_CAN_CON_DNCNT_SHIFT)
-#  define MCP25XXFD_CAN_CON_ISOCRCEN		BIT(5)
-#  define MCP25XXFD_CAN_CON_PXEDIS		BIT(6)
-#  define MCP25XXFD_CAN_CON_WAKFIL		BIT(8)
-#  define MCP25XXFD_CAN_CON_WFT_BITS		2
-#  define MCP25XXFD_CAN_CON_WFT_SHIFT		9
-#  define MCP25XXFD_CAN_CON_WFT_MASK					\
-	GENMASK(MCP25XXFD_CAN_CON_WFT_SHIFT +				\
-		MCP25XXFD_CAN_CON_WFT_BITS - 1,				\
-		MCP25XXFD_CAN_CON_WFT_SHIFT)
-#  define MCP25XXFD_CAN_CON_BUSY		BIT(11)
-#  define MCP25XXFD_CAN_CON_BRSDIS		BIT(12)
-#  define MCP25XXFD_CAN_CON_RTXAT		BIT(16)
-#  define MCP25XXFD_CAN_CON_ESIGM		BIT(17)
-#  define MCP25XXFD_CAN_CON_SERR2LOM		BIT(18)
-#  define MCP25XXFD_CAN_CON_STEF		BIT(19)
-#  define MCP25XXFD_CAN_CON_TXQEN		BIT(20)
-#  define MCP25XXFD_CAN_CON_OPMODE_BITS		3
-#  define MCP25XXFD_CAN_CON_OPMOD_SHIFT		21
-#  define MCP25XXFD_CAN_CON_OPMOD_MASK					\
-	GENMASK(MCP25XXFD_CAN_CON_OPMOD_SHIFT +				\
-		MCP25XXFD_CAN_CON_OPMODE_BITS - 1,			\
-		MCP25XXFD_CAN_CON_OPMOD_SHIFT)
-#  define MCP25XXFD_CAN_CON_REQOP_BITS		3
-#  define MCP25XXFD_CAN_CON_REQOP_SHIFT		24
-#  define MCP25XXFD_CAN_CON_REQOP_MASK					\
-	GENMASK(MCP25XXFD_CAN_CON_REQOP_SHIFT +				\
-		MCP25XXFD_CAN_CON_REQOP_BITS - 1,			\
-		MCP25XXFD_CAN_CON_REQOP_SHIFT)
-#    define MCP25XXFD_CAN_CON_MODE_MIXED	0
-#    define MCP25XXFD_CAN_CON_MODE_SLEEP	1
-#    define MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK	2
-#    define MCP25XXFD_CAN_CON_MODE_LISTENONLY	3
-#    define MCP25XXFD_CAN_CON_MODE_CONFIG	4
-#    define MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK	5
-#    define MCP25XXFD_CAN_CON_MODE_CAN2_0	6
-#    define MCP25XXFD_CAN_CON_MODE_RESTRICTED	7
-#  define MCP25XXFD_CAN_CON_ABAT		BIT(27)
-#  define MCP25XXFD_CAN_CON_TXBWS_BITS		3
-#  define MCP25XXFD_CAN_CON_TXBWS_SHIFT		28
-#  define MCP25XXFD_CAN_CON_TXBWS_MASK					\
-	GENMASK(MCP25XXFD_CAN_CON_TXBWS_SHIFT +				\
-		MCP25XXFD_CAN_CON_TXBWS_BITS - 1,			\
-		MCP25XXFD_CAN_CON_TXBWS_SHIFT)
-#  define MCP25XXFD_CAN_CON_DEFAULT					\
-	(MCP25XXFD_CAN_CON_ISOCRCEN |					\
-	 MCP25XXFD_CAN_CON_PXEDIS |					\
-	 MCP25XXFD_CAN_CON_WAKFIL |					\
-	 (3 << MCP25XXFD_CAN_CON_WFT_SHIFT) |				\
-	 MCP25XXFD_CAN_CON_STEF |					\
-	 MCP25XXFD_CAN_CON_TXQEN |					\
-	 (MCP25XXFD_CAN_CON_MODE_CONFIG << MCP25XXFD_CAN_CON_OPMOD_SHIFT) | \
-	 (MCP25XXFD_CAN_CON_MODE_CONFIG << MCP25XXFD_CAN_CON_REQOP_SHIFT))
-#  define MCP25XXFD_CAN_CON_DEFAULT_MASK				\
-	(MCP25XXFD_CAN_CON_DNCNT_MASK |					\
-	 MCP25XXFD_CAN_CON_ISOCRCEN |					\
-	 MCP25XXFD_CAN_CON_PXEDIS |					\
-	 MCP25XXFD_CAN_CON_WAKFIL |					\
-	 MCP25XXFD_CAN_CON_WFT_MASK |					\
-	 MCP25XXFD_CAN_CON_BRSDIS |					\
-	 MCP25XXFD_CAN_CON_RTXAT |					\
-	 MCP25XXFD_CAN_CON_ESIGM |					\
-	 MCP25XXFD_CAN_CON_SERR2LOM |					\
-	 MCP25XXFD_CAN_CON_STEF |					\
-	 MCP25XXFD_CAN_CON_TXQEN |					\
-	 MCP25XXFD_CAN_CON_OPMOD_MASK |					\
-	 MCP25XXFD_CAN_CON_REQOP_MASK |					\
-	 MCP25XXFD_CAN_CON_ABAT |					\
-	 MCP25XXFD_CAN_CON_TXBWS_MASK)
-#define MCP25XXFD_CAN_NBTCFG			MCP25XXFD_CAN_SFR_BASE(0x04)
-#  define MCP25XXFD_CAN_NBTCFG_SJW_BITS		7
-#  define MCP25XXFD_CAN_NBTCFG_SJW_SHIFT	0
-#  define MCP25XXFD_CAN_NBTCFG_SJW_MASK					\
-	GENMASK(MCP25XXFD_CAN_NBTCFG_SJW_SHIFT +			\
-		MCP25XXFD_CAN_NBTCFG_SJW_BITS - 1,			\
-		MCP25XXFD_CAN_NBTCFG_SJW_SHIFT)
-#  define MCP25XXFD_CAN_NBTCFG_TSEG2_BITS	7
-#  define MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT	8
-#  define MCP25XXFD_CAN_NBTCFG_TSEG2_MASK				\
-	GENMASK(MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT +			\
-		MCP25XXFD_CAN_NBTCFG_TSEG2_BITS - 1,			\
-		MCP25XXFD_CAN_NBTCFG_TSEG2_SHIFT)
-#  define MCP25XXFD_CAN_NBTCFG_TSEG1_BITS	8
-#  define MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT	16
-#  define MCP25XXFD_CAN_NBTCFG_TSEG1_MASK				\
-	GENMASK(MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT +			\
-		MCP25XXFD_CAN_NBTCFG_TSEG1_BITS - 1,			\
-		MCP25XXFD_CAN_NBTCFG_TSEG1_SHIFT)
-#  define MCP25XXFD_CAN_NBTCFG_BRP_BITS		8
-#  define MCP25XXFD_CAN_NBTCFG_BRP_SHIFT	24
-#  define MCP25XXFD_CAN_NBTCFG_BRP_MASK					\
-	GENMASK(MCP25XXFD_CAN_NBTCFG_BRP_SHIFT +			\
-		MCP25XXFD_CAN_NBTCFG_BRP_BITS - 1,			\
-		MCP25XXFD_CAN_NBTCFG_BRP_SHIFT)
-#define MCP25XXFD_CAN_DBTCFG			MCP25XXFD_CAN_SFR_BASE(0x08)
-#  define MCP25XXFD_CAN_DBTCFG_SJW_BITS		4
-#  define MCP25XXFD_CAN_DBTCFG_SJW_SHIFT	0
-#  define MCP25XXFD_CAN_DBTCFG_SJW_MASK					\
-	GENMASK(MCP25XXFD_CAN_DBTCFG_SJW_SHIFT +			\
-		MCP25XXFD_CAN_DBTCFG_SJW_BITS - 1,			\
-		MCP25XXFD_CAN_DBTCFG_SJW_SHIFT)
-#  define MCP25XXFD_CAN_DBTCFG_TSEG2_BITS	4
-#  define MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT	8
-#  define MCP25XXFD_CAN_DBTCFG_TSEG2_MASK				\
-	GENMASK(MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT +			\
-		MCP25XXFD_CAN_DBTCFG_TSEG2_BITS - 1,			\
-		MCP25XXFD_CAN_DBTCFG_TSEG2_SHIFT)
-#  define MCP25XXFD_CAN_DBTCFG_TSEG1_BITS	5
-#  define MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT	16
-#  define MCP25XXFD_CAN_DBTCFG_TSEG1_MASK				\
-	GENMASK(MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT +			\
-		MCP25XXFD_CAN_DBTCFG_TSEG1_BITS - 1,			\
-		MCP25XXFD_CAN_DBTCFG_TSEG1_SHIFT)
-#  define MCP25XXFD_CAN_DBTCFG_BRP_BITS		8
-#  define MCP25XXFD_CAN_DBTCFG_BRP_SHIFT	24
-#  define MCP25XXFD_CAN_DBTCFG_BRP_MASK					\
-	GENMASK(MCP25XXFD_CAN_DBTCFG_BRP_SHIFT +			\
-		MCP25XXFD_CAN_DBTCFG_BRP_BITS - 1,			\
-		MCP25XXFD_CAN_DBTCFG_BRP_SHIFT)
-#define MCP25XXFD_CAN_TDC			MCP25XXFD_CAN_SFR_BASE(0x0C)
-#  define MCP25XXFD_CAN_TDC_TDCV_BITS		5
-#  define MCP25XXFD_CAN_TDC_TDCV_SHIFT		0
-#  define MCP25XXFD_CAN_TDC_TDCV_MASK					\
-	GENMASK(MCP25XXFD_CAN_TDC_TDCV_SHIFT +				\
-		MCP25XXFD_CAN_TDC_TDCV_BITS - 1,			\
-		MCP25XXFD_CAN_TDC_TDCV_SHIFT)
-#  define MCP25XXFD_CAN_TDC_TDCO_BITS		5
-#  define MCP25XXFD_CAN_TDC_TDCO_SHIFT		8
-#  define MCP25XXFD_CAN_TDC_TDCO_MASK					\
-	GENMASK(MCP25XXFD_CAN_TDC_TDCO_SHIFT +				\
-		MCP25XXFD_CAN_TDC_TDCO_BITS - 1,			\
-		MCP25XXFD_CAN_TDC_TDCO_SHIFT)
-#  define MCP25XXFD_CAN_TDC_TDCMOD_BITS		2
-#  define MCP25XXFD_CAN_TDC_TDCMOD_SHIFT	16
-#  define MCP25XXFD_CAN_TDC_TDCMOD_MASK					\
-	GENMASK(MCP25XXFD_CAN_TDC_TDCMOD_SHIFT +			\
-		MCP25XXFD_CAN_TDC_TDCMOD_BITS - 1,			\
-		MCP25XXFD_CAN_TDC_TDCMOD_SHIFT)
-#  define MCP25XXFD_CAN_TDC_TDCMOD_DISABLED	0
-#  define MCP25XXFD_CAN_TDC_TDCMOD_MANUAL	1
-#  define MCP25XXFD_CAN_TDC_TDCMOD_AUTO		2
-#  define MCP25XXFD_CAN_TDC_SID11EN		BIT(24)
-#  define MCP25XXFD_CAN_TDC_EDGFLTEN		BIT(25)
-#define MCP25XXFD_CAN_TBC			MCP25XXFD_CAN_SFR_BASE(0x10)
-#define MCP25XXFD_CAN_TSCON			MCP25XXFD_CAN_SFR_BASE(0x14)
-#  define MCP25XXFD_CAN_TSCON_TBCPRE_BITS	10
-#  define MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT	0
-#  define MCP25XXFD_CAN_TSCON_TBCPRE_MASK				\
-	GENMASK(MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT +			\
-		MCP25XXFD_CAN_TSCON_TBCPRE_BITS - 1,			\
-		MCP25XXFD_CAN_TSCON_TBCPRE_SHIFT)
-#  define MCP25XXFD_CAN_TSCON_TBCEN		BIT(16)
-#  define MCP25XXFD_CAN_TSCON_TSEOF		BIT(17)
-#  define MCP25XXFD_CAN_TSCON_TSRES		BIT(18)
-#define MCP25XXFD_CAN_VEC			MCP25XXFD_CAN_SFR_BASE(0x18)
-#  define MCP25XXFD_CAN_VEC_ICODE_BITS		7
-#  define MCP25XXFD_CAN_VEC_ICODE_SHIFT		0
-#  define MCP25XXFD_CAN_VEC_ICODE_MASK					\
-	GENMASK(MCP25XXFD_CAN_VEC_ICODE_SHIFT +				\
-		MCP25XXFD_CAN_VEC_ICODE_BITS - 1,			\
-		MCP25XXFD_CAN_VEC_ICODE_SHIFT)
-#  define MCP25XXFD_CAN_VEC_FILHIT_BITS		5
-#  define MCP25XXFD_CAN_VEC_FILHIT_SHIFT	8
-#  define MCP25XXFD_CAN_VEC_FILHIT_MASK					\
-	GENMASK(MCP25XXFD_CAN_VEC_FILHIT_SHIFT +			\
-		MCP25XXFD_CAN_VEC_FILHIT_BITS - 1,			\
-		MCP25XXFD_CAN_VEC_FILHIT_SHIFT)
-#  define MCP25XXFD_CAN_VEC_TXCODE_BITS		7
-#  define MCP25XXFD_CAN_VEC_TXCODE_SHIFT	16
-#  define MCP25XXFD_CAN_VEC_TXCODE_MASK					\
-	GENMASK(MCP25XXFD_CAN_VEC_TXCODE_SHIFT +			\
-		MCP25XXFD_CAN_VEC_TXCODE_BITS - 1,			\
-		MCP25XXFD_CAN_VEC_TXCODE_SHIFT)
-#  define MCP25XXFD_CAN_VEC_RXCODE_BITS		7
-#  define MCP25XXFD_CAN_VEC_RXCODE_SHIFT	24
-#  define MCP25XXFD_CAN_VEC_RXCODE_MASK					\
-	GENMASK(MCP25XXFD_CAN_VEC_RXCODE_SHIFT +			\
-		MCP25XXFD_CAN_VEC_RXCODE_BITS - 1,			\
-		MCP25XXFD_CAN_VEC_RXCODE_SHIFT)
-#define MCP25XXFD_CAN_INT			MCP25XXFD_CAN_SFR_BASE(0x1C)
-#  define MCP25XXFD_CAN_INT_IF_SHIFT		0
-#  define MCP25XXFD_CAN_INT_TXIF		BIT(0)
-#  define MCP25XXFD_CAN_INT_RXIF		BIT(1)
-#  define MCP25XXFD_CAN_INT_TBCIF		BIT(2)
-#  define MCP25XXFD_CAN_INT_MODIF		BIT(3)
-#  define MCP25XXFD_CAN_INT_TEFIF		BIT(4)
-#  define MCP25XXFD_CAN_INT_ECCIF		BIT(8)
-#  define MCP25XXFD_CAN_INT_SPICRCIF		BIT(9)
-#  define MCP25XXFD_CAN_INT_TXATIF		BIT(10)
-#  define MCP25XXFD_CAN_INT_RXOVIF		BIT(11)
-#  define MCP25XXFD_CAN_INT_SERRIF		BIT(12)
-#  define MCP25XXFD_CAN_INT_CERRIF		BIT(13)
-#  define MCP25XXFD_CAN_INT_WAKIF		BIT(14)
-#  define MCP25XXFD_CAN_INT_IVMIF		BIT(15)
-#  define MCP25XXFD_CAN_INT_IF_MASK					\
-	(MCP25XXFD_CAN_INT_TXIF |					\
-	 MCP25XXFD_CAN_INT_RXIF |					\
-	 MCP25XXFD_CAN_INT_TBCIF |					\
-	 MCP25XXFD_CAN_INT_MODIF |					\
-	 MCP25XXFD_CAN_INT_TEFIF |					\
-	 MCP25XXFD_CAN_INT_ECCIF |					\
-	 MCP25XXFD_CAN_INT_SPICRCIF |					\
-	 MCP25XXFD_CAN_INT_TXATIF |					\
-	 MCP25XXFD_CAN_INT_RXOVIF |					\
-	 MCP25XXFD_CAN_INT_CERRIF |					\
-	 MCP25XXFD_CAN_INT_SERRIF |					\
-	 MCP25XXFD_CAN_INT_WAKIF |					\
-	 MCP25XXFD_CAN_INT_IVMIF)
-#  define MCP25XXFD_CAN_INT_IF_CLEAR_MASK				\
-	(MCP25XXFD_CAN_INT_TBCIF  |					\
-	 MCP25XXFD_CAN_INT_MODIF  |					\
-	 MCP25XXFD_CAN_INT_CERRIF |					\
-	 MCP25XXFD_CAN_INT_SERRIF |					\
-	 MCP25XXFD_CAN_INT_WAKIF |					\
-	 MCP25XXFD_CAN_INT_IVMIF)
-#  define MCP25XXFD_CAN_INT_IE_SHIFT		16
-#  define MCP25XXFD_CAN_INT_TXIE					\
-	(MCP25XXFD_CAN_INT_TXIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_RXIE					\
-	(MCP25XXFD_CAN_INT_RXIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_TBCIE					\
-	(MCP25XXFD_CAN_INT_TBCIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_MODIE					\
-	(MCP25XXFD_CAN_INT_MODIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_TEFIE					\
-	(MCP25XXFD_CAN_INT_TEFIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_ECCIE					\
-	(MCP25XXFD_CAN_INT_ECCIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_SPICRCIE					\
-	(MCP25XXFD_CAN_INT_SPICRCIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_TXATIE					\
-	(MCP25XXFD_CAN_INT_TXATIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_RXOVIE					\
-	(MCP25XXFD_CAN_INT_RXOVIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_CERRIE					\
-	(MCP25XXFD_CAN_INT_CERRIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_SERRIE					\
-	(MCP25XXFD_CAN_INT_SERRIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_WAKIE					\
-	(MCP25XXFD_CAN_INT_WAKIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_IVMIE					\
-	(MCP25XXFD_CAN_INT_IVMIF << MCP25XXFD_CAN_INT_IE_SHIFT)
-#  define MCP25XXFD_CAN_INT_IE_MASK					\
-	(MCP25XXFD_CAN_INT_TXIE |					\
-	 MCP25XXFD_CAN_INT_RXIE |					\
-	 MCP25XXFD_CAN_INT_TBCIE |					\
-	 MCP25XXFD_CAN_INT_MODIE |					\
-	 MCP25XXFD_CAN_INT_TEFIE |					\
-	 MCP25XXFD_CAN_INT_ECCIE |					\
-	 MCP25XXFD_CAN_INT_SPICRCIE |					\
-	 MCP25XXFD_CAN_INT_TXATIE |					\
-	 MCP25XXFD_CAN_INT_RXOVIE |					\
-	 MCP25XXFD_CAN_INT_CERRIE |					\
-	 MCP25XXFD_CAN_INT_SERRIE |					\
-	 MCP25XXFD_CAN_INT_WAKIE |					\
-	 MCP25XXFD_CAN_INT_IVMIE)
-#define MCP25XXFD_CAN_RXIF			MCP25XXFD_CAN_SFR_BASE(0x20)
-#define MCP25XXFD_CAN_TXIF			MCP25XXFD_CAN_SFR_BASE(0x24)
-#define MCP25XXFD_CAN_RXOVIF			MCP25XXFD_CAN_SFR_BASE(0x28)
-#define MCP25XXFD_CAN_TXATIF			MCP25XXFD_CAN_SFR_BASE(0x2C)
-#define MCP25XXFD_CAN_TXREQ			MCP25XXFD_CAN_SFR_BASE(0x30)
-#define MCP25XXFD_CAN_TREC			MCP25XXFD_CAN_SFR_BASE(0x34)
-#  define MCP25XXFD_CAN_TREC_REC_BITS		8
-#  define MCP25XXFD_CAN_TREC_REC_SHIFT		0
-#  define MCP25XXFD_CAN_TREC_REC_MASK					\
-	GENMASK(MCP25XXFD_CAN_TREC_REC_SHIFT +				\
-		MCP25XXFD_CAN_TREC_REC_BITS - 1,			\
-		MCP25XXFD_CAN_TREC_REC_SHIFT)
-#  define MCP25XXFD_CAN_TREC_TEC_BITS		8
-#  define MCP25XXFD_CAN_TREC_TEC_SHIFT		8
-#  define MCP25XXFD_CAN_TREC_TEC_MASK					\
-	GENMASK(MCP25XXFD_CAN_TREC_TEC_SHIFT +				\
-		MCP25XXFD_CAN_TREC_TEC_BITS - 1,			\
-		MCP25XXFD_CAN_TREC_TEC_SHIFT)
-#  define MCP25XXFD_CAN_TREC_EWARN		BIT(16)
-#  define MCP25XXFD_CAN_TREC_RXWARN		BIT(17)
-#  define MCP25XXFD_CAN_TREC_TXWARN		BIT(18)
-#  define MCP25XXFD_CAN_TREC_RXBP		BIT(19)
-#  define MCP25XXFD_CAN_TREC_TXBP		BIT(20)
-#  define MCP25XXFD_CAN_TREC_TXBO		BIT(21)
-#define MCP25XXFD_CAN_BDIAG0			MCP25XXFD_CAN_SFR_BASE(0x38)
-#  define MCP25XXFD_CAN_BDIAG0_NRERRCNT_BITS	8
-#  define MCP25XXFD_CAN_BDIAG0_NRERRCNT_SHIFT	0
-#  define MCP25XXFD_CAN_BDIAG0_NRERRCNT_MASK				\
-	GENMASK(MCP25XXFD_CAN_BDIAG0_NRERRCNT_SHIFT +			\
-		MCP25XXFD_CAN_BDIAG0_NRERRCNT_BITS - 1,			\
-		MCP25XXFD_CAN_BDIAG0_NRERRCNT_SHIFT)
-#  define MCP25XXFD_CAN_BDIAG0_NTERRCNT_BITS	8
-#  define MCP25XXFD_CAN_BDIAG0_NTERRCNT_SHIFT	8
-#  define MCP25XXFD_CAN_BDIAG0_NTERRCNT_MASK				\
-	GENMASK(MCP25XXFD_CAN_BDIAG0_NTERRCNT_SHIFT +			\
-		MCP25XXFD_CAN_BDIAG0_NTERRCNT_BITS - 1,			\
-		MCP25XXFD_CAN_BDIAG0_NTERRCNT_SHIFT)
-#  define MCP25XXFD_CAN_BDIAG0_DRERRCNT_BITS	8
-#  define MCP25XXFD_CAN_BDIAG0_DRERRCNT_SHIFT	16
-#  define MCP25XXFD_CAN_BDIAG0_DRERRCNT_MASK				\
-	GENMASK(MCP25XXFD_CAN_BDIAG0_DRERRCNT_SHIFT +			\
-		MCP25XXFD_CAN_BDIAG0_DRERRCNT_BITS - 1,			\
-		MCP25XXFD_CAN_BDIAG0_DRERRCNT_SHIFT)
-#  define MCP25XXFD_CAN_BDIAG0_DTERRCNT_BITS	8
-#  define MCP25XXFD_CAN_BDIAG0_DTERRCNT_SHIFT	24
-#  define MCP25XXFD_CAN_BDIAG0_DTERRCNT_MASK				\
-	GENMASK(MCP25XXFD_CAN_BDIAG0_DTERRCNT_SHIFT +			\
-		MCP25XXFD_CAN_BDIAG0_DTERRCNT_BITS - 1,			\
-		MCP25XXFD_CAN_BDIAG0_DTERRCNT_SHIFT)
-#define MCP25XXFD_CAN_BDIAG1			MCP25XXFD_CAN_SFR_BASE(0x3C)
-#  define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_BITS	16
-#  define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_SHIFT	0
-#  define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_MASK				\
-	GENMASK(MCP25XXFD_CAN_BDIAG1_EFMSGCNT_SHIFT +			\
-		MCP25XXFD_CAN_BDIAG1_EFMSGCNT_BITS - 1,			\
-		MCP25XXFD_CAN_BDIAG1_EFMSGCNT_SHIFT)
-#  define MCP25XXFD_CAN_BDIAG1_NBIT0ERR		BIT(16)
-#  define MCP25XXFD_CAN_BDIAG1_NBIT1ERR		BIT(17)
-#  define MCP25XXFD_CAN_BDIAG1_NACKERR		BIT(18)
-#  define MCP25XXFD_CAN_BDIAG1_NSTUFERR		BIT(19)
-#  define MCP25XXFD_CAN_BDIAG1_NFORMERR		BIT(20)
-#  define MCP25XXFD_CAN_BDIAG1_NCRCERR		BIT(21)
-#  define MCP25XXFD_CAN_BDIAG1_TXBOERR		BIT(23)
-#  define MCP25XXFD_CAN_BDIAG1_DBIT0ERR		BIT(24)
-#  define MCP25XXFD_CAN_BDIAG1_DBIT1ERR		BIT(25)
-#  define MCP25XXFD_CAN_BDIAG1_DFORMERR		BIT(27)
-#  define MCP25XXFD_CAN_BDIAG1_DSTUFERR		BIT(28)
-#  define MCP25XXFD_CAN_BDIAG1_DCRCERR		BIT(29)
-#  define MCP25XXFD_CAN_BDIAG1_ESI		BIT(30)
-#  define MCP25XXFD_CAN_BDIAG1_DLCMM		BIT(31)
-#define MCP25XXFD_CAN_TEFCON			MCP25XXFD_CAN_SFR_BASE(0x40)
-#  define MCP25XXFD_CAN_TEFCON_TEFNEIE		BIT(0)
-#  define MCP25XXFD_CAN_TEFCON_TEFHIE		BIT(1)
-#  define MCP25XXFD_CAN_TEFCON_TEFFIE		BIT(2)
-#  define MCP25XXFD_CAN_TEFCON_TEFOVIE		BIT(3)
-#  define MCP25XXFD_CAN_TEFCON_TEFTSEN		BIT(5)
-#  define MCP25XXFD_CAN_TEFCON_UINC		BIT(8)
-#  define MCP25XXFD_CAN_TEFCON_FRESET		BIT(10)
-#  define MCP25XXFD_CAN_TEFCON_FSIZE_BITS	5
-#  define MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT	24
-#  define MCP25XXFD_CAN_TEFCON_FSIZE_MASK				\
-	GENMASK(MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT +			\
-		MCP25XXFD_CAN_TEFCON_FSIZE_BITS - 1,			\
-		MCP25XXFD_CAN_TEFCON_FSIZE_SHIFT)
-#define MCP25XXFD_CAN_TEFSTA			MCP25XXFD_CAN_SFR_BASE(0x44)
-#  define MCP25XXFD_CAN_TEFSTA_TEFNEIF		BIT(0)
-#  define MCP25XXFD_CAN_TEFSTA_TEFHIF		BIT(1)
-#  define MCP25XXFD_CAN_TEFSTA_TEFFIF		BIT(2)
-#  define MCP25XXFD_CAN_TEFSTA_TEVOVIF		BIT(3)
-#define MCP25XXFD_CAN_TEFUA			MCP25XXFD_CAN_SFR_BASE(0x48)
-#define MCP25XXFD_CAN_RESERVED			MCP25XXFD_CAN_SFR_BASE(0x4C)
-#define MCP25XXFD_CAN_TXQCON			MCP25XXFD_CAN_SFR_BASE(0x50)
-#  define MCP25XXFD_CAN_TXQCON_TXQNIE		BIT(0)
-#  define MCP25XXFD_CAN_TXQCON_TXQEIE		BIT(2)
-#  define MCP25XXFD_CAN_TXQCON_TXATIE		BIT(4)
-#  define MCP25XXFD_CAN_TXQCON_TXEN		BIT(7)
-#  define MCP25XXFD_CAN_TXQCON_UINC		BIT(8)
-#  define MCP25XXFD_CAN_TXQCON_TXREQ		BIT(9)
-#  define MCP25XXFD_CAN_TXQCON_FRESET		BIT(10)
-#  define MCP25XXFD_CAN_TXQCON_TXPRI_BITS	5
-#  define MCP25XXFD_CAN_TXQCON_TXPRI_SHIFT	16
-#  define MCP25XXFD_CAN_TXQCON_TXPRI_MASK				\
-	GENMASK(MCP25XXFD_CAN_TXQCON_TXPRI_SHIFT +			\
-		MCP25XXFD_CAN_TXQCON_TXPRI_BITS - 1,			\
-		MCP25XXFD_CAN_TXQCON_TXPRI_SHIFT)
-#  define MCP25XXFD_CAN_TXQCON_TXAT_BITS	2
-#  define MCP25XXFD_CAN_TXQCON_TXAT_SHIFT	21
-#  define MCP25XXFD_CAN_TXQCON_TXAT_MASK				\
-	GENMASK(MCP25XXFD_CAN_TXQCON_TXAT_SHIFT +			\
-		#MCP25XXFD_CAN_TXQCON_TXAT_BITS - 1,			\
-		MCP25XXFD_CAN_TXQCON_TXAT_SHIFT)
-#  define MCP25XXFD_CAN_TXQCON_FSIZE_BITS	5
-#  define MCP25XXFD_CAN_TXQCON_FSIZE_SHIFT	24
-#  define MCP25XXFD_CAN_TXQCON_FSIZE_MASK				\
-	GENMASK(MCP25XXFD_CAN_TXQCON_FSIZE_SHIFT +			\
-		MCP25XXFD_CAN_TXQCON_FSIZE_BITS - 1,			\
-		MCP25XXFD_CAN_TXQCON_FSIZE_SHIFT)
-#  define MCP25XXFD_CAN_TXQCON_PLSIZE_BITS	3
-#  define MCP25XXFD_CAN_TXQCON_PLSIZE_SHIFT	29
-#  define MCP25XXFD_CAN_TXQCON_PLSIZE_MASK				\
-	GENMASK(MCP25XXFD_CAN_TXQCON_PLSIZE_SHIFT +			\
-		MCP25XXFD_CAN_TXQCON_PLSIZE_BITS - 1,			\
-		MCP25XXFD_CAN_TXQCON_PLSIZE_SHIFT)
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_8	0
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_12	1
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_16	2
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_20	3
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_24	4
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_32	5
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_48	6
-#    define MCP25XXFD_CAN_TXQCON_PLSIZE_64	7
-
-#define MCP25XXFD_CAN_TXQSTA			MCP25XXFD_CAN_SFR_BASE(0x54)
-#  define MCP25XXFD_CAN_TXQSTA_TXQNIF		BIT(0)
-#  define MCP25XXFD_CAN_TXQSTA_TXQEIF		BIT(2)
-#  define MCP25XXFD_CAN_TXQSTA_TXATIF		BIT(4)
-#  define MCP25XXFD_CAN_TXQSTA_TXERR		BIT(5)
-#  define MCP25XXFD_CAN_TXQSTA_TXLARB		BIT(6)
-#  define MCP25XXFD_CAN_TXQSTA_TXABT		BIT(7)
-#  define MCP25XXFD_CAN_TXQSTA_TXQCI_BITS	5
-#  define MCP25XXFD_CAN_TXQSTA_TXQCI_SHIFT	8
-#  define MCP25XXFD_CAN_TXQSTA_TXQCI_MASK				\
-	GENMASK(MCP25XXFD_CAN_TXQSTA_TXQCI_SHIFT +			\
-		MCP25XXFD_CAN_TXQSTA_TXQCI_BITS - 1,			\
-		MCP25XXFD_CAN_TXQSTA_TXQCI_SHIFT)
-
-#define MCP25XXFD_CAN_TXQUA			MCP25XXFD_CAN_SFR_BASE(0x58)
-#define MCP25XXFD_CAN_FIFOCON(x)					\
-	MCP25XXFD_CAN_SFR_BASE(0x5C + 12 * ((x) - 1))
-#define MCP25XXFD_CAN_FIFOCON_TFNRFNIE		BIT(0)
-#define MCP25XXFD_CAN_FIFOCON_TFHRFHIE		BIT(1)
-#define MCP25XXFD_CAN_FIFOCON_TFERFFIE		BIT(2)
-#define MCP25XXFD_CAN_FIFOCON_RXOVIE		BIT(3)
-#define MCP25XXFD_CAN_FIFOCON_TXATIE		BIT(4)
-#define MCP25XXFD_CAN_FIFOCON_RXTSEN		BIT(5)
-#define MCP25XXFD_CAN_FIFOCON_RTREN		BIT(6)
-#define MCP25XXFD_CAN_FIFOCON_TXEN		BIT(7)
-#define MCP25XXFD_CAN_FIFOCON_UINC		BIT(8)
-#define MCP25XXFD_CAN_FIFOCON_TXREQ		BIT(9)
-#define MCP25XXFD_CAN_FIFOCON_FRESET		BIT(10)
-#  define MCP25XXFD_CAN_FIFOCON_TXPRI_BITS	5
-#  define MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT	16
-#  define MCP25XXFD_CAN_FIFOCON_TXPRI_MASK				\
-	GENMASK(MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT +			\
-		MCP25XXFD_CAN_FIFOCON_TXPRI_BITS - 1,			\
-		MCP25XXFD_CAN_FIFOCON_TXPRI_SHIFT)
-#  define MCP25XXFD_CAN_FIFOCON_TXAT_BITS	2
-#  define MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT	21
-#  define MCP25XXFD_CAN_FIFOCON_TXAT_MASK				\
-	GENMASK(MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT +			\
-		MCP25XXFD_CAN_FIFOCON_TXAT_BITS - 1,			\
-		MCP25XXFD_CAN_FIFOCON_TXAT_SHIFT)
-#  define MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT	0
-#  define MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT	1
-#  define MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED	2
-#  define MCP25XXFD_CAN_FIFOCON_FSIZE_BITS	5
-#  define MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT	24
-#  define MCP25XXFD_CAN_FIFOCON_FSIZE_MASK				\
-	GENMASK(MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT +			\
-		MCP25XXFD_CAN_FIFOCON_FSIZE_BITS - 1,			\
-		MCP25XXFD_CAN_FIFOCON_FSIZE_SHIFT)
-#  define MCP25XXFD_CAN_FIFOCON_PLSIZE_BITS	3
-#  define MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT	29
-#  define MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK				\
-	GENMASK(MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT +			\
-		MCP25XXFD_CAN_FIFOCON_PLSIZE_BITS - 1,			\
-		MCP25XXFD_CAN_FIFOCON_PLSIZE_SHIFT)
-#define MCP25XXFD_CAN_FIFOSTA(x)					\
-	MCP25XXFD_CAN_SFR_BASE(0x60 + 12 * ((x) - 1))
-#  define MCP25XXFD_CAN_FIFOSTA_TFNRFNIF	BIT(0)
-#  define MCP25XXFD_CAN_FIFOSTA_TFHRFHIF	BIT(1)
-#  define MCP25XXFD_CAN_FIFOSTA_TFERFFIF	BIT(2)
-#  define MCP25XXFD_CAN_FIFOSTA_RXOVIF		BIT(3)
-#  define MCP25XXFD_CAN_FIFOSTA_TXATIF		BIT(4)
-#  define MCP25XXFD_CAN_FIFOSTA_TXERR		BIT(5)
-#  define MCP25XXFD_CAN_FIFOSTA_TXLARB		BIT(6)
-#  define MCP25XXFD_CAN_FIFOSTA_TXABT		BIT(7)
-#  define MCP25XXFD_CAN_FIFOSTA_FIFOCI_BITS	5
-#  define MCP25XXFD_CAN_FIFOSTA_FIFOCI_SHIFT	8
-#  define MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK				\
-	GENMASK(MCP25XXFD_CAN_FIFOSTA_FIFOCI_SHIFT +			\
-		MCP25XXFD_CAN_FIFOSTA_FIFOCI_BITS - 1,			\
-		MCP25XXFD_CAN_FIFOSTA_FIFOCI_SHIFT)
-#define MCP25XXFD_CAN_FIFOUA(x)						\
-	MCP25XXFD_CAN_SFR_BASE(0x64 + 12 * ((x) - 1))
-#define MCP25XXFD_CAN_FLTCON(x)						\
-	MCP25XXFD_CAN_SFR_BASE(0x1D0 + ((x) & 0x1c))
-#  define MCP25XXFD_CAN_FILCON_SHIFT(x)		(((x) & 3) * 8)
-#  define MCP25XXFD_CAN_FILCON_BITS(x)		MCP25XXFD_CAN_FILCON_BITS_
-#  define MCP25XXFD_CAN_FILCON_BITS_		4
-	/* avoid macro reuse warning, so do not use GENMASK as above */
-#  define MCP25XXFD_CAN_FILCON_MASK(x)					\
-	(GENMASK(MCP25XXFD_CAN_FILCON_BITS_ - 1, 0) <<			\
-	 MCP25XXFD_CAN_FILCON_SHIFT(x))
-#  define MCP25XXFD_CAN_FIFOCON_FLTEN(x)				\
-	BIT(7 + MCP25XXFD_CAN_FILCON_SHIFT(x))
-#define MCP25XXFD_CAN_FLTOBJ(x)						\
-	MCP25XXFD_CAN_SFR_BASE(0x1F0 + 8 * (x))
-#  define MCP25XXFD_CAN_FILOBJ_SID_BITS		11
-#  define MCP25XXFD_CAN_FILOBJ_SID_SHIFT	0
-#  define MCP25XXFD_CAN_FILOBJ_SID_MASK					\
-	GENMASK(MCP25XXFD_CAN_FILOBJ_SID_SHIFT +			\
-		MCP25XXFD_CAN_FILOBJ_SID_BITS - 1,			\
-		MCP25XXFD_CAN_FILOBJ_SID_SHIFT)
-#  define MCP25XXFD_CAN_FILOBJ_EID_BITS		18
-#  define MCP25XXFD_CAN_FILOBJ_EID_SHIFT	12
-#  define MCP25XXFD_CAN_FILOBJ_EID_MASK					\
-	GENMASK(MCP25XXFD_CAN_FILOBJ_EID_SHIFT +			\
-		MCP25XXFD_CAN_FILOBJ_EID_BITS - 1,			\
-		MCP25XXFD_CAN_FILOBJ_EID_SHIFT)
-#  define MCP25XXFD_CAN_FILOBJ_SID11		BIT(29)
-#  define MCP25XXFD_CAN_FILOBJ_EXIDE		BIT(30)
-#define MCP25XXFD_CAN_FLTMASK(x)					\
-	MCP25XXFD_CAN_SFR_BASE(0x1F4 + 8 * (x))
-#  define MCP25XXFD_CAN_FILMASK_MSID_BITS	11
-#  define MCP25XXFD_CAN_FILMASK_MSID_SHIFT	0
-#  define MCP25XXFD_CAN_FILMASK_MSID_MASK				\
-	GENMASK(MCP25XXFD_CAN_FILMASK_MSID_SHIFT +			\
-		MCP25XXFD_CAN_FILMASK_MSID_BITS - 1,			\
-		MCP25XXFD_CAN_FILMASK_MSID_SHIFT)
-#  define MCP25XXFD_CAN_FILMASK_MEID_BITS	18
-#  define MCP25XXFD_CAN_FILMASK_MEID_SHIFT	12
-#  define MCP25XXFD_CAN_FILMASK_MEID_MASK				\
-	GENMASK(MCP25XXFD_CAN_FILMASK_MEID_SHIFT +			\
-		MCP25XXFD_CAN_FILMASK_MEID_BITS - 1,			\
-		MCP25XXFD_CAN_FILMASK_MEID_SHIFT)
-#  define MCP25XXFD_CAN_FILMASK_MSID11		BIT(29)
-#  define MCP25XXFD_CAN_FILMASK_MIDE		BIT(30)
-
-/* the FIFO Objects in SRAM */
-#define MCP25XXFD_SRAM_SIZE 2048
-#define MCP25XXFD_SRAM_ADDR(x) (0x400 + (x))
-
-/* memory structure in sram for tx fifos */
-struct mcp25xxfd_can_obj_tx {
-	u32 id;
-	u32 flags;
-	u8 data[];
-};
-
-/* memory structure in sram for rx fifos */
-struct mcp25xxfd_can_obj_rx {
-	u32 id;
-	u32 flags;
-	u32 ts;
-	u8 data[];
-};
-
-/* memory structure in sram for tef fifos */
-struct mcp25xxfd_can_obj_tef {
-	u32 id;
-	u32 flags;
-	u32 ts;
-};
-
-#define MCP25XXFD_CAN_OBJ_ID_SID_BITS		11
-#define MCP25XXFD_CAN_OBJ_ID_SID_SHIFT		0
-#define MCP25XXFD_CAN_OBJ_ID_SID_MASK					\
-	GENMASK(MCP25XXFD_CAN_OBJ_ID_SID_SHIFT +			\
-		MCP25XXFD_CAN_OBJ_ID_SID_BITS - 1,			\
-		MCP25XXFD_CAN_OBJ_ID_SID_SHIFT)
-#define MCP25XXFD_CAN_OBJ_ID_EID_BITS		18
-#define MCP25XXFD_CAN_OBJ_ID_EID_SHIFT		11
-#define MCP25XXFD_CAN_OBJ_ID_EID_MASK					\
-	GENMASK(MCP25XXFD_CAN_OBJ_ID_EID_SHIFT +			\
-		MCP25XXFD_CAN_OBJ_ID_EID_BITS - 1,			\
-		MCP25XXFD_CAN_OBJ_ID_EID_SHIFT)
-#define MCP25XXFD_CAN_OBJ_ID_SID_BIT11		BIT(29)
-
-#define MCP25XXFD_CAN_OBJ_FLAGS_DLC_BITS	4
-#define MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT	0
-#define MCP25XXFD_CAN_OBJ_FLAGS_DLC_MASK				\
-	GENMASK(MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT +			\
-		MCP25XXFD_CAN_OBJ_FLAGS_DLC_BITS - 1,			\
-		MCP25XXFD_CAN_OBJ_FLAGS_DLC_SHIFT)
-#define MCP25XXFD_CAN_OBJ_FLAGS_IDE		BIT(4)
-#define MCP25XXFD_CAN_OBJ_FLAGS_RTR		BIT(5)
-#define MCP25XXFD_CAN_OBJ_FLAGS_BRS		BIT(6)
-#define MCP25XXFD_CAN_OBJ_FLAGS_FDF		BIT(7)
-#define MCP25XXFD_CAN_OBJ_FLAGS_ESI		BIT(8)
-#define MCP25XXFD_CAN_OBJ_FLAGS_SEQ_BITS	7
-#define MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT	9
-#define MCP25XXFD_CAN_OBJ_FLAGS_SEQ_MASK				\
-	GENMASK(MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT +			\
-		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_BITS - 1,			\
-		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT)
-/* the mcp2518 has an extended number of SEQ bits */
-#define MCP25XXFD_CAN_OBJ_FLAGS_SEQX_BITS	23
-#define MCP25XXFD_CAN_OBJ_FLAGS_SEQX_MASK				\
-	GENMASK(MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT +			\
-		MCP25XXFD_CAN_OBJ_FLAGS_SEQX_BITS - 1,			\
-		MCP25XXFD_CAN_OBJ_FLAGS_SEQ_SHIFT)
-#define MCP25XXFD_CAN_OBJ_FLAGS_FILHIT_BITS	11
-#define MCP25XXFD_CAN_OBJ_FLAGS_FILHIT_SHIFT	5
-#define MCP25XXFD_CAN_OBJ_FLAGS_FILHIT_MASK				\
-	GENMASK(MCP25XXFD_CAN_FLAGS_FILHIT_SHIFT +			\
-		MCP25XXFD_CAN_FLAGS_FILHIT_BITS - 1,			\
-		MCP25XXFD_CAN_FLAGS_FILHIT_SHIFT)
-
-/* custom status error */
-#define MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_RX BIT(0)
-#define MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_SERR_TX BIT(1)
-#define MCP25XXFD_CAN_ERR_DATA7_MCP25XXFD_ECC	  BIT(2)
-
-#endif /* __MCP25XXFD_REGS_H */
-- 
2.11.0

